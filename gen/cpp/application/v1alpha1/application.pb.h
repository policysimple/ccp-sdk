// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: application/v1alpha1/application.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_application_2fv1alpha1_2fapplication_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_application_2fv1alpha1_2fapplication_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_application_2fv1alpha1_2fapplication_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_application_2fv1alpha1_2fapplication_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_application_2fv1alpha1_2fapplication_2eproto;
namespace application {
namespace v1alpha1 {
class Application;
struct ApplicationDefaultTypeInternal;
extern ApplicationDefaultTypeInternal _Application_default_instance_;
class Command;
struct CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class Configuration;
struct ConfigurationDefaultTypeInternal;
extern ConfigurationDefaultTypeInternal _Configuration_default_instance_;
class CreateApplicationRequest;
struct CreateApplicationRequestDefaultTypeInternal;
extern CreateApplicationRequestDefaultTypeInternal _CreateApplicationRequest_default_instance_;
class CreateApplicationResponse;
struct CreateApplicationResponseDefaultTypeInternal;
extern CreateApplicationResponseDefaultTypeInternal _CreateApplicationResponse_default_instance_;
class DeleteApplicationRequest;
struct DeleteApplicationRequestDefaultTypeInternal;
extern DeleteApplicationRequestDefaultTypeInternal _DeleteApplicationRequest_default_instance_;
class DeleteApplicationResponse;
struct DeleteApplicationResponseDefaultTypeInternal;
extern DeleteApplicationResponseDefaultTypeInternal _DeleteApplicationResponse_default_instance_;
class Env;
struct EnvDefaultTypeInternal;
extern EnvDefaultTypeInternal _Env_default_instance_;
class GetApplicationRequest;
struct GetApplicationRequestDefaultTypeInternal;
extern GetApplicationRequestDefaultTypeInternal _GetApplicationRequest_default_instance_;
class GetApplicationResponse;
struct GetApplicationResponseDefaultTypeInternal;
extern GetApplicationResponseDefaultTypeInternal _GetApplicationResponse_default_instance_;
class ListApplicationRequest;
struct ListApplicationRequestDefaultTypeInternal;
extern ListApplicationRequestDefaultTypeInternal _ListApplicationRequest_default_instance_;
class ListApplicationResponse;
struct ListApplicationResponseDefaultTypeInternal;
extern ListApplicationResponseDefaultTypeInternal _ListApplicationResponse_default_instance_;
class Repository;
struct RepositoryDefaultTypeInternal;
extern RepositoryDefaultTypeInternal _Repository_default_instance_;
class UpdateApplicationRequest;
struct UpdateApplicationRequestDefaultTypeInternal;
extern UpdateApplicationRequestDefaultTypeInternal _UpdateApplicationRequest_default_instance_;
class UpdateApplicationResponse;
struct UpdateApplicationResponseDefaultTypeInternal;
extern UpdateApplicationResponseDefaultTypeInternal _UpdateApplicationResponse_default_instance_;
}  // namespace v1alpha1
}  // namespace application
PROTOBUF_NAMESPACE_OPEN
template<> ::application::v1alpha1::Application* Arena::CreateMaybeMessage<::application::v1alpha1::Application>(Arena*);
template<> ::application::v1alpha1::Command* Arena::CreateMaybeMessage<::application::v1alpha1::Command>(Arena*);
template<> ::application::v1alpha1::Configuration* Arena::CreateMaybeMessage<::application::v1alpha1::Configuration>(Arena*);
template<> ::application::v1alpha1::CreateApplicationRequest* Arena::CreateMaybeMessage<::application::v1alpha1::CreateApplicationRequest>(Arena*);
template<> ::application::v1alpha1::CreateApplicationResponse* Arena::CreateMaybeMessage<::application::v1alpha1::CreateApplicationResponse>(Arena*);
template<> ::application::v1alpha1::DeleteApplicationRequest* Arena::CreateMaybeMessage<::application::v1alpha1::DeleteApplicationRequest>(Arena*);
template<> ::application::v1alpha1::DeleteApplicationResponse* Arena::CreateMaybeMessage<::application::v1alpha1::DeleteApplicationResponse>(Arena*);
template<> ::application::v1alpha1::Env* Arena::CreateMaybeMessage<::application::v1alpha1::Env>(Arena*);
template<> ::application::v1alpha1::GetApplicationRequest* Arena::CreateMaybeMessage<::application::v1alpha1::GetApplicationRequest>(Arena*);
template<> ::application::v1alpha1::GetApplicationResponse* Arena::CreateMaybeMessage<::application::v1alpha1::GetApplicationResponse>(Arena*);
template<> ::application::v1alpha1::ListApplicationRequest* Arena::CreateMaybeMessage<::application::v1alpha1::ListApplicationRequest>(Arena*);
template<> ::application::v1alpha1::ListApplicationResponse* Arena::CreateMaybeMessage<::application::v1alpha1::ListApplicationResponse>(Arena*);
template<> ::application::v1alpha1::Repository* Arena::CreateMaybeMessage<::application::v1alpha1::Repository>(Arena*);
template<> ::application::v1alpha1::UpdateApplicationRequest* Arena::CreateMaybeMessage<::application::v1alpha1::UpdateApplicationRequest>(Arena*);
template<> ::application::v1alpha1::UpdateApplicationResponse* Arena::CreateMaybeMessage<::application::v1alpha1::UpdateApplicationResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace application {
namespace v1alpha1 {

// ===================================================================

class Repository final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:application.v1alpha1.Repository) */ {
 public:
  inline Repository() : Repository(nullptr) {}
  ~Repository() override;
  explicit constexpr Repository(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Repository(const Repository& from);
  Repository(Repository&& from) noexcept
    : Repository() {
    *this = ::std::move(from);
  }

  inline Repository& operator=(const Repository& from) {
    CopyFrom(from);
    return *this;
  }
  inline Repository& operator=(Repository&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Repository& default_instance() {
    return *internal_default_instance();
  }
  static inline const Repository* internal_default_instance() {
    return reinterpret_cast<const Repository*>(
               &_Repository_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Repository& a, Repository& b) {
    a.Swap(&b);
  }
  inline void Swap(Repository* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Repository* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Repository* New() const final {
    return new Repository();
  }

  Repository* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Repository>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Repository& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Repository& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Repository* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "application.v1alpha1.Repository";
  }
  protected:
  explicit Repository(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFullNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kCloneUrlFieldNumber = 5,
    kForkFieldNumber = 4,
    kPrivateFieldNumber = 6,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string full_name = 2 [json_name = "fullName"];
  void clear_full_name();
  const std::string& full_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_full_name();
  void set_allocated_full_name(std::string* full_name);
  private:
  const std::string& _internal_full_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_name(const std::string& value);
  std::string* _internal_mutable_full_name();
  public:

  // string description = 3 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string clone_url = 5 [json_name = "cloneUrl"];
  void clear_clone_url();
  const std::string& clone_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clone_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clone_url();
  PROTOBUF_MUST_USE_RESULT std::string* release_clone_url();
  void set_allocated_clone_url(std::string* clone_url);
  private:
  const std::string& _internal_clone_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clone_url(const std::string& value);
  std::string* _internal_mutable_clone_url();
  public:

  // bool fork = 4 [json_name = "fork"];
  void clear_fork();
  bool fork() const;
  void set_fork(bool value);
  private:
  bool _internal_fork() const;
  void _internal_set_fork(bool value);
  public:

  // bool private = 6 [json_name = "private"];
  void clear_private_();
  bool private_() const;
  void set_private_(bool value);
  private:
  bool _internal_private_() const;
  void _internal_set_private_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:application.v1alpha1.Repository)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clone_url_;
  bool fork_;
  bool private__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_application_2fv1alpha1_2fapplication_2eproto;
};
// -------------------------------------------------------------------

class Command final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:application.v1alpha1.Command) */ {
 public:
  inline Command() : Command(nullptr) {}
  ~Command() override;
  explicit constexpr Command(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Command(const Command& from);
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command& operator=(Command&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Command& default_instance() {
    return *internal_default_instance();
  }
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Command* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Command* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return new Command();
  }

  Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Command& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Command& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "application.v1alpha1.Command";
  }
  protected:
  explicit Command(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuildFieldNumber = 1,
    kRunFieldNumber = 2,
  };
  // string build = 1 [json_name = "build"];
  void clear_build();
  const std::string& build() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_build(ArgT0&& arg0, ArgT... args);
  std::string* mutable_build();
  PROTOBUF_MUST_USE_RESULT std::string* release_build();
  void set_allocated_build(std::string* build);
  private:
  const std::string& _internal_build() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_build(const std::string& value);
  std::string* _internal_mutable_build();
  public:

  // string run = 2 [json_name = "run"];
  void clear_run();
  const std::string& run() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_run(ArgT0&& arg0, ArgT... args);
  std::string* mutable_run();
  PROTOBUF_MUST_USE_RESULT std::string* release_run();
  void set_allocated_run(std::string* run);
  private:
  const std::string& _internal_run() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_run(const std::string& value);
  std::string* _internal_mutable_run();
  public:

  // @@protoc_insertion_point(class_scope:application.v1alpha1.Command)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr build_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr run_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_application_2fv1alpha1_2fapplication_2eproto;
};
// -------------------------------------------------------------------

class Env final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:application.v1alpha1.Env) */ {
 public:
  inline Env() : Env(nullptr) {}
  ~Env() override;
  explicit constexpr Env(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Env(const Env& from);
  Env(Env&& from) noexcept
    : Env() {
    *this = ::std::move(from);
  }

  inline Env& operator=(const Env& from) {
    CopyFrom(from);
    return *this;
  }
  inline Env& operator=(Env&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Env& default_instance() {
    return *internal_default_instance();
  }
  static inline const Env* internal_default_instance() {
    return reinterpret_cast<const Env*>(
               &_Env_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Env& a, Env& b) {
    a.Swap(&b);
  }
  inline void Swap(Env* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Env* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Env* New() const final {
    return new Env();
  }

  Env* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Env>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Env& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Env& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Env* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "application.v1alpha1.Env";
  }
  protected:
  explicit Env(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kKeyFieldNumber = 2,
    kEncryptedFieldNumber = 3,
  };
  // string value = 1 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string key = 2 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bool encrypted = 3 [json_name = "encrypted"];
  void clear_encrypted();
  bool encrypted() const;
  void set_encrypted(bool value);
  private:
  bool _internal_encrypted() const;
  void _internal_set_encrypted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:application.v1alpha1.Env)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  bool encrypted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_application_2fv1alpha1_2fapplication_2eproto;
};
// -------------------------------------------------------------------

class Configuration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:application.v1alpha1.Configuration) */ {
 public:
  inline Configuration() : Configuration(nullptr) {}
  ~Configuration() override;
  explicit constexpr Configuration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Configuration(const Configuration& from);
  Configuration(Configuration&& from) noexcept
    : Configuration() {
    *this = ::std::move(from);
  }

  inline Configuration& operator=(const Configuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Configuration& operator=(Configuration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Configuration& default_instance() {
    return *internal_default_instance();
  }
  static inline const Configuration* internal_default_instance() {
    return reinterpret_cast<const Configuration*>(
               &_Configuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Configuration& a, Configuration& b) {
    a.Swap(&b);
  }
  inline void Swap(Configuration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Configuration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Configuration* New() const final {
    return new Configuration();
  }

  Configuration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Configuration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Configuration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Configuration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Configuration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "application.v1alpha1.Configuration";
  }
  protected:
  explicit Configuration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnvsFieldNumber = 1,
    kCommandsFieldNumber = 2,
    kPortFieldNumber = 3,
  };
  // repeated .application.v1alpha1.Env envs = 1 [json_name = "envs"];
  int envs_size() const;
  private:
  int _internal_envs_size() const;
  public:
  void clear_envs();
  ::application::v1alpha1::Env* mutable_envs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::application::v1alpha1::Env >*
      mutable_envs();
  private:
  const ::application::v1alpha1::Env& _internal_envs(int index) const;
  ::application::v1alpha1::Env* _internal_add_envs();
  public:
  const ::application::v1alpha1::Env& envs(int index) const;
  ::application::v1alpha1::Env* add_envs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::application::v1alpha1::Env >&
      envs() const;

  // repeated .application.v1alpha1.Command commands = 2 [json_name = "commands"];
  int commands_size() const;
  private:
  int _internal_commands_size() const;
  public:
  void clear_commands();
  ::application::v1alpha1::Command* mutable_commands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::application::v1alpha1::Command >*
      mutable_commands();
  private:
  const ::application::v1alpha1::Command& _internal_commands(int index) const;
  ::application::v1alpha1::Command* _internal_add_commands();
  public:
  const ::application::v1alpha1::Command& commands(int index) const;
  ::application::v1alpha1::Command* add_commands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::application::v1alpha1::Command >&
      commands() const;

  // int32 port = 3 [json_name = "port"];
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:application.v1alpha1.Configuration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::application::v1alpha1::Env > envs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::application::v1alpha1::Command > commands_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_application_2fv1alpha1_2fapplication_2eproto;
};
// -------------------------------------------------------------------

class Application final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:application.v1alpha1.Application) */ {
 public:
  inline Application() : Application(nullptr) {}
  ~Application() override;
  explicit constexpr Application(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Application(const Application& from);
  Application(Application&& from) noexcept
    : Application() {
    *this = ::std::move(from);
  }

  inline Application& operator=(const Application& from) {
    CopyFrom(from);
    return *this;
  }
  inline Application& operator=(Application&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Application& default_instance() {
    return *internal_default_instance();
  }
  static inline const Application* internal_default_instance() {
    return reinterpret_cast<const Application*>(
               &_Application_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Application& a, Application& b) {
    a.Swap(&b);
  }
  inline void Swap(Application* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Application* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Application* New() const final {
    return new Application();
  }

  Application* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Application>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Application& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Application& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Application* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "application.v1alpha1.Application";
  }
  protected:
  explicit Application(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kIntegrationFieldNumber = 3,
    kRepositoryFieldNumber = 4,
    kConfigurationFieldNumber = 5,
    kProjectIdFieldNumber = 6,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string integration = 3 [json_name = "integration"];
  void clear_integration();
  const std::string& integration() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_integration(ArgT0&& arg0, ArgT... args);
  std::string* mutable_integration();
  PROTOBUF_MUST_USE_RESULT std::string* release_integration();
  void set_allocated_integration(std::string* integration);
  private:
  const std::string& _internal_integration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integration(const std::string& value);
  std::string* _internal_mutable_integration();
  public:

  // .application.v1alpha1.Repository repository = 4 [json_name = "repository"];
  bool has_repository() const;
  private:
  bool _internal_has_repository() const;
  public:
  void clear_repository();
  const ::application::v1alpha1::Repository& repository() const;
  PROTOBUF_MUST_USE_RESULT ::application::v1alpha1::Repository* release_repository();
  ::application::v1alpha1::Repository* mutable_repository();
  void set_allocated_repository(::application::v1alpha1::Repository* repository);
  private:
  const ::application::v1alpha1::Repository& _internal_repository() const;
  ::application::v1alpha1::Repository* _internal_mutable_repository();
  public:
  void unsafe_arena_set_allocated_repository(
      ::application::v1alpha1::Repository* repository);
  ::application::v1alpha1::Repository* unsafe_arena_release_repository();

  // .application.v1alpha1.Configuration configuration = 5 [json_name = "configuration"];
  bool has_configuration() const;
  private:
  bool _internal_has_configuration() const;
  public:
  void clear_configuration();
  const ::application::v1alpha1::Configuration& configuration() const;
  PROTOBUF_MUST_USE_RESULT ::application::v1alpha1::Configuration* release_configuration();
  ::application::v1alpha1::Configuration* mutable_configuration();
  void set_allocated_configuration(::application::v1alpha1::Configuration* configuration);
  private:
  const ::application::v1alpha1::Configuration& _internal_configuration() const;
  ::application::v1alpha1::Configuration* _internal_mutable_configuration();
  public:
  void unsafe_arena_set_allocated_configuration(
      ::application::v1alpha1::Configuration* configuration);
  ::application::v1alpha1::Configuration* unsafe_arena_release_configuration();

  // uint32 project_id = 6 [json_name = "projectId"];
  void clear_project_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id() const;
  void set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_project_id() const;
  void _internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:application.v1alpha1.Application)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integration_;
  ::application::v1alpha1::Repository* repository_;
  ::application::v1alpha1::Configuration* configuration_;
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_application_2fv1alpha1_2fapplication_2eproto;
};
// -------------------------------------------------------------------

class CreateApplicationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:application.v1alpha1.CreateApplicationRequest) */ {
 public:
  inline CreateApplicationRequest() : CreateApplicationRequest(nullptr) {}
  ~CreateApplicationRequest() override;
  explicit constexpr CreateApplicationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateApplicationRequest(const CreateApplicationRequest& from);
  CreateApplicationRequest(CreateApplicationRequest&& from) noexcept
    : CreateApplicationRequest() {
    *this = ::std::move(from);
  }

  inline CreateApplicationRequest& operator=(const CreateApplicationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateApplicationRequest& operator=(CreateApplicationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateApplicationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateApplicationRequest* internal_default_instance() {
    return reinterpret_cast<const CreateApplicationRequest*>(
               &_CreateApplicationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateApplicationRequest& a, CreateApplicationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateApplicationRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateApplicationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateApplicationRequest* New() const final {
    return new CreateApplicationRequest();
  }

  CreateApplicationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateApplicationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateApplicationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateApplicationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateApplicationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "application.v1alpha1.CreateApplicationRequest";
  }
  protected:
  explicit CreateApplicationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIntegrationFieldNumber = 2,
    kRepositoryFieldNumber = 3,
    kConfigurationFieldNumber = 4,
    kProjectIdFieldNumber = 5,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string integration = 2 [json_name = "integration"];
  void clear_integration();
  const std::string& integration() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_integration(ArgT0&& arg0, ArgT... args);
  std::string* mutable_integration();
  PROTOBUF_MUST_USE_RESULT std::string* release_integration();
  void set_allocated_integration(std::string* integration);
  private:
  const std::string& _internal_integration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integration(const std::string& value);
  std::string* _internal_mutable_integration();
  public:

  // .application.v1alpha1.Repository repository = 3 [json_name = "repository"];
  bool has_repository() const;
  private:
  bool _internal_has_repository() const;
  public:
  void clear_repository();
  const ::application::v1alpha1::Repository& repository() const;
  PROTOBUF_MUST_USE_RESULT ::application::v1alpha1::Repository* release_repository();
  ::application::v1alpha1::Repository* mutable_repository();
  void set_allocated_repository(::application::v1alpha1::Repository* repository);
  private:
  const ::application::v1alpha1::Repository& _internal_repository() const;
  ::application::v1alpha1::Repository* _internal_mutable_repository();
  public:
  void unsafe_arena_set_allocated_repository(
      ::application::v1alpha1::Repository* repository);
  ::application::v1alpha1::Repository* unsafe_arena_release_repository();

  // .application.v1alpha1.Configuration configuration = 4 [json_name = "configuration"];
  bool has_configuration() const;
  private:
  bool _internal_has_configuration() const;
  public:
  void clear_configuration();
  const ::application::v1alpha1::Configuration& configuration() const;
  PROTOBUF_MUST_USE_RESULT ::application::v1alpha1::Configuration* release_configuration();
  ::application::v1alpha1::Configuration* mutable_configuration();
  void set_allocated_configuration(::application::v1alpha1::Configuration* configuration);
  private:
  const ::application::v1alpha1::Configuration& _internal_configuration() const;
  ::application::v1alpha1::Configuration* _internal_mutable_configuration();
  public:
  void unsafe_arena_set_allocated_configuration(
      ::application::v1alpha1::Configuration* configuration);
  ::application::v1alpha1::Configuration* unsafe_arena_release_configuration();

  // uint32 project_id = 5 [json_name = "projectId"];
  void clear_project_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id() const;
  void set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_project_id() const;
  void _internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:application.v1alpha1.CreateApplicationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integration_;
  ::application::v1alpha1::Repository* repository_;
  ::application::v1alpha1::Configuration* configuration_;
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_application_2fv1alpha1_2fapplication_2eproto;
};
// -------------------------------------------------------------------

class CreateApplicationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:application.v1alpha1.CreateApplicationResponse) */ {
 public:
  inline CreateApplicationResponse() : CreateApplicationResponse(nullptr) {}
  ~CreateApplicationResponse() override;
  explicit constexpr CreateApplicationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateApplicationResponse(const CreateApplicationResponse& from);
  CreateApplicationResponse(CreateApplicationResponse&& from) noexcept
    : CreateApplicationResponse() {
    *this = ::std::move(from);
  }

  inline CreateApplicationResponse& operator=(const CreateApplicationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateApplicationResponse& operator=(CreateApplicationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateApplicationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateApplicationResponse* internal_default_instance() {
    return reinterpret_cast<const CreateApplicationResponse*>(
               &_CreateApplicationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CreateApplicationResponse& a, CreateApplicationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateApplicationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateApplicationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateApplicationResponse* New() const final {
    return new CreateApplicationResponse();
  }

  CreateApplicationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateApplicationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateApplicationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateApplicationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateApplicationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "application.v1alpha1.CreateApplicationResponse";
  }
  protected:
  explicit CreateApplicationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:application.v1alpha1.CreateApplicationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_application_2fv1alpha1_2fapplication_2eproto;
};
// -------------------------------------------------------------------

class ListApplicationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:application.v1alpha1.ListApplicationRequest) */ {
 public:
  inline ListApplicationRequest() : ListApplicationRequest(nullptr) {}
  ~ListApplicationRequest() override;
  explicit constexpr ListApplicationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListApplicationRequest(const ListApplicationRequest& from);
  ListApplicationRequest(ListApplicationRequest&& from) noexcept
    : ListApplicationRequest() {
    *this = ::std::move(from);
  }

  inline ListApplicationRequest& operator=(const ListApplicationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListApplicationRequest& operator=(ListApplicationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListApplicationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListApplicationRequest* internal_default_instance() {
    return reinterpret_cast<const ListApplicationRequest*>(
               &_ListApplicationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListApplicationRequest& a, ListApplicationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListApplicationRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListApplicationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListApplicationRequest* New() const final {
    return new ListApplicationRequest();
  }

  ListApplicationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListApplicationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListApplicationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListApplicationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListApplicationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "application.v1alpha1.ListApplicationRequest";
  }
  protected:
  explicit ListApplicationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectIdFieldNumber = 1,
  };
  // uint32 project_id = 1 [json_name = "projectId"];
  void clear_project_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id() const;
  void set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_project_id() const;
  void _internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:application.v1alpha1.ListApplicationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_application_2fv1alpha1_2fapplication_2eproto;
};
// -------------------------------------------------------------------

class ListApplicationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:application.v1alpha1.ListApplicationResponse) */ {
 public:
  inline ListApplicationResponse() : ListApplicationResponse(nullptr) {}
  ~ListApplicationResponse() override;
  explicit constexpr ListApplicationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListApplicationResponse(const ListApplicationResponse& from);
  ListApplicationResponse(ListApplicationResponse&& from) noexcept
    : ListApplicationResponse() {
    *this = ::std::move(from);
  }

  inline ListApplicationResponse& operator=(const ListApplicationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListApplicationResponse& operator=(ListApplicationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListApplicationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListApplicationResponse* internal_default_instance() {
    return reinterpret_cast<const ListApplicationResponse*>(
               &_ListApplicationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ListApplicationResponse& a, ListApplicationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListApplicationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListApplicationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListApplicationResponse* New() const final {
    return new ListApplicationResponse();
  }

  ListApplicationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListApplicationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListApplicationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListApplicationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListApplicationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "application.v1alpha1.ListApplicationResponse";
  }
  protected:
  explicit ListApplicationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApplicationsFieldNumber = 1,
  };
  // repeated .application.v1alpha1.Application applications = 1 [json_name = "applications"];
  int applications_size() const;
  private:
  int _internal_applications_size() const;
  public:
  void clear_applications();
  ::application::v1alpha1::Application* mutable_applications(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::application::v1alpha1::Application >*
      mutable_applications();
  private:
  const ::application::v1alpha1::Application& _internal_applications(int index) const;
  ::application::v1alpha1::Application* _internal_add_applications();
  public:
  const ::application::v1alpha1::Application& applications(int index) const;
  ::application::v1alpha1::Application* add_applications();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::application::v1alpha1::Application >&
      applications() const;

  // @@protoc_insertion_point(class_scope:application.v1alpha1.ListApplicationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::application::v1alpha1::Application > applications_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_application_2fv1alpha1_2fapplication_2eproto;
};
// -------------------------------------------------------------------

class GetApplicationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:application.v1alpha1.GetApplicationRequest) */ {
 public:
  inline GetApplicationRequest() : GetApplicationRequest(nullptr) {}
  ~GetApplicationRequest() override;
  explicit constexpr GetApplicationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetApplicationRequest(const GetApplicationRequest& from);
  GetApplicationRequest(GetApplicationRequest&& from) noexcept
    : GetApplicationRequest() {
    *this = ::std::move(from);
  }

  inline GetApplicationRequest& operator=(const GetApplicationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetApplicationRequest& operator=(GetApplicationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetApplicationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetApplicationRequest* internal_default_instance() {
    return reinterpret_cast<const GetApplicationRequest*>(
               &_GetApplicationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetApplicationRequest& a, GetApplicationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetApplicationRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetApplicationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetApplicationRequest* New() const final {
    return new GetApplicationRequest();
  }

  GetApplicationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetApplicationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetApplicationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetApplicationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetApplicationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "application.v1alpha1.GetApplicationRequest";
  }
  protected:
  explicit GetApplicationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:application.v1alpha1.GetApplicationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_application_2fv1alpha1_2fapplication_2eproto;
};
// -------------------------------------------------------------------

class GetApplicationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:application.v1alpha1.GetApplicationResponse) */ {
 public:
  inline GetApplicationResponse() : GetApplicationResponse(nullptr) {}
  ~GetApplicationResponse() override;
  explicit constexpr GetApplicationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetApplicationResponse(const GetApplicationResponse& from);
  GetApplicationResponse(GetApplicationResponse&& from) noexcept
    : GetApplicationResponse() {
    *this = ::std::move(from);
  }

  inline GetApplicationResponse& operator=(const GetApplicationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetApplicationResponse& operator=(GetApplicationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetApplicationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetApplicationResponse* internal_default_instance() {
    return reinterpret_cast<const GetApplicationResponse*>(
               &_GetApplicationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetApplicationResponse& a, GetApplicationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetApplicationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetApplicationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetApplicationResponse* New() const final {
    return new GetApplicationResponse();
  }

  GetApplicationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetApplicationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetApplicationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetApplicationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetApplicationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "application.v1alpha1.GetApplicationResponse";
  }
  protected:
  explicit GetApplicationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApplicationFieldNumber = 1,
  };
  // .application.v1alpha1.Application application = 1 [json_name = "application"];
  bool has_application() const;
  private:
  bool _internal_has_application() const;
  public:
  void clear_application();
  const ::application::v1alpha1::Application& application() const;
  PROTOBUF_MUST_USE_RESULT ::application::v1alpha1::Application* release_application();
  ::application::v1alpha1::Application* mutable_application();
  void set_allocated_application(::application::v1alpha1::Application* application);
  private:
  const ::application::v1alpha1::Application& _internal_application() const;
  ::application::v1alpha1::Application* _internal_mutable_application();
  public:
  void unsafe_arena_set_allocated_application(
      ::application::v1alpha1::Application* application);
  ::application::v1alpha1::Application* unsafe_arena_release_application();

  // @@protoc_insertion_point(class_scope:application.v1alpha1.GetApplicationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::application::v1alpha1::Application* application_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_application_2fv1alpha1_2fapplication_2eproto;
};
// -------------------------------------------------------------------

class DeleteApplicationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:application.v1alpha1.DeleteApplicationRequest) */ {
 public:
  inline DeleteApplicationRequest() : DeleteApplicationRequest(nullptr) {}
  ~DeleteApplicationRequest() override;
  explicit constexpr DeleteApplicationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteApplicationRequest(const DeleteApplicationRequest& from);
  DeleteApplicationRequest(DeleteApplicationRequest&& from) noexcept
    : DeleteApplicationRequest() {
    *this = ::std::move(from);
  }

  inline DeleteApplicationRequest& operator=(const DeleteApplicationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteApplicationRequest& operator=(DeleteApplicationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteApplicationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteApplicationRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteApplicationRequest*>(
               &_DeleteApplicationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DeleteApplicationRequest& a, DeleteApplicationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteApplicationRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteApplicationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteApplicationRequest* New() const final {
    return new DeleteApplicationRequest();
  }

  DeleteApplicationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteApplicationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteApplicationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteApplicationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteApplicationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "application.v1alpha1.DeleteApplicationRequest";
  }
  protected:
  explicit DeleteApplicationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:application.v1alpha1.DeleteApplicationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_application_2fv1alpha1_2fapplication_2eproto;
};
// -------------------------------------------------------------------

class DeleteApplicationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:application.v1alpha1.DeleteApplicationResponse) */ {
 public:
  inline DeleteApplicationResponse() : DeleteApplicationResponse(nullptr) {}
  ~DeleteApplicationResponse() override;
  explicit constexpr DeleteApplicationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteApplicationResponse(const DeleteApplicationResponse& from);
  DeleteApplicationResponse(DeleteApplicationResponse&& from) noexcept
    : DeleteApplicationResponse() {
    *this = ::std::move(from);
  }

  inline DeleteApplicationResponse& operator=(const DeleteApplicationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteApplicationResponse& operator=(DeleteApplicationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteApplicationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteApplicationResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteApplicationResponse*>(
               &_DeleteApplicationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeleteApplicationResponse& a, DeleteApplicationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteApplicationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteApplicationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteApplicationResponse* New() const final {
    return new DeleteApplicationResponse();
  }

  DeleteApplicationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteApplicationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteApplicationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteApplicationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteApplicationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "application.v1alpha1.DeleteApplicationResponse";
  }
  protected:
  explicit DeleteApplicationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:application.v1alpha1.DeleteApplicationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_application_2fv1alpha1_2fapplication_2eproto;
};
// -------------------------------------------------------------------

class UpdateApplicationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:application.v1alpha1.UpdateApplicationRequest) */ {
 public:
  inline UpdateApplicationRequest() : UpdateApplicationRequest(nullptr) {}
  ~UpdateApplicationRequest() override;
  explicit constexpr UpdateApplicationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateApplicationRequest(const UpdateApplicationRequest& from);
  UpdateApplicationRequest(UpdateApplicationRequest&& from) noexcept
    : UpdateApplicationRequest() {
    *this = ::std::move(from);
  }

  inline UpdateApplicationRequest& operator=(const UpdateApplicationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateApplicationRequest& operator=(UpdateApplicationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateApplicationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateApplicationRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateApplicationRequest*>(
               &_UpdateApplicationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UpdateApplicationRequest& a, UpdateApplicationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateApplicationRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateApplicationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateApplicationRequest* New() const final {
    return new UpdateApplicationRequest();
  }

  UpdateApplicationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateApplicationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateApplicationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateApplicationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateApplicationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "application.v1alpha1.UpdateApplicationRequest";
  }
  protected:
  explicit UpdateApplicationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kApplicationFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .application.v1alpha1.CreateApplicationRequest application = 2 [json_name = "application"];
  bool has_application() const;
  private:
  bool _internal_has_application() const;
  public:
  void clear_application();
  const ::application::v1alpha1::CreateApplicationRequest& application() const;
  PROTOBUF_MUST_USE_RESULT ::application::v1alpha1::CreateApplicationRequest* release_application();
  ::application::v1alpha1::CreateApplicationRequest* mutable_application();
  void set_allocated_application(::application::v1alpha1::CreateApplicationRequest* application);
  private:
  const ::application::v1alpha1::CreateApplicationRequest& _internal_application() const;
  ::application::v1alpha1::CreateApplicationRequest* _internal_mutable_application();
  public:
  void unsafe_arena_set_allocated_application(
      ::application::v1alpha1::CreateApplicationRequest* application);
  ::application::v1alpha1::CreateApplicationRequest* unsafe_arena_release_application();

  // @@protoc_insertion_point(class_scope:application.v1alpha1.UpdateApplicationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::application::v1alpha1::CreateApplicationRequest* application_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_application_2fv1alpha1_2fapplication_2eproto;
};
// -------------------------------------------------------------------

class UpdateApplicationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:application.v1alpha1.UpdateApplicationResponse) */ {
 public:
  inline UpdateApplicationResponse() : UpdateApplicationResponse(nullptr) {}
  ~UpdateApplicationResponse() override;
  explicit constexpr UpdateApplicationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateApplicationResponse(const UpdateApplicationResponse& from);
  UpdateApplicationResponse(UpdateApplicationResponse&& from) noexcept
    : UpdateApplicationResponse() {
    *this = ::std::move(from);
  }

  inline UpdateApplicationResponse& operator=(const UpdateApplicationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateApplicationResponse& operator=(UpdateApplicationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateApplicationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateApplicationResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateApplicationResponse*>(
               &_UpdateApplicationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UpdateApplicationResponse& a, UpdateApplicationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateApplicationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateApplicationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateApplicationResponse* New() const final {
    return new UpdateApplicationResponse();
  }

  UpdateApplicationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateApplicationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateApplicationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateApplicationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateApplicationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "application.v1alpha1.UpdateApplicationResponse";
  }
  protected:
  explicit UpdateApplicationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:application.v1alpha1.UpdateApplicationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_application_2fv1alpha1_2fapplication_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Repository

// string name = 1 [json_name = "name"];
inline void Repository::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Repository::name() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Repository.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Repository::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.Repository.name)
}
inline std::string* Repository::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.Repository.name)
  return _s;
}
inline const std::string& Repository::_internal_name() const {
  return name_.Get();
}
inline void Repository::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Repository::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Repository::release_name() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.Repository.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Repository::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.Repository.name)
}

// string full_name = 2 [json_name = "fullName"];
inline void Repository::clear_full_name() {
  full_name_.ClearToEmpty();
}
inline const std::string& Repository::full_name() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Repository.full_name)
  return _internal_full_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Repository::set_full_name(ArgT0&& arg0, ArgT... args) {
 
 full_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.Repository.full_name)
}
inline std::string* Repository::mutable_full_name() {
  std::string* _s = _internal_mutable_full_name();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.Repository.full_name)
  return _s;
}
inline const std::string& Repository::_internal_full_name() const {
  return full_name_.Get();
}
inline void Repository::_internal_set_full_name(const std::string& value) {
  
  full_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Repository::_internal_mutable_full_name() {
  
  return full_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Repository::release_full_name() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.Repository.full_name)
  return full_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Repository::set_allocated_full_name(std::string* full_name) {
  if (full_name != nullptr) {
    
  } else {
    
  }
  full_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), full_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.Repository.full_name)
}

// string description = 3 [json_name = "description"];
inline void Repository::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& Repository::description() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Repository.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Repository::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.Repository.description)
}
inline std::string* Repository::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.Repository.description)
  return _s;
}
inline const std::string& Repository::_internal_description() const {
  return description_.Get();
}
inline void Repository::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Repository::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Repository::release_description() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.Repository.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Repository::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.Repository.description)
}

// bool fork = 4 [json_name = "fork"];
inline void Repository::clear_fork() {
  fork_ = false;
}
inline bool Repository::_internal_fork() const {
  return fork_;
}
inline bool Repository::fork() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Repository.fork)
  return _internal_fork();
}
inline void Repository::_internal_set_fork(bool value) {
  
  fork_ = value;
}
inline void Repository::set_fork(bool value) {
  _internal_set_fork(value);
  // @@protoc_insertion_point(field_set:application.v1alpha1.Repository.fork)
}

// string clone_url = 5 [json_name = "cloneUrl"];
inline void Repository::clear_clone_url() {
  clone_url_.ClearToEmpty();
}
inline const std::string& Repository::clone_url() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Repository.clone_url)
  return _internal_clone_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Repository::set_clone_url(ArgT0&& arg0, ArgT... args) {
 
 clone_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.Repository.clone_url)
}
inline std::string* Repository::mutable_clone_url() {
  std::string* _s = _internal_mutable_clone_url();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.Repository.clone_url)
  return _s;
}
inline const std::string& Repository::_internal_clone_url() const {
  return clone_url_.Get();
}
inline void Repository::_internal_set_clone_url(const std::string& value) {
  
  clone_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Repository::_internal_mutable_clone_url() {
  
  return clone_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Repository::release_clone_url() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.Repository.clone_url)
  return clone_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Repository::set_allocated_clone_url(std::string* clone_url) {
  if (clone_url != nullptr) {
    
  } else {
    
  }
  clone_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clone_url,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.Repository.clone_url)
}

// bool private = 6 [json_name = "private"];
inline void Repository::clear_private_() {
  private__ = false;
}
inline bool Repository::_internal_private_() const {
  return private__;
}
inline bool Repository::private_() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Repository.private)
  return _internal_private_();
}
inline void Repository::_internal_set_private_(bool value) {
  
  private__ = value;
}
inline void Repository::set_private_(bool value) {
  _internal_set_private_(value);
  // @@protoc_insertion_point(field_set:application.v1alpha1.Repository.private)
}

// -------------------------------------------------------------------

// Command

// string build = 1 [json_name = "build"];
inline void Command::clear_build() {
  build_.ClearToEmpty();
}
inline const std::string& Command::build() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Command.build)
  return _internal_build();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Command::set_build(ArgT0&& arg0, ArgT... args) {
 
 build_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.Command.build)
}
inline std::string* Command::mutable_build() {
  std::string* _s = _internal_mutable_build();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.Command.build)
  return _s;
}
inline const std::string& Command::_internal_build() const {
  return build_.Get();
}
inline void Command::_internal_set_build(const std::string& value) {
  
  build_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Command::_internal_mutable_build() {
  
  return build_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Command::release_build() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.Command.build)
  return build_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Command::set_allocated_build(std::string* build) {
  if (build != nullptr) {
    
  } else {
    
  }
  build_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), build,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.Command.build)
}

// string run = 2 [json_name = "run"];
inline void Command::clear_run() {
  run_.ClearToEmpty();
}
inline const std::string& Command::run() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Command.run)
  return _internal_run();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Command::set_run(ArgT0&& arg0, ArgT... args) {
 
 run_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.Command.run)
}
inline std::string* Command::mutable_run() {
  std::string* _s = _internal_mutable_run();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.Command.run)
  return _s;
}
inline const std::string& Command::_internal_run() const {
  return run_.Get();
}
inline void Command::_internal_set_run(const std::string& value) {
  
  run_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Command::_internal_mutable_run() {
  
  return run_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Command::release_run() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.Command.run)
  return run_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Command::set_allocated_run(std::string* run) {
  if (run != nullptr) {
    
  } else {
    
  }
  run_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), run,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.Command.run)
}

// -------------------------------------------------------------------

// Env

// string value = 1 [json_name = "value"];
inline void Env::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Env::value() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Env.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Env::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.Env.value)
}
inline std::string* Env::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.Env.value)
  return _s;
}
inline const std::string& Env::_internal_value() const {
  return value_.Get();
}
inline void Env::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Env::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Env::release_value() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.Env.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Env::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.Env.value)
}

// string key = 2 [json_name = "key"];
inline void Env::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& Env::key() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Env.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Env::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.Env.key)
}
inline std::string* Env::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.Env.key)
  return _s;
}
inline const std::string& Env::_internal_key() const {
  return key_.Get();
}
inline void Env::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Env::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Env::release_key() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.Env.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Env::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.Env.key)
}

// bool encrypted = 3 [json_name = "encrypted"];
inline void Env::clear_encrypted() {
  encrypted_ = false;
}
inline bool Env::_internal_encrypted() const {
  return encrypted_;
}
inline bool Env::encrypted() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Env.encrypted)
  return _internal_encrypted();
}
inline void Env::_internal_set_encrypted(bool value) {
  
  encrypted_ = value;
}
inline void Env::set_encrypted(bool value) {
  _internal_set_encrypted(value);
  // @@protoc_insertion_point(field_set:application.v1alpha1.Env.encrypted)
}

// -------------------------------------------------------------------

// Configuration

// repeated .application.v1alpha1.Env envs = 1 [json_name = "envs"];
inline int Configuration::_internal_envs_size() const {
  return envs_.size();
}
inline int Configuration::envs_size() const {
  return _internal_envs_size();
}
inline void Configuration::clear_envs() {
  envs_.Clear();
}
inline ::application::v1alpha1::Env* Configuration::mutable_envs(int index) {
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.Configuration.envs)
  return envs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::application::v1alpha1::Env >*
Configuration::mutable_envs() {
  // @@protoc_insertion_point(field_mutable_list:application.v1alpha1.Configuration.envs)
  return &envs_;
}
inline const ::application::v1alpha1::Env& Configuration::_internal_envs(int index) const {
  return envs_.Get(index);
}
inline const ::application::v1alpha1::Env& Configuration::envs(int index) const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Configuration.envs)
  return _internal_envs(index);
}
inline ::application::v1alpha1::Env* Configuration::_internal_add_envs() {
  return envs_.Add();
}
inline ::application::v1alpha1::Env* Configuration::add_envs() {
  ::application::v1alpha1::Env* _add = _internal_add_envs();
  // @@protoc_insertion_point(field_add:application.v1alpha1.Configuration.envs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::application::v1alpha1::Env >&
Configuration::envs() const {
  // @@protoc_insertion_point(field_list:application.v1alpha1.Configuration.envs)
  return envs_;
}

// repeated .application.v1alpha1.Command commands = 2 [json_name = "commands"];
inline int Configuration::_internal_commands_size() const {
  return commands_.size();
}
inline int Configuration::commands_size() const {
  return _internal_commands_size();
}
inline void Configuration::clear_commands() {
  commands_.Clear();
}
inline ::application::v1alpha1::Command* Configuration::mutable_commands(int index) {
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.Configuration.commands)
  return commands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::application::v1alpha1::Command >*
Configuration::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_list:application.v1alpha1.Configuration.commands)
  return &commands_;
}
inline const ::application::v1alpha1::Command& Configuration::_internal_commands(int index) const {
  return commands_.Get(index);
}
inline const ::application::v1alpha1::Command& Configuration::commands(int index) const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Configuration.commands)
  return _internal_commands(index);
}
inline ::application::v1alpha1::Command* Configuration::_internal_add_commands() {
  return commands_.Add();
}
inline ::application::v1alpha1::Command* Configuration::add_commands() {
  ::application::v1alpha1::Command* _add = _internal_add_commands();
  // @@protoc_insertion_point(field_add:application.v1alpha1.Configuration.commands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::application::v1alpha1::Command >&
Configuration::commands() const {
  // @@protoc_insertion_point(field_list:application.v1alpha1.Configuration.commands)
  return commands_;
}

// int32 port = 3 [json_name = "port"];
inline void Configuration::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Configuration::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Configuration::port() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Configuration.port)
  return _internal_port();
}
inline void Configuration::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
}
inline void Configuration::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:application.v1alpha1.Configuration.port)
}

// -------------------------------------------------------------------

// Application

// string id = 1 [json_name = "id"];
inline void Application::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Application::id() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Application.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Application::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.Application.id)
}
inline std::string* Application::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.Application.id)
  return _s;
}
inline const std::string& Application::_internal_id() const {
  return id_.Get();
}
inline void Application::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Application::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Application::release_id() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.Application.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Application::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.Application.id)
}

// string name = 2 [json_name = "name"];
inline void Application::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Application::name() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Application.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Application::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.Application.name)
}
inline std::string* Application::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.Application.name)
  return _s;
}
inline const std::string& Application::_internal_name() const {
  return name_.Get();
}
inline void Application::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Application::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Application::release_name() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.Application.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Application::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.Application.name)
}

// string integration = 3 [json_name = "integration"];
inline void Application::clear_integration() {
  integration_.ClearToEmpty();
}
inline const std::string& Application::integration() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Application.integration)
  return _internal_integration();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Application::set_integration(ArgT0&& arg0, ArgT... args) {
 
 integration_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.Application.integration)
}
inline std::string* Application::mutable_integration() {
  std::string* _s = _internal_mutable_integration();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.Application.integration)
  return _s;
}
inline const std::string& Application::_internal_integration() const {
  return integration_.Get();
}
inline void Application::_internal_set_integration(const std::string& value) {
  
  integration_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Application::_internal_mutable_integration() {
  
  return integration_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Application::release_integration() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.Application.integration)
  return integration_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Application::set_allocated_integration(std::string* integration) {
  if (integration != nullptr) {
    
  } else {
    
  }
  integration_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), integration,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.Application.integration)
}

// .application.v1alpha1.Repository repository = 4 [json_name = "repository"];
inline bool Application::_internal_has_repository() const {
  return this != internal_default_instance() && repository_ != nullptr;
}
inline bool Application::has_repository() const {
  return _internal_has_repository();
}
inline void Application::clear_repository() {
  if (GetArenaForAllocation() == nullptr && repository_ != nullptr) {
    delete repository_;
  }
  repository_ = nullptr;
}
inline const ::application::v1alpha1::Repository& Application::_internal_repository() const {
  const ::application::v1alpha1::Repository* p = repository_;
  return p != nullptr ? *p : reinterpret_cast<const ::application::v1alpha1::Repository&>(
      ::application::v1alpha1::_Repository_default_instance_);
}
inline const ::application::v1alpha1::Repository& Application::repository() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Application.repository)
  return _internal_repository();
}
inline void Application::unsafe_arena_set_allocated_repository(
    ::application::v1alpha1::Repository* repository) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(repository_);
  }
  repository_ = repository;
  if (repository) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:application.v1alpha1.Application.repository)
}
inline ::application::v1alpha1::Repository* Application::release_repository() {
  
  ::application::v1alpha1::Repository* temp = repository_;
  repository_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::application::v1alpha1::Repository* Application::unsafe_arena_release_repository() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.Application.repository)
  
  ::application::v1alpha1::Repository* temp = repository_;
  repository_ = nullptr;
  return temp;
}
inline ::application::v1alpha1::Repository* Application::_internal_mutable_repository() {
  
  if (repository_ == nullptr) {
    auto* p = CreateMaybeMessage<::application::v1alpha1::Repository>(GetArenaForAllocation());
    repository_ = p;
  }
  return repository_;
}
inline ::application::v1alpha1::Repository* Application::mutable_repository() {
  ::application::v1alpha1::Repository* _msg = _internal_mutable_repository();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.Application.repository)
  return _msg;
}
inline void Application::set_allocated_repository(::application::v1alpha1::Repository* repository) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete repository_;
  }
  if (repository) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::application::v1alpha1::Repository>::GetOwningArena(repository);
    if (message_arena != submessage_arena) {
      repository = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repository, submessage_arena);
    }
    
  } else {
    
  }
  repository_ = repository;
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.Application.repository)
}

// .application.v1alpha1.Configuration configuration = 5 [json_name = "configuration"];
inline bool Application::_internal_has_configuration() const {
  return this != internal_default_instance() && configuration_ != nullptr;
}
inline bool Application::has_configuration() const {
  return _internal_has_configuration();
}
inline void Application::clear_configuration() {
  if (GetArenaForAllocation() == nullptr && configuration_ != nullptr) {
    delete configuration_;
  }
  configuration_ = nullptr;
}
inline const ::application::v1alpha1::Configuration& Application::_internal_configuration() const {
  const ::application::v1alpha1::Configuration* p = configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::application::v1alpha1::Configuration&>(
      ::application::v1alpha1::_Configuration_default_instance_);
}
inline const ::application::v1alpha1::Configuration& Application::configuration() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Application.configuration)
  return _internal_configuration();
}
inline void Application::unsafe_arena_set_allocated_configuration(
    ::application::v1alpha1::Configuration* configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(configuration_);
  }
  configuration_ = configuration;
  if (configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:application.v1alpha1.Application.configuration)
}
inline ::application::v1alpha1::Configuration* Application::release_configuration() {
  
  ::application::v1alpha1::Configuration* temp = configuration_;
  configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::application::v1alpha1::Configuration* Application::unsafe_arena_release_configuration() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.Application.configuration)
  
  ::application::v1alpha1::Configuration* temp = configuration_;
  configuration_ = nullptr;
  return temp;
}
inline ::application::v1alpha1::Configuration* Application::_internal_mutable_configuration() {
  
  if (configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::application::v1alpha1::Configuration>(GetArenaForAllocation());
    configuration_ = p;
  }
  return configuration_;
}
inline ::application::v1alpha1::Configuration* Application::mutable_configuration() {
  ::application::v1alpha1::Configuration* _msg = _internal_mutable_configuration();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.Application.configuration)
  return _msg;
}
inline void Application::set_allocated_configuration(::application::v1alpha1::Configuration* configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete configuration_;
  }
  if (configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::application::v1alpha1::Configuration>::GetOwningArena(configuration);
    if (message_arena != submessage_arena) {
      configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, configuration, submessage_arena);
    }
    
  } else {
    
  }
  configuration_ = configuration;
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.Application.configuration)
}

// uint32 project_id = 6 [json_name = "projectId"];
inline void Application::clear_project_id() {
  project_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Application::_internal_project_id() const {
  return project_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Application::project_id() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.Application.project_id)
  return _internal_project_id();
}
inline void Application::_internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  project_id_ = value;
}
inline void Application::set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_project_id(value);
  // @@protoc_insertion_point(field_set:application.v1alpha1.Application.project_id)
}

// -------------------------------------------------------------------

// CreateApplicationRequest

// string name = 1 [json_name = "name"];
inline void CreateApplicationRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateApplicationRequest::name() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.CreateApplicationRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateApplicationRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.CreateApplicationRequest.name)
}
inline std::string* CreateApplicationRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.CreateApplicationRequest.name)
  return _s;
}
inline const std::string& CreateApplicationRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateApplicationRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateApplicationRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateApplicationRequest::release_name() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.CreateApplicationRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateApplicationRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.CreateApplicationRequest.name)
}

// string integration = 2 [json_name = "integration"];
inline void CreateApplicationRequest::clear_integration() {
  integration_.ClearToEmpty();
}
inline const std::string& CreateApplicationRequest::integration() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.CreateApplicationRequest.integration)
  return _internal_integration();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateApplicationRequest::set_integration(ArgT0&& arg0, ArgT... args) {
 
 integration_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.CreateApplicationRequest.integration)
}
inline std::string* CreateApplicationRequest::mutable_integration() {
  std::string* _s = _internal_mutable_integration();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.CreateApplicationRequest.integration)
  return _s;
}
inline const std::string& CreateApplicationRequest::_internal_integration() const {
  return integration_.Get();
}
inline void CreateApplicationRequest::_internal_set_integration(const std::string& value) {
  
  integration_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateApplicationRequest::_internal_mutable_integration() {
  
  return integration_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateApplicationRequest::release_integration() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.CreateApplicationRequest.integration)
  return integration_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateApplicationRequest::set_allocated_integration(std::string* integration) {
  if (integration != nullptr) {
    
  } else {
    
  }
  integration_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), integration,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.CreateApplicationRequest.integration)
}

// .application.v1alpha1.Repository repository = 3 [json_name = "repository"];
inline bool CreateApplicationRequest::_internal_has_repository() const {
  return this != internal_default_instance() && repository_ != nullptr;
}
inline bool CreateApplicationRequest::has_repository() const {
  return _internal_has_repository();
}
inline void CreateApplicationRequest::clear_repository() {
  if (GetArenaForAllocation() == nullptr && repository_ != nullptr) {
    delete repository_;
  }
  repository_ = nullptr;
}
inline const ::application::v1alpha1::Repository& CreateApplicationRequest::_internal_repository() const {
  const ::application::v1alpha1::Repository* p = repository_;
  return p != nullptr ? *p : reinterpret_cast<const ::application::v1alpha1::Repository&>(
      ::application::v1alpha1::_Repository_default_instance_);
}
inline const ::application::v1alpha1::Repository& CreateApplicationRequest::repository() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.CreateApplicationRequest.repository)
  return _internal_repository();
}
inline void CreateApplicationRequest::unsafe_arena_set_allocated_repository(
    ::application::v1alpha1::Repository* repository) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(repository_);
  }
  repository_ = repository;
  if (repository) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:application.v1alpha1.CreateApplicationRequest.repository)
}
inline ::application::v1alpha1::Repository* CreateApplicationRequest::release_repository() {
  
  ::application::v1alpha1::Repository* temp = repository_;
  repository_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::application::v1alpha1::Repository* CreateApplicationRequest::unsafe_arena_release_repository() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.CreateApplicationRequest.repository)
  
  ::application::v1alpha1::Repository* temp = repository_;
  repository_ = nullptr;
  return temp;
}
inline ::application::v1alpha1::Repository* CreateApplicationRequest::_internal_mutable_repository() {
  
  if (repository_ == nullptr) {
    auto* p = CreateMaybeMessage<::application::v1alpha1::Repository>(GetArenaForAllocation());
    repository_ = p;
  }
  return repository_;
}
inline ::application::v1alpha1::Repository* CreateApplicationRequest::mutable_repository() {
  ::application::v1alpha1::Repository* _msg = _internal_mutable_repository();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.CreateApplicationRequest.repository)
  return _msg;
}
inline void CreateApplicationRequest::set_allocated_repository(::application::v1alpha1::Repository* repository) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete repository_;
  }
  if (repository) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::application::v1alpha1::Repository>::GetOwningArena(repository);
    if (message_arena != submessage_arena) {
      repository = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repository, submessage_arena);
    }
    
  } else {
    
  }
  repository_ = repository;
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.CreateApplicationRequest.repository)
}

// .application.v1alpha1.Configuration configuration = 4 [json_name = "configuration"];
inline bool CreateApplicationRequest::_internal_has_configuration() const {
  return this != internal_default_instance() && configuration_ != nullptr;
}
inline bool CreateApplicationRequest::has_configuration() const {
  return _internal_has_configuration();
}
inline void CreateApplicationRequest::clear_configuration() {
  if (GetArenaForAllocation() == nullptr && configuration_ != nullptr) {
    delete configuration_;
  }
  configuration_ = nullptr;
}
inline const ::application::v1alpha1::Configuration& CreateApplicationRequest::_internal_configuration() const {
  const ::application::v1alpha1::Configuration* p = configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::application::v1alpha1::Configuration&>(
      ::application::v1alpha1::_Configuration_default_instance_);
}
inline const ::application::v1alpha1::Configuration& CreateApplicationRequest::configuration() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.CreateApplicationRequest.configuration)
  return _internal_configuration();
}
inline void CreateApplicationRequest::unsafe_arena_set_allocated_configuration(
    ::application::v1alpha1::Configuration* configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(configuration_);
  }
  configuration_ = configuration;
  if (configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:application.v1alpha1.CreateApplicationRequest.configuration)
}
inline ::application::v1alpha1::Configuration* CreateApplicationRequest::release_configuration() {
  
  ::application::v1alpha1::Configuration* temp = configuration_;
  configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::application::v1alpha1::Configuration* CreateApplicationRequest::unsafe_arena_release_configuration() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.CreateApplicationRequest.configuration)
  
  ::application::v1alpha1::Configuration* temp = configuration_;
  configuration_ = nullptr;
  return temp;
}
inline ::application::v1alpha1::Configuration* CreateApplicationRequest::_internal_mutable_configuration() {
  
  if (configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::application::v1alpha1::Configuration>(GetArenaForAllocation());
    configuration_ = p;
  }
  return configuration_;
}
inline ::application::v1alpha1::Configuration* CreateApplicationRequest::mutable_configuration() {
  ::application::v1alpha1::Configuration* _msg = _internal_mutable_configuration();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.CreateApplicationRequest.configuration)
  return _msg;
}
inline void CreateApplicationRequest::set_allocated_configuration(::application::v1alpha1::Configuration* configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete configuration_;
  }
  if (configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::application::v1alpha1::Configuration>::GetOwningArena(configuration);
    if (message_arena != submessage_arena) {
      configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, configuration, submessage_arena);
    }
    
  } else {
    
  }
  configuration_ = configuration;
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.CreateApplicationRequest.configuration)
}

// uint32 project_id = 5 [json_name = "projectId"];
inline void CreateApplicationRequest::clear_project_id() {
  project_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateApplicationRequest::_internal_project_id() const {
  return project_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateApplicationRequest::project_id() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.CreateApplicationRequest.project_id)
  return _internal_project_id();
}
inline void CreateApplicationRequest::_internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  project_id_ = value;
}
inline void CreateApplicationRequest::set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_project_id(value);
  // @@protoc_insertion_point(field_set:application.v1alpha1.CreateApplicationRequest.project_id)
}

// -------------------------------------------------------------------

// CreateApplicationResponse

// string msg = 1 [json_name = "msg"];
inline void CreateApplicationResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& CreateApplicationResponse::msg() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.CreateApplicationResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateApplicationResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.CreateApplicationResponse.msg)
}
inline std::string* CreateApplicationResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.CreateApplicationResponse.msg)
  return _s;
}
inline const std::string& CreateApplicationResponse::_internal_msg() const {
  return msg_.Get();
}
inline void CreateApplicationResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateApplicationResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateApplicationResponse::release_msg() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.CreateApplicationResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateApplicationResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.CreateApplicationResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void CreateApplicationResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& CreateApplicationResponse::error() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.CreateApplicationResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateApplicationResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.CreateApplicationResponse.error)
}
inline std::string* CreateApplicationResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.CreateApplicationResponse.error)
  return _s;
}
inline const std::string& CreateApplicationResponse::_internal_error() const {
  return error_.Get();
}
inline void CreateApplicationResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateApplicationResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateApplicationResponse::release_error() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.CreateApplicationResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateApplicationResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.CreateApplicationResponse.error)
}

// -------------------------------------------------------------------

// ListApplicationRequest

// uint32 project_id = 1 [json_name = "projectId"];
inline void ListApplicationRequest::clear_project_id() {
  project_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListApplicationRequest::_internal_project_id() const {
  return project_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListApplicationRequest::project_id() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.ListApplicationRequest.project_id)
  return _internal_project_id();
}
inline void ListApplicationRequest::_internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  project_id_ = value;
}
inline void ListApplicationRequest::set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_project_id(value);
  // @@protoc_insertion_point(field_set:application.v1alpha1.ListApplicationRequest.project_id)
}

// -------------------------------------------------------------------

// ListApplicationResponse

// repeated .application.v1alpha1.Application applications = 1 [json_name = "applications"];
inline int ListApplicationResponse::_internal_applications_size() const {
  return applications_.size();
}
inline int ListApplicationResponse::applications_size() const {
  return _internal_applications_size();
}
inline void ListApplicationResponse::clear_applications() {
  applications_.Clear();
}
inline ::application::v1alpha1::Application* ListApplicationResponse::mutable_applications(int index) {
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.ListApplicationResponse.applications)
  return applications_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::application::v1alpha1::Application >*
ListApplicationResponse::mutable_applications() {
  // @@protoc_insertion_point(field_mutable_list:application.v1alpha1.ListApplicationResponse.applications)
  return &applications_;
}
inline const ::application::v1alpha1::Application& ListApplicationResponse::_internal_applications(int index) const {
  return applications_.Get(index);
}
inline const ::application::v1alpha1::Application& ListApplicationResponse::applications(int index) const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.ListApplicationResponse.applications)
  return _internal_applications(index);
}
inline ::application::v1alpha1::Application* ListApplicationResponse::_internal_add_applications() {
  return applications_.Add();
}
inline ::application::v1alpha1::Application* ListApplicationResponse::add_applications() {
  ::application::v1alpha1::Application* _add = _internal_add_applications();
  // @@protoc_insertion_point(field_add:application.v1alpha1.ListApplicationResponse.applications)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::application::v1alpha1::Application >&
ListApplicationResponse::applications() const {
  // @@protoc_insertion_point(field_list:application.v1alpha1.ListApplicationResponse.applications)
  return applications_;
}

// -------------------------------------------------------------------

// GetApplicationRequest

// string id = 1 [json_name = "id"];
inline void GetApplicationRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetApplicationRequest::id() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.GetApplicationRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetApplicationRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.GetApplicationRequest.id)
}
inline std::string* GetApplicationRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.GetApplicationRequest.id)
  return _s;
}
inline const std::string& GetApplicationRequest::_internal_id() const {
  return id_.Get();
}
inline void GetApplicationRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetApplicationRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetApplicationRequest::release_id() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.GetApplicationRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetApplicationRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.GetApplicationRequest.id)
}

// -------------------------------------------------------------------

// GetApplicationResponse

// .application.v1alpha1.Application application = 1 [json_name = "application"];
inline bool GetApplicationResponse::_internal_has_application() const {
  return this != internal_default_instance() && application_ != nullptr;
}
inline bool GetApplicationResponse::has_application() const {
  return _internal_has_application();
}
inline void GetApplicationResponse::clear_application() {
  if (GetArenaForAllocation() == nullptr && application_ != nullptr) {
    delete application_;
  }
  application_ = nullptr;
}
inline const ::application::v1alpha1::Application& GetApplicationResponse::_internal_application() const {
  const ::application::v1alpha1::Application* p = application_;
  return p != nullptr ? *p : reinterpret_cast<const ::application::v1alpha1::Application&>(
      ::application::v1alpha1::_Application_default_instance_);
}
inline const ::application::v1alpha1::Application& GetApplicationResponse::application() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.GetApplicationResponse.application)
  return _internal_application();
}
inline void GetApplicationResponse::unsafe_arena_set_allocated_application(
    ::application::v1alpha1::Application* application) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(application_);
  }
  application_ = application;
  if (application) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:application.v1alpha1.GetApplicationResponse.application)
}
inline ::application::v1alpha1::Application* GetApplicationResponse::release_application() {
  
  ::application::v1alpha1::Application* temp = application_;
  application_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::application::v1alpha1::Application* GetApplicationResponse::unsafe_arena_release_application() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.GetApplicationResponse.application)
  
  ::application::v1alpha1::Application* temp = application_;
  application_ = nullptr;
  return temp;
}
inline ::application::v1alpha1::Application* GetApplicationResponse::_internal_mutable_application() {
  
  if (application_ == nullptr) {
    auto* p = CreateMaybeMessage<::application::v1alpha1::Application>(GetArenaForAllocation());
    application_ = p;
  }
  return application_;
}
inline ::application::v1alpha1::Application* GetApplicationResponse::mutable_application() {
  ::application::v1alpha1::Application* _msg = _internal_mutable_application();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.GetApplicationResponse.application)
  return _msg;
}
inline void GetApplicationResponse::set_allocated_application(::application::v1alpha1::Application* application) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete application_;
  }
  if (application) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::application::v1alpha1::Application>::GetOwningArena(application);
    if (message_arena != submessage_arena) {
      application = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, application, submessage_arena);
    }
    
  } else {
    
  }
  application_ = application;
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.GetApplicationResponse.application)
}

// -------------------------------------------------------------------

// DeleteApplicationRequest

// string id = 1 [json_name = "id"];
inline void DeleteApplicationRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteApplicationRequest::id() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.DeleteApplicationRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteApplicationRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.DeleteApplicationRequest.id)
}
inline std::string* DeleteApplicationRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.DeleteApplicationRequest.id)
  return _s;
}
inline const std::string& DeleteApplicationRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteApplicationRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteApplicationRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteApplicationRequest::release_id() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.DeleteApplicationRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteApplicationRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.DeleteApplicationRequest.id)
}

// -------------------------------------------------------------------

// DeleteApplicationResponse

// string msg = 1 [json_name = "msg"];
inline void DeleteApplicationResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& DeleteApplicationResponse::msg() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.DeleteApplicationResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteApplicationResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.DeleteApplicationResponse.msg)
}
inline std::string* DeleteApplicationResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.DeleteApplicationResponse.msg)
  return _s;
}
inline const std::string& DeleteApplicationResponse::_internal_msg() const {
  return msg_.Get();
}
inline void DeleteApplicationResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteApplicationResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteApplicationResponse::release_msg() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.DeleteApplicationResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteApplicationResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.DeleteApplicationResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void DeleteApplicationResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& DeleteApplicationResponse::error() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.DeleteApplicationResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteApplicationResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.DeleteApplicationResponse.error)
}
inline std::string* DeleteApplicationResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.DeleteApplicationResponse.error)
  return _s;
}
inline const std::string& DeleteApplicationResponse::_internal_error() const {
  return error_.Get();
}
inline void DeleteApplicationResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteApplicationResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteApplicationResponse::release_error() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.DeleteApplicationResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteApplicationResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.DeleteApplicationResponse.error)
}

// -------------------------------------------------------------------

// UpdateApplicationRequest

// string id = 1 [json_name = "id"];
inline void UpdateApplicationRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UpdateApplicationRequest::id() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.UpdateApplicationRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateApplicationRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.UpdateApplicationRequest.id)
}
inline std::string* UpdateApplicationRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.UpdateApplicationRequest.id)
  return _s;
}
inline const std::string& UpdateApplicationRequest::_internal_id() const {
  return id_.Get();
}
inline void UpdateApplicationRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateApplicationRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateApplicationRequest::release_id() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.UpdateApplicationRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateApplicationRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.UpdateApplicationRequest.id)
}

// .application.v1alpha1.CreateApplicationRequest application = 2 [json_name = "application"];
inline bool UpdateApplicationRequest::_internal_has_application() const {
  return this != internal_default_instance() && application_ != nullptr;
}
inline bool UpdateApplicationRequest::has_application() const {
  return _internal_has_application();
}
inline void UpdateApplicationRequest::clear_application() {
  if (GetArenaForAllocation() == nullptr && application_ != nullptr) {
    delete application_;
  }
  application_ = nullptr;
}
inline const ::application::v1alpha1::CreateApplicationRequest& UpdateApplicationRequest::_internal_application() const {
  const ::application::v1alpha1::CreateApplicationRequest* p = application_;
  return p != nullptr ? *p : reinterpret_cast<const ::application::v1alpha1::CreateApplicationRequest&>(
      ::application::v1alpha1::_CreateApplicationRequest_default_instance_);
}
inline const ::application::v1alpha1::CreateApplicationRequest& UpdateApplicationRequest::application() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.UpdateApplicationRequest.application)
  return _internal_application();
}
inline void UpdateApplicationRequest::unsafe_arena_set_allocated_application(
    ::application::v1alpha1::CreateApplicationRequest* application) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(application_);
  }
  application_ = application;
  if (application) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:application.v1alpha1.UpdateApplicationRequest.application)
}
inline ::application::v1alpha1::CreateApplicationRequest* UpdateApplicationRequest::release_application() {
  
  ::application::v1alpha1::CreateApplicationRequest* temp = application_;
  application_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::application::v1alpha1::CreateApplicationRequest* UpdateApplicationRequest::unsafe_arena_release_application() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.UpdateApplicationRequest.application)
  
  ::application::v1alpha1::CreateApplicationRequest* temp = application_;
  application_ = nullptr;
  return temp;
}
inline ::application::v1alpha1::CreateApplicationRequest* UpdateApplicationRequest::_internal_mutable_application() {
  
  if (application_ == nullptr) {
    auto* p = CreateMaybeMessage<::application::v1alpha1::CreateApplicationRequest>(GetArenaForAllocation());
    application_ = p;
  }
  return application_;
}
inline ::application::v1alpha1::CreateApplicationRequest* UpdateApplicationRequest::mutable_application() {
  ::application::v1alpha1::CreateApplicationRequest* _msg = _internal_mutable_application();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.UpdateApplicationRequest.application)
  return _msg;
}
inline void UpdateApplicationRequest::set_allocated_application(::application::v1alpha1::CreateApplicationRequest* application) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete application_;
  }
  if (application) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::application::v1alpha1::CreateApplicationRequest>::GetOwningArena(application);
    if (message_arena != submessage_arena) {
      application = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, application, submessage_arena);
    }
    
  } else {
    
  }
  application_ = application;
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.UpdateApplicationRequest.application)
}

// -------------------------------------------------------------------

// UpdateApplicationResponse

// string msg = 1 [json_name = "msg"];
inline void UpdateApplicationResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& UpdateApplicationResponse::msg() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.UpdateApplicationResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateApplicationResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.UpdateApplicationResponse.msg)
}
inline std::string* UpdateApplicationResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.UpdateApplicationResponse.msg)
  return _s;
}
inline const std::string& UpdateApplicationResponse::_internal_msg() const {
  return msg_.Get();
}
inline void UpdateApplicationResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateApplicationResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateApplicationResponse::release_msg() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.UpdateApplicationResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateApplicationResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.UpdateApplicationResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void UpdateApplicationResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& UpdateApplicationResponse::error() const {
  // @@protoc_insertion_point(field_get:application.v1alpha1.UpdateApplicationResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateApplicationResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:application.v1alpha1.UpdateApplicationResponse.error)
}
inline std::string* UpdateApplicationResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:application.v1alpha1.UpdateApplicationResponse.error)
  return _s;
}
inline const std::string& UpdateApplicationResponse::_internal_error() const {
  return error_.Get();
}
inline void UpdateApplicationResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateApplicationResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateApplicationResponse::release_error() {
  // @@protoc_insertion_point(field_release:application.v1alpha1.UpdateApplicationResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateApplicationResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:application.v1alpha1.UpdateApplicationResponse.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace application

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_application_2fv1alpha1_2fapplication_2eproto
