// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: payment/v1alpha1/payment.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_payment_2fv1alpha1_2fpayment_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_payment_2fv1alpha1_2fpayment_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_payment_2fv1alpha1_2fpayment_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_payment_2fv1alpha1_2fpayment_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[19]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_payment_2fv1alpha1_2fpayment_2eproto;
namespace payment {
namespace v1alpha1 {
class Biling;
struct BilingDefaultTypeInternal;
extern BilingDefaultTypeInternal _Biling_default_instance_;
class BilingList;
struct BilingListDefaultTypeInternal;
extern BilingListDefaultTypeInternal _BilingList_default_instance_;
class BlockChain;
struct BlockChainDefaultTypeInternal;
extern BlockChainDefaultTypeInternal _BlockChain_default_instance_;
class Card;
struct CardDefaultTypeInternal;
extern CardDefaultTypeInternal _Card_default_instance_;
class CardList;
struct CardListDefaultTypeInternal;
extern CardListDefaultTypeInternal _CardList_default_instance_;
class Customer;
struct CustomerDefaultTypeInternal;
extern CustomerDefaultTypeInternal _Customer_default_instance_;
class CustomerList;
struct CustomerListDefaultTypeInternal;
extern CustomerListDefaultTypeInternal _CustomerList_default_instance_;
class Invoice;
struct InvoiceDefaultTypeInternal;
extern InvoiceDefaultTypeInternal _Invoice_default_instance_;
class InvoiceList;
struct InvoiceListDefaultTypeInternal;
extern InvoiceListDefaultTypeInternal _InvoiceList_default_instance_;
class Payment;
struct PaymentDefaultTypeInternal;
extern PaymentDefaultTypeInternal _Payment_default_instance_;
class PaymentList;
struct PaymentListDefaultTypeInternal;
extern PaymentListDefaultTypeInternal _PaymentList_default_instance_;
class Project;
struct ProjectDefaultTypeInternal;
extern ProjectDefaultTypeInternal _Project_default_instance_;
class ProjectBilling;
struct ProjectBillingDefaultTypeInternal;
extern ProjectBillingDefaultTypeInternal _ProjectBilling_default_instance_;
class ProjectBillingList;
struct ProjectBillingListDefaultTypeInternal;
extern ProjectBillingListDefaultTypeInternal _ProjectBillingList_default_instance_;
class ProjectList;
struct ProjectListDefaultTypeInternal;
extern ProjectListDefaultTypeInternal _ProjectList_default_instance_;
class Subscription;
struct SubscriptionDefaultTypeInternal;
extern SubscriptionDefaultTypeInternal _Subscription_default_instance_;
class SubscriptionItems;
struct SubscriptionItemsDefaultTypeInternal;
extern SubscriptionItemsDefaultTypeInternal _SubscriptionItems_default_instance_;
class SubscriptionItemsList;
struct SubscriptionItemsListDefaultTypeInternal;
extern SubscriptionItemsListDefaultTypeInternal _SubscriptionItemsList_default_instance_;
class SubscriptionList;
struct SubscriptionListDefaultTypeInternal;
extern SubscriptionListDefaultTypeInternal _SubscriptionList_default_instance_;
}  // namespace v1alpha1
}  // namespace payment
PROTOBUF_NAMESPACE_OPEN
template<> ::payment::v1alpha1::Biling* Arena::CreateMaybeMessage<::payment::v1alpha1::Biling>(Arena*);
template<> ::payment::v1alpha1::BilingList* Arena::CreateMaybeMessage<::payment::v1alpha1::BilingList>(Arena*);
template<> ::payment::v1alpha1::BlockChain* Arena::CreateMaybeMessage<::payment::v1alpha1::BlockChain>(Arena*);
template<> ::payment::v1alpha1::Card* Arena::CreateMaybeMessage<::payment::v1alpha1::Card>(Arena*);
template<> ::payment::v1alpha1::CardList* Arena::CreateMaybeMessage<::payment::v1alpha1::CardList>(Arena*);
template<> ::payment::v1alpha1::Customer* Arena::CreateMaybeMessage<::payment::v1alpha1::Customer>(Arena*);
template<> ::payment::v1alpha1::CustomerList* Arena::CreateMaybeMessage<::payment::v1alpha1::CustomerList>(Arena*);
template<> ::payment::v1alpha1::Invoice* Arena::CreateMaybeMessage<::payment::v1alpha1::Invoice>(Arena*);
template<> ::payment::v1alpha1::InvoiceList* Arena::CreateMaybeMessage<::payment::v1alpha1::InvoiceList>(Arena*);
template<> ::payment::v1alpha1::Payment* Arena::CreateMaybeMessage<::payment::v1alpha1::Payment>(Arena*);
template<> ::payment::v1alpha1::PaymentList* Arena::CreateMaybeMessage<::payment::v1alpha1::PaymentList>(Arena*);
template<> ::payment::v1alpha1::Project* Arena::CreateMaybeMessage<::payment::v1alpha1::Project>(Arena*);
template<> ::payment::v1alpha1::ProjectBilling* Arena::CreateMaybeMessage<::payment::v1alpha1::ProjectBilling>(Arena*);
template<> ::payment::v1alpha1::ProjectBillingList* Arena::CreateMaybeMessage<::payment::v1alpha1::ProjectBillingList>(Arena*);
template<> ::payment::v1alpha1::ProjectList* Arena::CreateMaybeMessage<::payment::v1alpha1::ProjectList>(Arena*);
template<> ::payment::v1alpha1::Subscription* Arena::CreateMaybeMessage<::payment::v1alpha1::Subscription>(Arena*);
template<> ::payment::v1alpha1::SubscriptionItems* Arena::CreateMaybeMessage<::payment::v1alpha1::SubscriptionItems>(Arena*);
template<> ::payment::v1alpha1::SubscriptionItemsList* Arena::CreateMaybeMessage<::payment::v1alpha1::SubscriptionItemsList>(Arena*);
template<> ::payment::v1alpha1::SubscriptionList* Arena::CreateMaybeMessage<::payment::v1alpha1::SubscriptionList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace payment {
namespace v1alpha1 {

// ===================================================================

class Customer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.Customer) */ {
 public:
  inline Customer() : Customer(nullptr) {}
  ~Customer() override;
  explicit constexpr Customer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Customer(const Customer& from);
  Customer(Customer&& from) noexcept
    : Customer() {
    *this = ::std::move(from);
  }

  inline Customer& operator=(const Customer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Customer& operator=(Customer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Customer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Customer* internal_default_instance() {
    return reinterpret_cast<const Customer*>(
               &_Customer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Customer& a, Customer& b) {
    a.Swap(&b);
  }
  inline void Swap(Customer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Customer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Customer* New() const final {
    return new Customer();
  }

  Customer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Customer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Customer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Customer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Customer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.Customer";
  }
  protected:
  explicit Customer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectsFieldNumber = 10,
    kBlockchainsFieldNumber = 11,
    kIdFieldNumber = 1,
    kCustomerIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 3,
    kNameFieldNumber = 4,
    kEmailFieldNumber = 5,
    kDefaultpaymentmethodFieldNumber = 6,
    kPaymentsFieldNumber = 7,
    kInvoiceFieldNumber = 8,
    kBilingFieldNumber = 9,
  };
  // repeated .payment.v1alpha1.Project projects = 10 [json_name = "projects"];
  int projects_size() const;
  private:
  int _internal_projects_size() const;
  public:
  void clear_projects();
  ::payment::v1alpha1::Project* mutable_projects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Project >*
      mutable_projects();
  private:
  const ::payment::v1alpha1::Project& _internal_projects(int index) const;
  ::payment::v1alpha1::Project* _internal_add_projects();
  public:
  const ::payment::v1alpha1::Project& projects(int index) const;
  ::payment::v1alpha1::Project* add_projects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Project >&
      projects() const;

  // repeated .payment.v1alpha1.BlockChain blockchains = 11 [json_name = "blockchains"];
  int blockchains_size() const;
  private:
  int _internal_blockchains_size() const;
  public:
  void clear_blockchains();
  ::payment::v1alpha1::BlockChain* mutable_blockchains(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::BlockChain >*
      mutable_blockchains();
  private:
  const ::payment::v1alpha1::BlockChain& _internal_blockchains(int index) const;
  ::payment::v1alpha1::BlockChain* _internal_add_blockchains();
  public:
  const ::payment::v1alpha1::BlockChain& blockchains(int index) const;
  ::payment::v1alpha1::BlockChain* add_blockchains();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::BlockChain >&
      blockchains() const;

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // string organization_id = 3 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string name = 4 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string email = 5 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_MUST_USE_RESULT std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string defaultpaymentmethod = 6 [json_name = "defaultpaymentmethod"];
  void clear_defaultpaymentmethod();
  const std::string& defaultpaymentmethod() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_defaultpaymentmethod(ArgT0&& arg0, ArgT... args);
  std::string* mutable_defaultpaymentmethod();
  PROTOBUF_MUST_USE_RESULT std::string* release_defaultpaymentmethod();
  void set_allocated_defaultpaymentmethod(std::string* defaultpaymentmethod);
  private:
  const std::string& _internal_defaultpaymentmethod() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_defaultpaymentmethod(const std::string& value);
  std::string* _internal_mutable_defaultpaymentmethod();
  public:

  // .payment.v1alpha1.PaymentList payments = 7 [json_name = "payments"];
  bool has_payments() const;
  private:
  bool _internal_has_payments() const;
  public:
  void clear_payments();
  const ::payment::v1alpha1::PaymentList& payments() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::PaymentList* release_payments();
  ::payment::v1alpha1::PaymentList* mutable_payments();
  void set_allocated_payments(::payment::v1alpha1::PaymentList* payments);
  private:
  const ::payment::v1alpha1::PaymentList& _internal_payments() const;
  ::payment::v1alpha1::PaymentList* _internal_mutable_payments();
  public:
  void unsafe_arena_set_allocated_payments(
      ::payment::v1alpha1::PaymentList* payments);
  ::payment::v1alpha1::PaymentList* unsafe_arena_release_payments();

  // .payment.v1alpha1.Invoice invoice = 8 [json_name = "invoice"];
  bool has_invoice() const;
  private:
  bool _internal_has_invoice() const;
  public:
  void clear_invoice();
  const ::payment::v1alpha1::Invoice& invoice() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Invoice* release_invoice();
  ::payment::v1alpha1::Invoice* mutable_invoice();
  void set_allocated_invoice(::payment::v1alpha1::Invoice* invoice);
  private:
  const ::payment::v1alpha1::Invoice& _internal_invoice() const;
  ::payment::v1alpha1::Invoice* _internal_mutable_invoice();
  public:
  void unsafe_arena_set_allocated_invoice(
      ::payment::v1alpha1::Invoice* invoice);
  ::payment::v1alpha1::Invoice* unsafe_arena_release_invoice();

  // .payment.v1alpha1.Biling biling = 9 [json_name = "biling"];
  bool has_biling() const;
  private:
  bool _internal_has_biling() const;
  public:
  void clear_biling();
  const ::payment::v1alpha1::Biling& biling() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Biling* release_biling();
  ::payment::v1alpha1::Biling* mutable_biling();
  void set_allocated_biling(::payment::v1alpha1::Biling* biling);
  private:
  const ::payment::v1alpha1::Biling& _internal_biling() const;
  ::payment::v1alpha1::Biling* _internal_mutable_biling();
  public:
  void unsafe_arena_set_allocated_biling(
      ::payment::v1alpha1::Biling* biling);
  ::payment::v1alpha1::Biling* unsafe_arena_release_biling();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.Customer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Project > projects_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::BlockChain > blockchains_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr defaultpaymentmethod_;
  ::payment::v1alpha1::PaymentList* payments_;
  ::payment::v1alpha1::Invoice* invoice_;
  ::payment::v1alpha1::Biling* biling_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class Project final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.Project) */ {
 public:
  inline Project() : Project(nullptr) {}
  ~Project() override;
  explicit constexpr Project(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Project(const Project& from);
  Project(Project&& from) noexcept
    : Project() {
    *this = ::std::move(from);
  }

  inline Project& operator=(const Project& from) {
    CopyFrom(from);
    return *this;
  }
  inline Project& operator=(Project&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Project& default_instance() {
    return *internal_default_instance();
  }
  static inline const Project* internal_default_instance() {
    return reinterpret_cast<const Project*>(
               &_Project_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Project& a, Project& b) {
    a.Swap(&b);
  }
  inline void Swap(Project* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Project* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Project* New() const final {
    return new Project();
  }

  Project* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Project>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Project& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Project& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Project* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.Project";
  }
  protected:
  explicit Project(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kImageFieldNumber = 3,
    kBudgetFieldNumber = 4,
    kDescriptionFieldNumber = 5,
    kCreatedAtFieldNumber = 6,
    kUpdatedAtFieldNumber = 7,
    kSubscriptionFieldNumber = 8,
    kStatusFieldNumber = 9,
    kIsSuspendedFieldNumber = 10,
  };
  // string project_id = 1 [json_name = "projectId"];
  void clear_project_id();
  const std::string& project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_project_id();
  void set_allocated_project_id(std::string* project_id);
  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(const std::string& value);
  std::string* _internal_mutable_project_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string image = 3 [json_name = "image"];
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_MUST_USE_RESULT std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // string budget = 4 [json_name = "budget"];
  void clear_budget();
  const std::string& budget() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_budget(ArgT0&& arg0, ArgT... args);
  std::string* mutable_budget();
  PROTOBUF_MUST_USE_RESULT std::string* release_budget();
  void set_allocated_budget(std::string* budget);
  private:
  const std::string& _internal_budget() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_budget(const std::string& value);
  std::string* _internal_mutable_budget();
  public:

  // string description = 5 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string created_at = 6 [json_name = "createdAt"];
  void clear_created_at();
  const std::string& created_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_at();
  PROTOBUF_MUST_USE_RESULT std::string* release_created_at();
  void set_allocated_created_at(std::string* created_at);
  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(const std::string& value);
  std::string* _internal_mutable_created_at();
  public:

  // string updated_at = 7 [json_name = "updatedAt"];
  void clear_updated_at();
  const std::string& updated_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_updated_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_updated_at();
  PROTOBUF_MUST_USE_RESULT std::string* release_updated_at();
  void set_allocated_updated_at(std::string* updated_at);
  private:
  const std::string& _internal_updated_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_at(const std::string& value);
  std::string* _internal_mutable_updated_at();
  public:

  // .payment.v1alpha1.Subscription subscription = 8 [json_name = "subscription"];
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::payment::v1alpha1::Subscription& subscription() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Subscription* release_subscription();
  ::payment::v1alpha1::Subscription* mutable_subscription();
  void set_allocated_subscription(::payment::v1alpha1::Subscription* subscription);
  private:
  const ::payment::v1alpha1::Subscription& _internal_subscription() const;
  ::payment::v1alpha1::Subscription* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::payment::v1alpha1::Subscription* subscription);
  ::payment::v1alpha1::Subscription* unsafe_arena_release_subscription();

  // bool status = 9 [json_name = "status"];
  void clear_status();
  bool status() const;
  void set_status(bool value);
  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);
  public:

  // bool is_suspended = 10 [json_name = "isSuspended"];
  void clear_is_suspended();
  bool is_suspended() const;
  void set_is_suspended(bool value);
  private:
  bool _internal_is_suspended() const;
  void _internal_set_is_suspended(bool value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.Project)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr budget_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_at_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updated_at_;
  ::payment::v1alpha1::Subscription* subscription_;
  bool status_;
  bool is_suspended_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class Subscription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.Subscription) */ {
 public:
  inline Subscription() : Subscription(nullptr) {}
  ~Subscription() override;
  explicit constexpr Subscription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subscription(const Subscription& from);
  Subscription(Subscription&& from) noexcept
    : Subscription() {
    *this = ::std::move(from);
  }

  inline Subscription& operator=(const Subscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subscription& operator=(Subscription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subscription& default_instance() {
    return *internal_default_instance();
  }
  static inline const Subscription* internal_default_instance() {
    return reinterpret_cast<const Subscription*>(
               &_Subscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Subscription& a, Subscription& b) {
    a.Swap(&b);
  }
  inline void Swap(Subscription* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subscription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Subscription* New() const final {
    return new Subscription();
  }

  Subscription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Subscription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Subscription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Subscription& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subscription* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.Subscription";
  }
  protected:
  explicit Subscription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionIdFieldNumber = 1,
    kSubscriptionItemIdFieldNumber = 2,
    kInvoiceIdFieldNumber = 3,
    kPriceCpuFieldNumber = 4,
    kPriceBytesFieldNumber = 5,
    kPricePipelineFieldNumber = 6,
    kCurrencyFieldNumber = 7,
    kIntervalFieldNumber = 8,
  };
  // string subscription_id = 1 [json_name = "subscriptionId"];
  void clear_subscription_id();
  const std::string& subscription_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscription_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscription_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_subscription_id();
  void set_allocated_subscription_id(std::string* subscription_id);
  private:
  const std::string& _internal_subscription_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscription_id(const std::string& value);
  std::string* _internal_mutable_subscription_id();
  public:

  // string subscription_item_id = 2 [json_name = "subscriptionItemId"];
  void clear_subscription_item_id();
  const std::string& subscription_item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscription_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscription_item_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_subscription_item_id();
  void set_allocated_subscription_item_id(std::string* subscription_item_id);
  private:
  const std::string& _internal_subscription_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscription_item_id(const std::string& value);
  std::string* _internal_mutable_subscription_item_id();
  public:

  // string invoice_id = 3 [json_name = "invoiceId"];
  void clear_invoice_id();
  const std::string& invoice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invoice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invoice_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_invoice_id();
  void set_allocated_invoice_id(std::string* invoice_id);
  private:
  const std::string& _internal_invoice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invoice_id(const std::string& value);
  std::string* _internal_mutable_invoice_id();
  public:

  // string price_cpu = 4 [json_name = "priceCpu"];
  void clear_price_cpu();
  const std::string& price_cpu() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_price_cpu(ArgT0&& arg0, ArgT... args);
  std::string* mutable_price_cpu();
  PROTOBUF_MUST_USE_RESULT std::string* release_price_cpu();
  void set_allocated_price_cpu(std::string* price_cpu);
  private:
  const std::string& _internal_price_cpu() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price_cpu(const std::string& value);
  std::string* _internal_mutable_price_cpu();
  public:

  // string price_bytes = 5 [json_name = "priceBytes"];
  void clear_price_bytes();
  const std::string& price_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_price_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_price_bytes();
  PROTOBUF_MUST_USE_RESULT std::string* release_price_bytes();
  void set_allocated_price_bytes(std::string* price_bytes);
  private:
  const std::string& _internal_price_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price_bytes(const std::string& value);
  std::string* _internal_mutable_price_bytes();
  public:

  // string price_pipeline = 6 [json_name = "pricePipeline"];
  void clear_price_pipeline();
  const std::string& price_pipeline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_price_pipeline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_price_pipeline();
  PROTOBUF_MUST_USE_RESULT std::string* release_price_pipeline();
  void set_allocated_price_pipeline(std::string* price_pipeline);
  private:
  const std::string& _internal_price_pipeline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price_pipeline(const std::string& value);
  std::string* _internal_mutable_price_pipeline();
  public:

  // string currency = 7 [json_name = "currency"];
  void clear_currency();
  const std::string& currency() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currency(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currency();
  PROTOBUF_MUST_USE_RESULT std::string* release_currency();
  void set_allocated_currency(std::string* currency);
  private:
  const std::string& _internal_currency() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currency(const std::string& value);
  std::string* _internal_mutable_currency();
  public:

  // string interval = 8 [json_name = "interval"];
  void clear_interval();
  const std::string& interval() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interval(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interval();
  PROTOBUF_MUST_USE_RESULT std::string* release_interval();
  void set_allocated_interval(std::string* interval);
  private:
  const std::string& _internal_interval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interval(const std::string& value);
  std::string* _internal_mutable_interval();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.Subscription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscription_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscription_item_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invoice_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_cpu_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_bytes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_pipeline_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currency_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interval_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class Payment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.Payment) */ {
 public:
  inline Payment() : Payment(nullptr) {}
  ~Payment() override;
  explicit constexpr Payment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Payment(const Payment& from);
  Payment(Payment&& from) noexcept
    : Payment() {
    *this = ::std::move(from);
  }

  inline Payment& operator=(const Payment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Payment& operator=(Payment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Payment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Payment* internal_default_instance() {
    return reinterpret_cast<const Payment*>(
               &_Payment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Payment& a, Payment& b) {
    a.Swap(&b);
  }
  inline void Swap(Payment* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Payment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Payment* New() const final {
    return new Payment();
  }

  Payment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Payment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Payment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Payment& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Payment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.Payment";
  }
  protected:
  explicit Payment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardIdFieldNumber = 1,
    kAliasFieldNumber = 4,
    kTokenCardFieldNumber = 5,
    kCardFieldNumber = 6,
    kDefaultFieldNumber = 2,
    kEnabledFieldNumber = 3,
  };
  // string card_id = 1 [json_name = "cardId"];
  void clear_card_id();
  const std::string& card_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_id();
  void set_allocated_card_id(std::string* card_id);
  private:
  const std::string& _internal_card_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_id(const std::string& value);
  std::string* _internal_mutable_card_id();
  public:

  // string alias = 4 [json_name = "alias"];
  void clear_alias();
  const std::string& alias() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alias(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alias();
  PROTOBUF_MUST_USE_RESULT std::string* release_alias();
  void set_allocated_alias(std::string* alias);
  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(const std::string& value);
  std::string* _internal_mutable_alias();
  public:

  // string token_card = 5 [json_name = "tokenCard"];
  void clear_token_card();
  const std::string& token_card() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_card(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_card();
  PROTOBUF_MUST_USE_RESULT std::string* release_token_card();
  void set_allocated_token_card(std::string* token_card);
  private:
  const std::string& _internal_token_card() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_card(const std::string& value);
  std::string* _internal_mutable_token_card();
  public:

  // .payment.v1alpha1.Card card = 6 [json_name = "card"];
  bool has_card() const;
  private:
  bool _internal_has_card() const;
  public:
  void clear_card();
  const ::payment::v1alpha1::Card& card() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Card* release_card();
  ::payment::v1alpha1::Card* mutable_card();
  void set_allocated_card(::payment::v1alpha1::Card* card);
  private:
  const ::payment::v1alpha1::Card& _internal_card() const;
  ::payment::v1alpha1::Card* _internal_mutable_card();
  public:
  void unsafe_arena_set_allocated_card(
      ::payment::v1alpha1::Card* card);
  ::payment::v1alpha1::Card* unsafe_arena_release_card();

  // bool default = 2 [json_name = "default"];
  void clear_default_();
  bool default_() const;
  void set_default_(bool value);
  private:
  bool _internal_default_() const;
  void _internal_set_default_(bool value);
  public:

  // bool enabled = 3 [json_name = "enabled"];
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.Payment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alias_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_card_;
  ::payment::v1alpha1::Card* card_;
  bool default__;
  bool enabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class Card final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.Card) */ {
 public:
  inline Card() : Card(nullptr) {}
  ~Card() override;
  explicit constexpr Card(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Card(const Card& from);
  Card(Card&& from) noexcept
    : Card() {
    *this = ::std::move(from);
  }

  inline Card& operator=(const Card& from) {
    CopyFrom(from);
    return *this;
  }
  inline Card& operator=(Card&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Card& default_instance() {
    return *internal_default_instance();
  }
  static inline const Card* internal_default_instance() {
    return reinterpret_cast<const Card*>(
               &_Card_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Card& a, Card& b) {
    a.Swap(&b);
  }
  inline void Swap(Card* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Card* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Card* New() const final {
    return new Card();
  }

  Card* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Card>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Card& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Card& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Card* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.Card";
  }
  protected:
  explicit Card(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNumberFieldNumber = 2,
    kCardHolderFieldNumber = 3,
    kExpmonthFieldNumber = 4,
    kExpyearFieldNumber = 5,
    kCvcFieldNumber = 6,
    kBrandFieldNumber = 7,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string number = 2 [json_name = "number"];
  void clear_number();
  const std::string& number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_number();
  PROTOBUF_MUST_USE_RESULT std::string* release_number();
  void set_allocated_number(std::string* number);
  private:
  const std::string& _internal_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_number(const std::string& value);
  std::string* _internal_mutable_number();
  public:

  // string card_holder = 3 [json_name = "cardHolder"];
  void clear_card_holder();
  const std::string& card_holder() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_holder(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_holder();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_holder();
  void set_allocated_card_holder(std::string* card_holder);
  private:
  const std::string& _internal_card_holder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_holder(const std::string& value);
  std::string* _internal_mutable_card_holder();
  public:

  // string expmonth = 4 [json_name = "expmonth"];
  void clear_expmonth();
  const std::string& expmonth() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expmonth(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expmonth();
  PROTOBUF_MUST_USE_RESULT std::string* release_expmonth();
  void set_allocated_expmonth(std::string* expmonth);
  private:
  const std::string& _internal_expmonth() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expmonth(const std::string& value);
  std::string* _internal_mutable_expmonth();
  public:

  // string expyear = 5 [json_name = "expyear"];
  void clear_expyear();
  const std::string& expyear() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expyear(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expyear();
  PROTOBUF_MUST_USE_RESULT std::string* release_expyear();
  void set_allocated_expyear(std::string* expyear);
  private:
  const std::string& _internal_expyear() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expyear(const std::string& value);
  std::string* _internal_mutable_expyear();
  public:

  // string cvc = 6 [json_name = "cvc"];
  void clear_cvc();
  const std::string& cvc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cvc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cvc();
  PROTOBUF_MUST_USE_RESULT std::string* release_cvc();
  void set_allocated_cvc(std::string* cvc);
  private:
  const std::string& _internal_cvc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cvc(const std::string& value);
  std::string* _internal_mutable_cvc();
  public:

  // string brand = 7 [json_name = "brand"];
  void clear_brand();
  const std::string& brand() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_brand(ArgT0&& arg0, ArgT... args);
  std::string* mutable_brand();
  PROTOBUF_MUST_USE_RESULT std::string* release_brand();
  void set_allocated_brand(std::string* brand);
  private:
  const std::string& _internal_brand() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brand(const std::string& value);
  std::string* _internal_mutable_brand();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.Card)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr number_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_holder_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expmonth_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expyear_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cvc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brand_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class Invoice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.Invoice) */ {
 public:
  inline Invoice() : Invoice(nullptr) {}
  ~Invoice() override;
  explicit constexpr Invoice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Invoice(const Invoice& from);
  Invoice(Invoice&& from) noexcept
    : Invoice() {
    *this = ::std::move(from);
  }

  inline Invoice& operator=(const Invoice& from) {
    CopyFrom(from);
    return *this;
  }
  inline Invoice& operator=(Invoice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Invoice& default_instance() {
    return *internal_default_instance();
  }
  static inline const Invoice* internal_default_instance() {
    return reinterpret_cast<const Invoice*>(
               &_Invoice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Invoice& a, Invoice& b) {
    a.Swap(&b);
  }
  inline void Swap(Invoice* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Invoice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Invoice* New() const final {
    return new Invoice();
  }

  Invoice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Invoice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Invoice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Invoice& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Invoice* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.Invoice";
  }
  protected:
  explicit Invoice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPeriodFieldNumber = 3,
    kStatuspayFieldNumber = 4,
    kDateFieldNumber = 5,
    kProductFieldNumber = 6,
    kAmountFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string period = 3 [json_name = "period"];
  void clear_period();
  const std::string& period() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_period(ArgT0&& arg0, ArgT... args);
  std::string* mutable_period();
  PROTOBUF_MUST_USE_RESULT std::string* release_period();
  void set_allocated_period(std::string* period);
  private:
  const std::string& _internal_period() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_period(const std::string& value);
  std::string* _internal_mutable_period();
  public:

  // string statuspay = 4 [json_name = "statuspay"];
  void clear_statuspay();
  const std::string& statuspay() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_statuspay(ArgT0&& arg0, ArgT... args);
  std::string* mutable_statuspay();
  PROTOBUF_MUST_USE_RESULT std::string* release_statuspay();
  void set_allocated_statuspay(std::string* statuspay);
  private:
  const std::string& _internal_statuspay() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statuspay(const std::string& value);
  std::string* _internal_mutable_statuspay();
  public:

  // string date = 5 [json_name = "date"];
  void clear_date();
  const std::string& date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date();
  PROTOBUF_MUST_USE_RESULT std::string* release_date();
  void set_allocated_date(std::string* date);
  private:
  const std::string& _internal_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date(const std::string& value);
  std::string* _internal_mutable_date();
  public:

  // string product = 6 [json_name = "product"];
  void clear_product();
  const std::string& product() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product();
  PROTOBUF_MUST_USE_RESULT std::string* release_product();
  void set_allocated_product(std::string* product);
  private:
  const std::string& _internal_product() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product(const std::string& value);
  std::string* _internal_mutable_product();
  public:

  // int64 amount = 2 [json_name = "amount"];
  void clear_amount();
  ::PROTOBUF_NAMESPACE_ID::int64 amount() const;
  void set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_amount() const;
  void _internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.Invoice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr period_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr statuspay_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_;
  ::PROTOBUF_NAMESPACE_ID::int64 amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class Biling final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.Biling) */ {
 public:
  inline Biling() : Biling(nullptr) {}
  ~Biling() override;
  explicit constexpr Biling(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Biling(const Biling& from);
  Biling(Biling&& from) noexcept
    : Biling() {
    *this = ::std::move(from);
  }

  inline Biling& operator=(const Biling& from) {
    CopyFrom(from);
    return *this;
  }
  inline Biling& operator=(Biling&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Biling& default_instance() {
    return *internal_default_instance();
  }
  static inline const Biling* internal_default_instance() {
    return reinterpret_cast<const Biling*>(
               &_Biling_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Biling& a, Biling& b) {
    a.Swap(&b);
  }
  inline void Swap(Biling* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Biling* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Biling* New() const final {
    return new Biling();
  }

  Biling* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Biling>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Biling& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Biling& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Biling* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.Biling";
  }
  protected:
  explicit Biling(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kInvoiceIdFieldNumber = 2,
    kAccountNameFieldNumber = 3,
    kMonthFieldNumber = 8,
    kYearFieldNumber = 9,
    kPeriodFieldNumber = 11,
    kStatuspayFieldNumber = 12,
    kDateFieldNumber = 13,
    kProductFieldNumber = 14,
    kTotalusageFieldNumber = 4,
    kCpuFieldNumber = 5,
    kRamFieldNumber = 6,
    kPipelineFieldNumber = 7,
    kAmountFieldNumber = 10,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string invoice_id = 2 [json_name = "invoiceId"];
  void clear_invoice_id();
  const std::string& invoice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invoice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invoice_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_invoice_id();
  void set_allocated_invoice_id(std::string* invoice_id);
  private:
  const std::string& _internal_invoice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invoice_id(const std::string& value);
  std::string* _internal_mutable_invoice_id();
  public:

  // string account_name = 3 [json_name = "accountName"];
  void clear_account_name();
  const std::string& account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_account_name();
  void set_allocated_account_name(std::string* account_name);
  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* _internal_mutable_account_name();
  public:

  // string month = 8 [json_name = "month"];
  void clear_month();
  const std::string& month() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_month(ArgT0&& arg0, ArgT... args);
  std::string* mutable_month();
  PROTOBUF_MUST_USE_RESULT std::string* release_month();
  void set_allocated_month(std::string* month);
  private:
  const std::string& _internal_month() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_month(const std::string& value);
  std::string* _internal_mutable_month();
  public:

  // string year = 9 [json_name = "year"];
  void clear_year();
  const std::string& year() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_year(ArgT0&& arg0, ArgT... args);
  std::string* mutable_year();
  PROTOBUF_MUST_USE_RESULT std::string* release_year();
  void set_allocated_year(std::string* year);
  private:
  const std::string& _internal_year() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_year(const std::string& value);
  std::string* _internal_mutable_year();
  public:

  // string period = 11 [json_name = "period"];
  void clear_period();
  const std::string& period() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_period(ArgT0&& arg0, ArgT... args);
  std::string* mutable_period();
  PROTOBUF_MUST_USE_RESULT std::string* release_period();
  void set_allocated_period(std::string* period);
  private:
  const std::string& _internal_period() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_period(const std::string& value);
  std::string* _internal_mutable_period();
  public:

  // string statuspay = 12 [json_name = "statuspay"];
  void clear_statuspay();
  const std::string& statuspay() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_statuspay(ArgT0&& arg0, ArgT... args);
  std::string* mutable_statuspay();
  PROTOBUF_MUST_USE_RESULT std::string* release_statuspay();
  void set_allocated_statuspay(std::string* statuspay);
  private:
  const std::string& _internal_statuspay() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statuspay(const std::string& value);
  std::string* _internal_mutable_statuspay();
  public:

  // string date = 13 [json_name = "date"];
  void clear_date();
  const std::string& date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date();
  PROTOBUF_MUST_USE_RESULT std::string* release_date();
  void set_allocated_date(std::string* date);
  private:
  const std::string& _internal_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date(const std::string& value);
  std::string* _internal_mutable_date();
  public:

  // string product = 14 [json_name = "product"];
  void clear_product();
  const std::string& product() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product();
  PROTOBUF_MUST_USE_RESULT std::string* release_product();
  void set_allocated_product(std::string* product);
  private:
  const std::string& _internal_product() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product(const std::string& value);
  std::string* _internal_mutable_product();
  public:

  // int64 totalusage = 4 [json_name = "totalusage"];
  void clear_totalusage();
  ::PROTOBUF_NAMESPACE_ID::int64 totalusage() const;
  void set_totalusage(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_totalusage() const;
  void _internal_set_totalusage(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // double cpu = 5 [json_name = "cpu"];
  void clear_cpu();
  double cpu() const;
  void set_cpu(double value);
  private:
  double _internal_cpu() const;
  void _internal_set_cpu(double value);
  public:

  // double ram = 6 [json_name = "ram"];
  void clear_ram();
  double ram() const;
  void set_ram(double value);
  private:
  double _internal_ram() const;
  void _internal_set_ram(double value);
  public:

  // double pipeline = 7 [json_name = "pipeline"];
  void clear_pipeline();
  double pipeline() const;
  void set_pipeline(double value);
  private:
  double _internal_pipeline() const;
  void _internal_set_pipeline(double value);
  public:

  // int64 amount = 10 [json_name = "amount"];
  void clear_amount();
  ::PROTOBUF_NAMESPACE_ID::int64 amount() const;
  void set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_amount() const;
  void _internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.Biling)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invoice_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr month_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr year_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr period_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr statuspay_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_;
  ::PROTOBUF_NAMESPACE_ID::int64 totalusage_;
  double cpu_;
  double ram_;
  double pipeline_;
  ::PROTOBUF_NAMESPACE_ID::int64 amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionItems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.SubscriptionItems) */ {
 public:
  inline SubscriptionItems() : SubscriptionItems(nullptr) {}
  ~SubscriptionItems() override;
  explicit constexpr SubscriptionItems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionItems(const SubscriptionItems& from);
  SubscriptionItems(SubscriptionItems&& from) noexcept
    : SubscriptionItems() {
    *this = ::std::move(from);
  }

  inline SubscriptionItems& operator=(const SubscriptionItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionItems& operator=(SubscriptionItems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionItems& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionItems* internal_default_instance() {
    return reinterpret_cast<const SubscriptionItems*>(
               &_SubscriptionItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SubscriptionItems& a, SubscriptionItems& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionItems* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubscriptionItems* New() const final {
    return new SubscriptionItems();
  }

  SubscriptionItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubscriptionItems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionItems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscriptionItems& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionItems* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.SubscriptionItems";
  }
  protected:
  explicit SubscriptionItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSubscriptionItemIdFieldNumber = 2,
    kPriceIdFieldNumber = 3,
    kProductIdFieldNumber = 4,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string subscription_item_id = 2 [json_name = "subscriptionItemId"];
  void clear_subscription_item_id();
  const std::string& subscription_item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscription_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscription_item_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_subscription_item_id();
  void set_allocated_subscription_item_id(std::string* subscription_item_id);
  private:
  const std::string& _internal_subscription_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscription_item_id(const std::string& value);
  std::string* _internal_mutable_subscription_item_id();
  public:

  // string price_id = 3 [json_name = "priceId"];
  void clear_price_id();
  const std::string& price_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_price_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_price_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_price_id();
  void set_allocated_price_id(std::string* price_id);
  private:
  const std::string& _internal_price_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price_id(const std::string& value);
  std::string* _internal_mutable_price_id();
  public:

  // string product_id = 4 [json_name = "productId"];
  void clear_product_id();
  const std::string& product_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_product_id();
  void set_allocated_product_id(std::string* product_id);
  private:
  const std::string& _internal_product_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product_id(const std::string& value);
  std::string* _internal_mutable_product_id();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.SubscriptionItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscription_item_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionItemsList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.SubscriptionItemsList) */ {
 public:
  inline SubscriptionItemsList() : SubscriptionItemsList(nullptr) {}
  ~SubscriptionItemsList() override;
  explicit constexpr SubscriptionItemsList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionItemsList(const SubscriptionItemsList& from);
  SubscriptionItemsList(SubscriptionItemsList&& from) noexcept
    : SubscriptionItemsList() {
    *this = ::std::move(from);
  }

  inline SubscriptionItemsList& operator=(const SubscriptionItemsList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionItemsList& operator=(SubscriptionItemsList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionItemsList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionItemsList* internal_default_instance() {
    return reinterpret_cast<const SubscriptionItemsList*>(
               &_SubscriptionItemsList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SubscriptionItemsList& a, SubscriptionItemsList& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionItemsList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionItemsList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubscriptionItemsList* New() const final {
    return new SubscriptionItemsList();
  }

  SubscriptionItemsList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubscriptionItemsList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionItemsList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscriptionItemsList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionItemsList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.SubscriptionItemsList";
  }
  protected:
  explicit SubscriptionItemsList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .payment.v1alpha1.SubscriptionItems items = 1 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::payment::v1alpha1::SubscriptionItems* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::SubscriptionItems >*
      mutable_items();
  private:
  const ::payment::v1alpha1::SubscriptionItems& _internal_items(int index) const;
  ::payment::v1alpha1::SubscriptionItems* _internal_add_items();
  public:
  const ::payment::v1alpha1::SubscriptionItems& items(int index) const;
  ::payment::v1alpha1::SubscriptionItems* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::SubscriptionItems >&
      items() const;

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.SubscriptionItemsList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::SubscriptionItems > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class InvoiceList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.InvoiceList) */ {
 public:
  inline InvoiceList() : InvoiceList(nullptr) {}
  ~InvoiceList() override;
  explicit constexpr InvoiceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvoiceList(const InvoiceList& from);
  InvoiceList(InvoiceList&& from) noexcept
    : InvoiceList() {
    *this = ::std::move(from);
  }

  inline InvoiceList& operator=(const InvoiceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvoiceList& operator=(InvoiceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvoiceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvoiceList* internal_default_instance() {
    return reinterpret_cast<const InvoiceList*>(
               &_InvoiceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InvoiceList& a, InvoiceList& b) {
    a.Swap(&b);
  }
  inline void Swap(InvoiceList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvoiceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InvoiceList* New() const final {
    return new InvoiceList();
  }

  InvoiceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InvoiceList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvoiceList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvoiceList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvoiceList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.InvoiceList";
  }
  protected:
  explicit InvoiceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .payment.v1alpha1.Invoice items = 1 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::payment::v1alpha1::Invoice* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Invoice >*
      mutable_items();
  private:
  const ::payment::v1alpha1::Invoice& _internal_items(int index) const;
  ::payment::v1alpha1::Invoice* _internal_add_items();
  public:
  const ::payment::v1alpha1::Invoice& items(int index) const;
  ::payment::v1alpha1::Invoice* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Invoice >&
      items() const;

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.InvoiceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Invoice > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class CustomerList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CustomerList) */ {
 public:
  inline CustomerList() : CustomerList(nullptr) {}
  ~CustomerList() override;
  explicit constexpr CustomerList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomerList(const CustomerList& from);
  CustomerList(CustomerList&& from) noexcept
    : CustomerList() {
    *this = ::std::move(from);
  }

  inline CustomerList& operator=(const CustomerList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomerList& operator=(CustomerList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomerList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomerList* internal_default_instance() {
    return reinterpret_cast<const CustomerList*>(
               &_CustomerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CustomerList& a, CustomerList& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomerList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomerList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CustomerList* New() const final {
    return new CustomerList();
  }

  CustomerList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CustomerList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomerList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CustomerList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomerList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CustomerList";
  }
  protected:
  explicit CustomerList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .payment.v1alpha1.Customer items = 1 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::payment::v1alpha1::Customer* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Customer >*
      mutable_items();
  private:
  const ::payment::v1alpha1::Customer& _internal_items(int index) const;
  ::payment::v1alpha1::Customer* _internal_add_items();
  public:
  const ::payment::v1alpha1::Customer& items(int index) const;
  ::payment::v1alpha1::Customer* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Customer >&
      items() const;

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CustomerList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Customer > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class BilingList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.BilingList) */ {
 public:
  inline BilingList() : BilingList(nullptr) {}
  ~BilingList() override;
  explicit constexpr BilingList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BilingList(const BilingList& from);
  BilingList(BilingList&& from) noexcept
    : BilingList() {
    *this = ::std::move(from);
  }

  inline BilingList& operator=(const BilingList& from) {
    CopyFrom(from);
    return *this;
  }
  inline BilingList& operator=(BilingList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BilingList& default_instance() {
    return *internal_default_instance();
  }
  static inline const BilingList* internal_default_instance() {
    return reinterpret_cast<const BilingList*>(
               &_BilingList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BilingList& a, BilingList& b) {
    a.Swap(&b);
  }
  inline void Swap(BilingList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BilingList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BilingList* New() const final {
    return new BilingList();
  }

  BilingList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BilingList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BilingList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BilingList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BilingList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.BilingList";
  }
  protected:
  explicit BilingList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .payment.v1alpha1.Biling items = 1 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::payment::v1alpha1::Biling* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Biling >*
      mutable_items();
  private:
  const ::payment::v1alpha1::Biling& _internal_items(int index) const;
  ::payment::v1alpha1::Biling* _internal_add_items();
  public:
  const ::payment::v1alpha1::Biling& items(int index) const;
  ::payment::v1alpha1::Biling* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Biling >&
      items() const;

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.BilingList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Biling > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.SubscriptionList) */ {
 public:
  inline SubscriptionList() : SubscriptionList(nullptr) {}
  ~SubscriptionList() override;
  explicit constexpr SubscriptionList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionList(const SubscriptionList& from);
  SubscriptionList(SubscriptionList&& from) noexcept
    : SubscriptionList() {
    *this = ::std::move(from);
  }

  inline SubscriptionList& operator=(const SubscriptionList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionList& operator=(SubscriptionList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionList* internal_default_instance() {
    return reinterpret_cast<const SubscriptionList*>(
               &_SubscriptionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SubscriptionList& a, SubscriptionList& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubscriptionList* New() const final {
    return new SubscriptionList();
  }

  SubscriptionList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubscriptionList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscriptionList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.SubscriptionList";
  }
  protected:
  explicit SubscriptionList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .payment.v1alpha1.Subscription items = 1 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::payment::v1alpha1::Subscription* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Subscription >*
      mutable_items();
  private:
  const ::payment::v1alpha1::Subscription& _internal_items(int index) const;
  ::payment::v1alpha1::Subscription* _internal_add_items();
  public:
  const ::payment::v1alpha1::Subscription& items(int index) const;
  ::payment::v1alpha1::Subscription* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Subscription >&
      items() const;

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.SubscriptionList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Subscription > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class CardList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CardList) */ {
 public:
  inline CardList() : CardList(nullptr) {}
  ~CardList() override;
  explicit constexpr CardList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CardList(const CardList& from);
  CardList(CardList&& from) noexcept
    : CardList() {
    *this = ::std::move(from);
  }

  inline CardList& operator=(const CardList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CardList& operator=(CardList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CardList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CardList* internal_default_instance() {
    return reinterpret_cast<const CardList*>(
               &_CardList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CardList& a, CardList& b) {
    a.Swap(&b);
  }
  inline void Swap(CardList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CardList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CardList* New() const final {
    return new CardList();
  }

  CardList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CardList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CardList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CardList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CardList";
  }
  protected:
  explicit CardList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .payment.v1alpha1.Card items = 1 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::payment::v1alpha1::Card* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Card >*
      mutable_items();
  private:
  const ::payment::v1alpha1::Card& _internal_items(int index) const;
  ::payment::v1alpha1::Card* _internal_add_items();
  public:
  const ::payment::v1alpha1::Card& items(int index) const;
  ::payment::v1alpha1::Card* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Card >&
      items() const;

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CardList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Card > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class PaymentList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.PaymentList) */ {
 public:
  inline PaymentList() : PaymentList(nullptr) {}
  ~PaymentList() override;
  explicit constexpr PaymentList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaymentList(const PaymentList& from);
  PaymentList(PaymentList&& from) noexcept
    : PaymentList() {
    *this = ::std::move(from);
  }

  inline PaymentList& operator=(const PaymentList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentList& operator=(PaymentList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaymentList& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaymentList* internal_default_instance() {
    return reinterpret_cast<const PaymentList*>(
               &_PaymentList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PaymentList& a, PaymentList& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaymentList* New() const final {
    return new PaymentList();
  }

  PaymentList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaymentList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaymentList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PaymentList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.PaymentList";
  }
  protected:
  explicit PaymentList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .payment.v1alpha1.Payment items = 1 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::payment::v1alpha1::Payment* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Payment >*
      mutable_items();
  private:
  const ::payment::v1alpha1::Payment& _internal_items(int index) const;
  ::payment::v1alpha1::Payment* _internal_add_items();
  public:
  const ::payment::v1alpha1::Payment& items(int index) const;
  ::payment::v1alpha1::Payment* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Payment >&
      items() const;

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.PaymentList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Payment > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class ProjectList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ProjectList) */ {
 public:
  inline ProjectList() : ProjectList(nullptr) {}
  ~ProjectList() override;
  explicit constexpr ProjectList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProjectList(const ProjectList& from);
  ProjectList(ProjectList&& from) noexcept
    : ProjectList() {
    *this = ::std::move(from);
  }

  inline ProjectList& operator=(const ProjectList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectList& operator=(ProjectList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectList* internal_default_instance() {
    return reinterpret_cast<const ProjectList*>(
               &_ProjectList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ProjectList& a, ProjectList& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProjectList* New() const final {
    return new ProjectList();
  }

  ProjectList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProjectList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProjectList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProjectList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ProjectList";
  }
  protected:
  explicit ProjectList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .payment.v1alpha1.Project items = 1 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::payment::v1alpha1::Project* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Project >*
      mutable_items();
  private:
  const ::payment::v1alpha1::Project& _internal_items(int index) const;
  ::payment::v1alpha1::Project* _internal_add_items();
  public:
  const ::payment::v1alpha1::Project& items(int index) const;
  ::payment::v1alpha1::Project* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Project >&
      items() const;

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ProjectList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Project > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class ProjectBilling final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ProjectBilling) */ {
 public:
  inline ProjectBilling() : ProjectBilling(nullptr) {}
  ~ProjectBilling() override;
  explicit constexpr ProjectBilling(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProjectBilling(const ProjectBilling& from);
  ProjectBilling(ProjectBilling&& from) noexcept
    : ProjectBilling() {
    *this = ::std::move(from);
  }

  inline ProjectBilling& operator=(const ProjectBilling& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectBilling& operator=(ProjectBilling&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectBilling& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectBilling* internal_default_instance() {
    return reinterpret_cast<const ProjectBilling*>(
               &_ProjectBilling_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ProjectBilling& a, ProjectBilling& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectBilling* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectBilling* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProjectBilling* New() const final {
    return new ProjectBilling();
  }

  ProjectBilling* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProjectBilling>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProjectBilling& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProjectBilling& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectBilling* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ProjectBilling";
  }
  protected:
  explicit ProjectBilling(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kProjectIdFieldNumber = 2,
    kNameProjectFieldNumber = 3,
    kRamFieldNumber = 4,
    kCpuFieldNumber = 5,
    kPipelineFieldNumber = 6,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string project_id = 2 [json_name = "projectId"];
  void clear_project_id();
  const std::string& project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_project_id();
  void set_allocated_project_id(std::string* project_id);
  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(const std::string& value);
  std::string* _internal_mutable_project_id();
  public:

  // string name_project = 3 [json_name = "nameProject"];
  void clear_name_project();
  const std::string& name_project() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name_project(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name_project();
  PROTOBUF_MUST_USE_RESULT std::string* release_name_project();
  void set_allocated_name_project(std::string* name_project);
  private:
  const std::string& _internal_name_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name_project(const std::string& value);
  std::string* _internal_mutable_name_project();
  public:

  // string ram = 4 [json_name = "ram"];
  void clear_ram();
  const std::string& ram() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ram(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ram();
  PROTOBUF_MUST_USE_RESULT std::string* release_ram();
  void set_allocated_ram(std::string* ram);
  private:
  const std::string& _internal_ram() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ram(const std::string& value);
  std::string* _internal_mutable_ram();
  public:

  // string cpu = 5 [json_name = "cpu"];
  void clear_cpu();
  const std::string& cpu() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cpu(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cpu();
  PROTOBUF_MUST_USE_RESULT std::string* release_cpu();
  void set_allocated_cpu(std::string* cpu);
  private:
  const std::string& _internal_cpu() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cpu(const std::string& value);
  std::string* _internal_mutable_cpu();
  public:

  // string pipeline = 6 [json_name = "pipeline"];
  void clear_pipeline();
  const std::string& pipeline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pipeline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pipeline();
  PROTOBUF_MUST_USE_RESULT std::string* release_pipeline();
  void set_allocated_pipeline(std::string* pipeline);
  private:
  const std::string& _internal_pipeline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pipeline(const std::string& value);
  std::string* _internal_mutable_pipeline();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ProjectBilling)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_project_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ram_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cpu_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pipeline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class ProjectBillingList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ProjectBillingList) */ {
 public:
  inline ProjectBillingList() : ProjectBillingList(nullptr) {}
  ~ProjectBillingList() override;
  explicit constexpr ProjectBillingList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProjectBillingList(const ProjectBillingList& from);
  ProjectBillingList(ProjectBillingList&& from) noexcept
    : ProjectBillingList() {
    *this = ::std::move(from);
  }

  inline ProjectBillingList& operator=(const ProjectBillingList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectBillingList& operator=(ProjectBillingList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectBillingList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProjectBillingList* internal_default_instance() {
    return reinterpret_cast<const ProjectBillingList*>(
               &_ProjectBillingList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ProjectBillingList& a, ProjectBillingList& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectBillingList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectBillingList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProjectBillingList* New() const final {
    return new ProjectBillingList();
  }

  ProjectBillingList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProjectBillingList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProjectBillingList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProjectBillingList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectBillingList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ProjectBillingList";
  }
  protected:
  explicit ProjectBillingList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .payment.v1alpha1.ProjectBilling items = 1 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::payment::v1alpha1::ProjectBilling* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::ProjectBilling >*
      mutable_items();
  private:
  const ::payment::v1alpha1::ProjectBilling& _internal_items(int index) const;
  ::payment::v1alpha1::ProjectBilling* _internal_add_items();
  public:
  const ::payment::v1alpha1::ProjectBilling& items(int index) const;
  ::payment::v1alpha1::ProjectBilling* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::ProjectBilling >&
      items() const;

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ProjectBillingList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::ProjectBilling > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// -------------------------------------------------------------------

class BlockChain final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.BlockChain) */ {
 public:
  inline BlockChain() : BlockChain(nullptr) {}
  ~BlockChain() override;
  explicit constexpr BlockChain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockChain(const BlockChain& from);
  BlockChain(BlockChain&& from) noexcept
    : BlockChain() {
    *this = ::std::move(from);
  }

  inline BlockChain& operator=(const BlockChain& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockChain& operator=(BlockChain&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockChain& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockChain* internal_default_instance() {
    return reinterpret_cast<const BlockChain*>(
               &_BlockChain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BlockChain& a, BlockChain& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockChain* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockChain* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockChain* New() const final {
    return new BlockChain();
  }

  BlockChain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockChain>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockChain& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockChain& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockChain* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.BlockChain";
  }
  protected:
  explicit BlockChain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockchainIdFieldNumber = 1,
    kBlockchainNameFieldNumber = 2,
    kNodeNameFieldNumber = 3,
    kBudgetFieldNumber = 4,
    kCreatedAtFieldNumber = 6,
    kUpdatedAtFieldNumber = 7,
    kSubscriptionFieldNumber = 5,
    kStatusFieldNumber = 8,
    kIsSuspendedFieldNumber = 9,
  };
  // string blockchain_id = 1 [json_name = "blockchainId"];
  void clear_blockchain_id();
  const std::string& blockchain_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blockchain_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blockchain_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_blockchain_id();
  void set_allocated_blockchain_id(std::string* blockchain_id);
  private:
  const std::string& _internal_blockchain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blockchain_id(const std::string& value);
  std::string* _internal_mutable_blockchain_id();
  public:

  // string blockchain_name = 2 [json_name = "blockchainName"];
  void clear_blockchain_name();
  const std::string& blockchain_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blockchain_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blockchain_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_blockchain_name();
  void set_allocated_blockchain_name(std::string* blockchain_name);
  private:
  const std::string& _internal_blockchain_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blockchain_name(const std::string& value);
  std::string* _internal_mutable_blockchain_name();
  public:

  // string node_name = 3 [json_name = "nodeName"];
  void clear_node_name();
  const std::string& node_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_name();
  void set_allocated_node_name(std::string* node_name);
  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(const std::string& value);
  std::string* _internal_mutable_node_name();
  public:

  // string budget = 4 [json_name = "budget"];
  void clear_budget();
  const std::string& budget() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_budget(ArgT0&& arg0, ArgT... args);
  std::string* mutable_budget();
  PROTOBUF_MUST_USE_RESULT std::string* release_budget();
  void set_allocated_budget(std::string* budget);
  private:
  const std::string& _internal_budget() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_budget(const std::string& value);
  std::string* _internal_mutable_budget();
  public:

  // string created_at = 6 [json_name = "createdAt"];
  void clear_created_at();
  const std::string& created_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_at();
  PROTOBUF_MUST_USE_RESULT std::string* release_created_at();
  void set_allocated_created_at(std::string* created_at);
  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(const std::string& value);
  std::string* _internal_mutable_created_at();
  public:

  // string updated_at = 7 [json_name = "updatedAt"];
  void clear_updated_at();
  const std::string& updated_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_updated_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_updated_at();
  PROTOBUF_MUST_USE_RESULT std::string* release_updated_at();
  void set_allocated_updated_at(std::string* updated_at);
  private:
  const std::string& _internal_updated_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_at(const std::string& value);
  std::string* _internal_mutable_updated_at();
  public:

  // .payment.v1alpha1.Subscription subscription = 5 [json_name = "subscription"];
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::payment::v1alpha1::Subscription& subscription() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Subscription* release_subscription();
  ::payment::v1alpha1::Subscription* mutable_subscription();
  void set_allocated_subscription(::payment::v1alpha1::Subscription* subscription);
  private:
  const ::payment::v1alpha1::Subscription& _internal_subscription() const;
  ::payment::v1alpha1::Subscription* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::payment::v1alpha1::Subscription* subscription);
  ::payment::v1alpha1::Subscription* unsafe_arena_release_subscription();

  // bool status = 8 [json_name = "status"];
  void clear_status();
  bool status() const;
  void set_status(bool value);
  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);
  public:

  // bool is_suspended = 9 [json_name = "isSuspended"];
  void clear_is_suspended();
  bool is_suspended() const;
  void set_is_suspended(bool value);
  private:
  bool _internal_is_suspended() const;
  void _internal_set_is_suspended(bool value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.BlockChain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blockchain_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blockchain_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr budget_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_at_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updated_at_;
  ::payment::v1alpha1::Subscription* subscription_;
  bool status_;
  bool is_suspended_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Customer

// string id = 1 [json_name = "id"];
inline void Customer::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Customer::id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Customer.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Customer::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Customer.id)
}
inline std::string* Customer::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Customer.id)
  return _s;
}
inline const std::string& Customer::_internal_id() const {
  return id_.Get();
}
inline void Customer::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Customer::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Customer::release_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Customer.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Customer::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Customer.id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void Customer::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& Customer::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Customer.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Customer::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Customer.customer_id)
}
inline std::string* Customer::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Customer.customer_id)
  return _s;
}
inline const std::string& Customer::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void Customer::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Customer::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Customer::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Customer.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Customer::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Customer.customer_id)
}

// string organization_id = 3 [json_name = "organizationId"];
inline void Customer::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& Customer::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Customer.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Customer::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Customer.organization_id)
}
inline std::string* Customer::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Customer.organization_id)
  return _s;
}
inline const std::string& Customer::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void Customer::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Customer::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Customer::release_organization_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Customer.organization_id)
  return organization_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Customer::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), organization_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Customer.organization_id)
}

// string name = 4 [json_name = "name"];
inline void Customer::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Customer::name() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Customer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Customer::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Customer.name)
}
inline std::string* Customer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Customer.name)
  return _s;
}
inline const std::string& Customer::_internal_name() const {
  return name_.Get();
}
inline void Customer::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Customer::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Customer::release_name() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Customer.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Customer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Customer.name)
}

// string email = 5 [json_name = "email"];
inline void Customer::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& Customer::email() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Customer.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Customer::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Customer.email)
}
inline std::string* Customer::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Customer.email)
  return _s;
}
inline const std::string& Customer::_internal_email() const {
  return email_.Get();
}
inline void Customer::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Customer::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Customer::release_email() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Customer.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Customer::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Customer.email)
}

// string defaultpaymentmethod = 6 [json_name = "defaultpaymentmethod"];
inline void Customer::clear_defaultpaymentmethod() {
  defaultpaymentmethod_.ClearToEmpty();
}
inline const std::string& Customer::defaultpaymentmethod() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Customer.defaultpaymentmethod)
  return _internal_defaultpaymentmethod();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Customer::set_defaultpaymentmethod(ArgT0&& arg0, ArgT... args) {
 
 defaultpaymentmethod_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Customer.defaultpaymentmethod)
}
inline std::string* Customer::mutable_defaultpaymentmethod() {
  std::string* _s = _internal_mutable_defaultpaymentmethod();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Customer.defaultpaymentmethod)
  return _s;
}
inline const std::string& Customer::_internal_defaultpaymentmethod() const {
  return defaultpaymentmethod_.Get();
}
inline void Customer::_internal_set_defaultpaymentmethod(const std::string& value) {
  
  defaultpaymentmethod_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Customer::_internal_mutable_defaultpaymentmethod() {
  
  return defaultpaymentmethod_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Customer::release_defaultpaymentmethod() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Customer.defaultpaymentmethod)
  return defaultpaymentmethod_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Customer::set_allocated_defaultpaymentmethod(std::string* defaultpaymentmethod) {
  if (defaultpaymentmethod != nullptr) {
    
  } else {
    
  }
  defaultpaymentmethod_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), defaultpaymentmethod,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Customer.defaultpaymentmethod)
}

// .payment.v1alpha1.PaymentList payments = 7 [json_name = "payments"];
inline bool Customer::_internal_has_payments() const {
  return this != internal_default_instance() && payments_ != nullptr;
}
inline bool Customer::has_payments() const {
  return _internal_has_payments();
}
inline void Customer::clear_payments() {
  if (GetArenaForAllocation() == nullptr && payments_ != nullptr) {
    delete payments_;
  }
  payments_ = nullptr;
}
inline const ::payment::v1alpha1::PaymentList& Customer::_internal_payments() const {
  const ::payment::v1alpha1::PaymentList* p = payments_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::PaymentList&>(
      ::payment::v1alpha1::_PaymentList_default_instance_);
}
inline const ::payment::v1alpha1::PaymentList& Customer::payments() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Customer.payments)
  return _internal_payments();
}
inline void Customer::unsafe_arena_set_allocated_payments(
    ::payment::v1alpha1::PaymentList* payments) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payments_);
  }
  payments_ = payments;
  if (payments) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.Customer.payments)
}
inline ::payment::v1alpha1::PaymentList* Customer::release_payments() {
  
  ::payment::v1alpha1::PaymentList* temp = payments_;
  payments_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::PaymentList* Customer::unsafe_arena_release_payments() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Customer.payments)
  
  ::payment::v1alpha1::PaymentList* temp = payments_;
  payments_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::PaymentList* Customer::_internal_mutable_payments() {
  
  if (payments_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::PaymentList>(GetArenaForAllocation());
    payments_ = p;
  }
  return payments_;
}
inline ::payment::v1alpha1::PaymentList* Customer::mutable_payments() {
  ::payment::v1alpha1::PaymentList* _msg = _internal_mutable_payments();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Customer.payments)
  return _msg;
}
inline void Customer::set_allocated_payments(::payment::v1alpha1::PaymentList* payments) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete payments_;
  }
  if (payments) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::payment::v1alpha1::PaymentList>::GetOwningArena(payments);
    if (message_arena != submessage_arena) {
      payments = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payments, submessage_arena);
    }
    
  } else {
    
  }
  payments_ = payments;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Customer.payments)
}

// .payment.v1alpha1.Invoice invoice = 8 [json_name = "invoice"];
inline bool Customer::_internal_has_invoice() const {
  return this != internal_default_instance() && invoice_ != nullptr;
}
inline bool Customer::has_invoice() const {
  return _internal_has_invoice();
}
inline void Customer::clear_invoice() {
  if (GetArenaForAllocation() == nullptr && invoice_ != nullptr) {
    delete invoice_;
  }
  invoice_ = nullptr;
}
inline const ::payment::v1alpha1::Invoice& Customer::_internal_invoice() const {
  const ::payment::v1alpha1::Invoice* p = invoice_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Invoice&>(
      ::payment::v1alpha1::_Invoice_default_instance_);
}
inline const ::payment::v1alpha1::Invoice& Customer::invoice() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Customer.invoice)
  return _internal_invoice();
}
inline void Customer::unsafe_arena_set_allocated_invoice(
    ::payment::v1alpha1::Invoice* invoice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invoice_);
  }
  invoice_ = invoice;
  if (invoice) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.Customer.invoice)
}
inline ::payment::v1alpha1::Invoice* Customer::release_invoice() {
  
  ::payment::v1alpha1::Invoice* temp = invoice_;
  invoice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Invoice* Customer::unsafe_arena_release_invoice() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Customer.invoice)
  
  ::payment::v1alpha1::Invoice* temp = invoice_;
  invoice_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Invoice* Customer::_internal_mutable_invoice() {
  
  if (invoice_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Invoice>(GetArenaForAllocation());
    invoice_ = p;
  }
  return invoice_;
}
inline ::payment::v1alpha1::Invoice* Customer::mutable_invoice() {
  ::payment::v1alpha1::Invoice* _msg = _internal_mutable_invoice();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Customer.invoice)
  return _msg;
}
inline void Customer::set_allocated_invoice(::payment::v1alpha1::Invoice* invoice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete invoice_;
  }
  if (invoice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::payment::v1alpha1::Invoice>::GetOwningArena(invoice);
    if (message_arena != submessage_arena) {
      invoice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invoice, submessage_arena);
    }
    
  } else {
    
  }
  invoice_ = invoice;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Customer.invoice)
}

// .payment.v1alpha1.Biling biling = 9 [json_name = "biling"];
inline bool Customer::_internal_has_biling() const {
  return this != internal_default_instance() && biling_ != nullptr;
}
inline bool Customer::has_biling() const {
  return _internal_has_biling();
}
inline void Customer::clear_biling() {
  if (GetArenaForAllocation() == nullptr && biling_ != nullptr) {
    delete biling_;
  }
  biling_ = nullptr;
}
inline const ::payment::v1alpha1::Biling& Customer::_internal_biling() const {
  const ::payment::v1alpha1::Biling* p = biling_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Biling&>(
      ::payment::v1alpha1::_Biling_default_instance_);
}
inline const ::payment::v1alpha1::Biling& Customer::biling() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Customer.biling)
  return _internal_biling();
}
inline void Customer::unsafe_arena_set_allocated_biling(
    ::payment::v1alpha1::Biling* biling) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling_);
  }
  biling_ = biling;
  if (biling) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.Customer.biling)
}
inline ::payment::v1alpha1::Biling* Customer::release_biling() {
  
  ::payment::v1alpha1::Biling* temp = biling_;
  biling_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Biling* Customer::unsafe_arena_release_biling() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Customer.biling)
  
  ::payment::v1alpha1::Biling* temp = biling_;
  biling_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Biling* Customer::_internal_mutable_biling() {
  
  if (biling_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Biling>(GetArenaForAllocation());
    biling_ = p;
  }
  return biling_;
}
inline ::payment::v1alpha1::Biling* Customer::mutable_biling() {
  ::payment::v1alpha1::Biling* _msg = _internal_mutable_biling();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Customer.biling)
  return _msg;
}
inline void Customer::set_allocated_biling(::payment::v1alpha1::Biling* biling) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete biling_;
  }
  if (biling) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::payment::v1alpha1::Biling>::GetOwningArena(biling);
    if (message_arena != submessage_arena) {
      biling = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, biling, submessage_arena);
    }
    
  } else {
    
  }
  biling_ = biling;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Customer.biling)
}

// repeated .payment.v1alpha1.Project projects = 10 [json_name = "projects"];
inline int Customer::_internal_projects_size() const {
  return projects_.size();
}
inline int Customer::projects_size() const {
  return _internal_projects_size();
}
inline void Customer::clear_projects() {
  projects_.Clear();
}
inline ::payment::v1alpha1::Project* Customer::mutable_projects(int index) {
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Customer.projects)
  return projects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Project >*
Customer::mutable_projects() {
  // @@protoc_insertion_point(field_mutable_list:payment.v1alpha1.Customer.projects)
  return &projects_;
}
inline const ::payment::v1alpha1::Project& Customer::_internal_projects(int index) const {
  return projects_.Get(index);
}
inline const ::payment::v1alpha1::Project& Customer::projects(int index) const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Customer.projects)
  return _internal_projects(index);
}
inline ::payment::v1alpha1::Project* Customer::_internal_add_projects() {
  return projects_.Add();
}
inline ::payment::v1alpha1::Project* Customer::add_projects() {
  ::payment::v1alpha1::Project* _add = _internal_add_projects();
  // @@protoc_insertion_point(field_add:payment.v1alpha1.Customer.projects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Project >&
Customer::projects() const {
  // @@protoc_insertion_point(field_list:payment.v1alpha1.Customer.projects)
  return projects_;
}

// repeated .payment.v1alpha1.BlockChain blockchains = 11 [json_name = "blockchains"];
inline int Customer::_internal_blockchains_size() const {
  return blockchains_.size();
}
inline int Customer::blockchains_size() const {
  return _internal_blockchains_size();
}
inline void Customer::clear_blockchains() {
  blockchains_.Clear();
}
inline ::payment::v1alpha1::BlockChain* Customer::mutable_blockchains(int index) {
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Customer.blockchains)
  return blockchains_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::BlockChain >*
Customer::mutable_blockchains() {
  // @@protoc_insertion_point(field_mutable_list:payment.v1alpha1.Customer.blockchains)
  return &blockchains_;
}
inline const ::payment::v1alpha1::BlockChain& Customer::_internal_blockchains(int index) const {
  return blockchains_.Get(index);
}
inline const ::payment::v1alpha1::BlockChain& Customer::blockchains(int index) const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Customer.blockchains)
  return _internal_blockchains(index);
}
inline ::payment::v1alpha1::BlockChain* Customer::_internal_add_blockchains() {
  return blockchains_.Add();
}
inline ::payment::v1alpha1::BlockChain* Customer::add_blockchains() {
  ::payment::v1alpha1::BlockChain* _add = _internal_add_blockchains();
  // @@protoc_insertion_point(field_add:payment.v1alpha1.Customer.blockchains)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::BlockChain >&
Customer::blockchains() const {
  // @@protoc_insertion_point(field_list:payment.v1alpha1.Customer.blockchains)
  return blockchains_;
}

// -------------------------------------------------------------------

// Project

// string project_id = 1 [json_name = "projectId"];
inline void Project::clear_project_id() {
  project_id_.ClearToEmpty();
}
inline const std::string& Project::project_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Project.project_id)
  return _internal_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Project::set_project_id(ArgT0&& arg0, ArgT... args) {
 
 project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Project.project_id)
}
inline std::string* Project::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Project.project_id)
  return _s;
}
inline const std::string& Project::_internal_project_id() const {
  return project_id_.Get();
}
inline void Project::_internal_set_project_id(const std::string& value) {
  
  project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Project::_internal_mutable_project_id() {
  
  return project_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Project::release_project_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Project.project_id)
  return project_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Project::set_allocated_project_id(std::string* project_id) {
  if (project_id != nullptr) {
    
  } else {
    
  }
  project_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Project.project_id)
}

// string name = 2 [json_name = "name"];
inline void Project::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Project::name() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Project.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Project::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Project.name)
}
inline std::string* Project::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Project.name)
  return _s;
}
inline const std::string& Project::_internal_name() const {
  return name_.Get();
}
inline void Project::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Project::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Project::release_name() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Project.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Project::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Project.name)
}

// string image = 3 [json_name = "image"];
inline void Project::clear_image() {
  image_.ClearToEmpty();
}
inline const std::string& Project::image() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Project.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Project::set_image(ArgT0&& arg0, ArgT... args) {
 
 image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Project.image)
}
inline std::string* Project::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Project.image)
  return _s;
}
inline const std::string& Project::_internal_image() const {
  return image_.Get();
}
inline void Project::_internal_set_image(const std::string& value) {
  
  image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Project::_internal_mutable_image() {
  
  return image_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Project::release_image() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Project.image)
  return image_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Project::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  image_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Project.image)
}

// string budget = 4 [json_name = "budget"];
inline void Project::clear_budget() {
  budget_.ClearToEmpty();
}
inline const std::string& Project::budget() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Project.budget)
  return _internal_budget();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Project::set_budget(ArgT0&& arg0, ArgT... args) {
 
 budget_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Project.budget)
}
inline std::string* Project::mutable_budget() {
  std::string* _s = _internal_mutable_budget();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Project.budget)
  return _s;
}
inline const std::string& Project::_internal_budget() const {
  return budget_.Get();
}
inline void Project::_internal_set_budget(const std::string& value) {
  
  budget_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Project::_internal_mutable_budget() {
  
  return budget_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Project::release_budget() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Project.budget)
  return budget_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Project::set_allocated_budget(std::string* budget) {
  if (budget != nullptr) {
    
  } else {
    
  }
  budget_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), budget,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Project.budget)
}

// string description = 5 [json_name = "description"];
inline void Project::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& Project::description() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Project.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Project::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Project.description)
}
inline std::string* Project::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Project.description)
  return _s;
}
inline const std::string& Project::_internal_description() const {
  return description_.Get();
}
inline void Project::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Project::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Project::release_description() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Project.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Project::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Project.description)
}

// string created_at = 6 [json_name = "createdAt"];
inline void Project::clear_created_at() {
  created_at_.ClearToEmpty();
}
inline const std::string& Project::created_at() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Project.created_at)
  return _internal_created_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Project::set_created_at(ArgT0&& arg0, ArgT... args) {
 
 created_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Project.created_at)
}
inline std::string* Project::mutable_created_at() {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Project.created_at)
  return _s;
}
inline const std::string& Project::_internal_created_at() const {
  return created_at_.Get();
}
inline void Project::_internal_set_created_at(const std::string& value) {
  
  created_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Project::_internal_mutable_created_at() {
  
  return created_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Project::release_created_at() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Project.created_at)
  return created_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Project::set_allocated_created_at(std::string* created_at) {
  if (created_at != nullptr) {
    
  } else {
    
  }
  created_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), created_at,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Project.created_at)
}

// string updated_at = 7 [json_name = "updatedAt"];
inline void Project::clear_updated_at() {
  updated_at_.ClearToEmpty();
}
inline const std::string& Project::updated_at() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Project.updated_at)
  return _internal_updated_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Project::set_updated_at(ArgT0&& arg0, ArgT... args) {
 
 updated_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Project.updated_at)
}
inline std::string* Project::mutable_updated_at() {
  std::string* _s = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Project.updated_at)
  return _s;
}
inline const std::string& Project::_internal_updated_at() const {
  return updated_at_.Get();
}
inline void Project::_internal_set_updated_at(const std::string& value) {
  
  updated_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Project::_internal_mutable_updated_at() {
  
  return updated_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Project::release_updated_at() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Project.updated_at)
  return updated_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Project::set_allocated_updated_at(std::string* updated_at) {
  if (updated_at != nullptr) {
    
  } else {
    
  }
  updated_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), updated_at,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Project.updated_at)
}

// .payment.v1alpha1.Subscription subscription = 8 [json_name = "subscription"];
inline bool Project::_internal_has_subscription() const {
  return this != internal_default_instance() && subscription_ != nullptr;
}
inline bool Project::has_subscription() const {
  return _internal_has_subscription();
}
inline void Project::clear_subscription() {
  if (GetArenaForAllocation() == nullptr && subscription_ != nullptr) {
    delete subscription_;
  }
  subscription_ = nullptr;
}
inline const ::payment::v1alpha1::Subscription& Project::_internal_subscription() const {
  const ::payment::v1alpha1::Subscription* p = subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Subscription&>(
      ::payment::v1alpha1::_Subscription_default_instance_);
}
inline const ::payment::v1alpha1::Subscription& Project::subscription() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Project.subscription)
  return _internal_subscription();
}
inline void Project::unsafe_arena_set_allocated_subscription(
    ::payment::v1alpha1::Subscription* subscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_);
  }
  subscription_ = subscription;
  if (subscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.Project.subscription)
}
inline ::payment::v1alpha1::Subscription* Project::release_subscription() {
  
  ::payment::v1alpha1::Subscription* temp = subscription_;
  subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Subscription* Project::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Project.subscription)
  
  ::payment::v1alpha1::Subscription* temp = subscription_;
  subscription_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Subscription* Project::_internal_mutable_subscription() {
  
  if (subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Subscription>(GetArenaForAllocation());
    subscription_ = p;
  }
  return subscription_;
}
inline ::payment::v1alpha1::Subscription* Project::mutable_subscription() {
  ::payment::v1alpha1::Subscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Project.subscription)
  return _msg;
}
inline void Project::set_allocated_subscription(::payment::v1alpha1::Subscription* subscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subscription_;
  }
  if (subscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::payment::v1alpha1::Subscription>::GetOwningArena(subscription);
    if (message_arena != submessage_arena) {
      subscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscription, submessage_arena);
    }
    
  } else {
    
  }
  subscription_ = subscription;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Project.subscription)
}

// bool status = 9 [json_name = "status"];
inline void Project::clear_status() {
  status_ = false;
}
inline bool Project::_internal_status() const {
  return status_;
}
inline bool Project::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Project.status)
  return _internal_status();
}
inline void Project::_internal_set_status(bool value) {
  
  status_ = value;
}
inline void Project::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Project.status)
}

// bool is_suspended = 10 [json_name = "isSuspended"];
inline void Project::clear_is_suspended() {
  is_suspended_ = false;
}
inline bool Project::_internal_is_suspended() const {
  return is_suspended_;
}
inline bool Project::is_suspended() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Project.is_suspended)
  return _internal_is_suspended();
}
inline void Project::_internal_set_is_suspended(bool value) {
  
  is_suspended_ = value;
}
inline void Project::set_is_suspended(bool value) {
  _internal_set_is_suspended(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Project.is_suspended)
}

// -------------------------------------------------------------------

// Subscription

// string subscription_id = 1 [json_name = "subscriptionId"];
inline void Subscription::clear_subscription_id() {
  subscription_id_.ClearToEmpty();
}
inline const std::string& Subscription::subscription_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Subscription.subscription_id)
  return _internal_subscription_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscription::set_subscription_id(ArgT0&& arg0, ArgT... args) {
 
 subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Subscription.subscription_id)
}
inline std::string* Subscription::mutable_subscription_id() {
  std::string* _s = _internal_mutable_subscription_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Subscription.subscription_id)
  return _s;
}
inline const std::string& Subscription::_internal_subscription_id() const {
  return subscription_id_.Get();
}
inline void Subscription::_internal_set_subscription_id(const std::string& value) {
  
  subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscription::_internal_mutable_subscription_id() {
  
  return subscription_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscription::release_subscription_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Subscription.subscription_id)
  return subscription_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscription::set_allocated_subscription_id(std::string* subscription_id) {
  if (subscription_id != nullptr) {
    
  } else {
    
  }
  subscription_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subscription_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Subscription.subscription_id)
}

// string subscription_item_id = 2 [json_name = "subscriptionItemId"];
inline void Subscription::clear_subscription_item_id() {
  subscription_item_id_.ClearToEmpty();
}
inline const std::string& Subscription::subscription_item_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Subscription.subscription_item_id)
  return _internal_subscription_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscription::set_subscription_item_id(ArgT0&& arg0, ArgT... args) {
 
 subscription_item_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Subscription.subscription_item_id)
}
inline std::string* Subscription::mutable_subscription_item_id() {
  std::string* _s = _internal_mutable_subscription_item_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Subscription.subscription_item_id)
  return _s;
}
inline const std::string& Subscription::_internal_subscription_item_id() const {
  return subscription_item_id_.Get();
}
inline void Subscription::_internal_set_subscription_item_id(const std::string& value) {
  
  subscription_item_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscription::_internal_mutable_subscription_item_id() {
  
  return subscription_item_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscription::release_subscription_item_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Subscription.subscription_item_id)
  return subscription_item_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscription::set_allocated_subscription_item_id(std::string* subscription_item_id) {
  if (subscription_item_id != nullptr) {
    
  } else {
    
  }
  subscription_item_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subscription_item_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Subscription.subscription_item_id)
}

// string invoice_id = 3 [json_name = "invoiceId"];
inline void Subscription::clear_invoice_id() {
  invoice_id_.ClearToEmpty();
}
inline const std::string& Subscription::invoice_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Subscription.invoice_id)
  return _internal_invoice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscription::set_invoice_id(ArgT0&& arg0, ArgT... args) {
 
 invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Subscription.invoice_id)
}
inline std::string* Subscription::mutable_invoice_id() {
  std::string* _s = _internal_mutable_invoice_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Subscription.invoice_id)
  return _s;
}
inline const std::string& Subscription::_internal_invoice_id() const {
  return invoice_id_.Get();
}
inline void Subscription::_internal_set_invoice_id(const std::string& value) {
  
  invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscription::_internal_mutable_invoice_id() {
  
  return invoice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscription::release_invoice_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Subscription.invoice_id)
  return invoice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscription::set_allocated_invoice_id(std::string* invoice_id) {
  if (invoice_id != nullptr) {
    
  } else {
    
  }
  invoice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invoice_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Subscription.invoice_id)
}

// string price_cpu = 4 [json_name = "priceCpu"];
inline void Subscription::clear_price_cpu() {
  price_cpu_.ClearToEmpty();
}
inline const std::string& Subscription::price_cpu() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Subscription.price_cpu)
  return _internal_price_cpu();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscription::set_price_cpu(ArgT0&& arg0, ArgT... args) {
 
 price_cpu_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Subscription.price_cpu)
}
inline std::string* Subscription::mutable_price_cpu() {
  std::string* _s = _internal_mutable_price_cpu();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Subscription.price_cpu)
  return _s;
}
inline const std::string& Subscription::_internal_price_cpu() const {
  return price_cpu_.Get();
}
inline void Subscription::_internal_set_price_cpu(const std::string& value) {
  
  price_cpu_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscription::_internal_mutable_price_cpu() {
  
  return price_cpu_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscription::release_price_cpu() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Subscription.price_cpu)
  return price_cpu_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscription::set_allocated_price_cpu(std::string* price_cpu) {
  if (price_cpu != nullptr) {
    
  } else {
    
  }
  price_cpu_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), price_cpu,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Subscription.price_cpu)
}

// string price_bytes = 5 [json_name = "priceBytes"];
inline void Subscription::clear_price_bytes() {
  price_bytes_.ClearToEmpty();
}
inline const std::string& Subscription::price_bytes() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Subscription.price_bytes)
  return _internal_price_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscription::set_price_bytes(ArgT0&& arg0, ArgT... args) {
 
 price_bytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Subscription.price_bytes)
}
inline std::string* Subscription::mutable_price_bytes() {
  std::string* _s = _internal_mutable_price_bytes();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Subscription.price_bytes)
  return _s;
}
inline const std::string& Subscription::_internal_price_bytes() const {
  return price_bytes_.Get();
}
inline void Subscription::_internal_set_price_bytes(const std::string& value) {
  
  price_bytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscription::_internal_mutable_price_bytes() {
  
  return price_bytes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscription::release_price_bytes() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Subscription.price_bytes)
  return price_bytes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscription::set_allocated_price_bytes(std::string* price_bytes) {
  if (price_bytes != nullptr) {
    
  } else {
    
  }
  price_bytes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), price_bytes,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Subscription.price_bytes)
}

// string price_pipeline = 6 [json_name = "pricePipeline"];
inline void Subscription::clear_price_pipeline() {
  price_pipeline_.ClearToEmpty();
}
inline const std::string& Subscription::price_pipeline() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Subscription.price_pipeline)
  return _internal_price_pipeline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscription::set_price_pipeline(ArgT0&& arg0, ArgT... args) {
 
 price_pipeline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Subscription.price_pipeline)
}
inline std::string* Subscription::mutable_price_pipeline() {
  std::string* _s = _internal_mutable_price_pipeline();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Subscription.price_pipeline)
  return _s;
}
inline const std::string& Subscription::_internal_price_pipeline() const {
  return price_pipeline_.Get();
}
inline void Subscription::_internal_set_price_pipeline(const std::string& value) {
  
  price_pipeline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscription::_internal_mutable_price_pipeline() {
  
  return price_pipeline_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscription::release_price_pipeline() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Subscription.price_pipeline)
  return price_pipeline_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscription::set_allocated_price_pipeline(std::string* price_pipeline) {
  if (price_pipeline != nullptr) {
    
  } else {
    
  }
  price_pipeline_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), price_pipeline,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Subscription.price_pipeline)
}

// string currency = 7 [json_name = "currency"];
inline void Subscription::clear_currency() {
  currency_.ClearToEmpty();
}
inline const std::string& Subscription::currency() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Subscription.currency)
  return _internal_currency();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscription::set_currency(ArgT0&& arg0, ArgT... args) {
 
 currency_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Subscription.currency)
}
inline std::string* Subscription::mutable_currency() {
  std::string* _s = _internal_mutable_currency();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Subscription.currency)
  return _s;
}
inline const std::string& Subscription::_internal_currency() const {
  return currency_.Get();
}
inline void Subscription::_internal_set_currency(const std::string& value) {
  
  currency_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscription::_internal_mutable_currency() {
  
  return currency_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscription::release_currency() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Subscription.currency)
  return currency_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscription::set_allocated_currency(std::string* currency) {
  if (currency != nullptr) {
    
  } else {
    
  }
  currency_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), currency,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Subscription.currency)
}

// string interval = 8 [json_name = "interval"];
inline void Subscription::clear_interval() {
  interval_.ClearToEmpty();
}
inline const std::string& Subscription::interval() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Subscription.interval)
  return _internal_interval();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscription::set_interval(ArgT0&& arg0, ArgT... args) {
 
 interval_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Subscription.interval)
}
inline std::string* Subscription::mutable_interval() {
  std::string* _s = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Subscription.interval)
  return _s;
}
inline const std::string& Subscription::_internal_interval() const {
  return interval_.Get();
}
inline void Subscription::_internal_set_interval(const std::string& value) {
  
  interval_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscription::_internal_mutable_interval() {
  
  return interval_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscription::release_interval() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Subscription.interval)
  return interval_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscription::set_allocated_interval(std::string* interval) {
  if (interval != nullptr) {
    
  } else {
    
  }
  interval_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), interval,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Subscription.interval)
}

// -------------------------------------------------------------------

// Payment

// string card_id = 1 [json_name = "cardId"];
inline void Payment::clear_card_id() {
  card_id_.ClearToEmpty();
}
inline const std::string& Payment::card_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Payment.card_id)
  return _internal_card_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Payment::set_card_id(ArgT0&& arg0, ArgT... args) {
 
 card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Payment.card_id)
}
inline std::string* Payment::mutable_card_id() {
  std::string* _s = _internal_mutable_card_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Payment.card_id)
  return _s;
}
inline const std::string& Payment::_internal_card_id() const {
  return card_id_.Get();
}
inline void Payment::_internal_set_card_id(const std::string& value) {
  
  card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Payment::_internal_mutable_card_id() {
  
  return card_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Payment::release_card_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Payment.card_id)
  return card_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Payment::set_allocated_card_id(std::string* card_id) {
  if (card_id != nullptr) {
    
  } else {
    
  }
  card_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Payment.card_id)
}

// bool default = 2 [json_name = "default"];
inline void Payment::clear_default_() {
  default__ = false;
}
inline bool Payment::_internal_default_() const {
  return default__;
}
inline bool Payment::default_() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Payment.default)
  return _internal_default_();
}
inline void Payment::_internal_set_default_(bool value) {
  
  default__ = value;
}
inline void Payment::set_default_(bool value) {
  _internal_set_default_(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Payment.default)
}

// bool enabled = 3 [json_name = "enabled"];
inline void Payment::clear_enabled() {
  enabled_ = false;
}
inline bool Payment::_internal_enabled() const {
  return enabled_;
}
inline bool Payment::enabled() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Payment.enabled)
  return _internal_enabled();
}
inline void Payment::_internal_set_enabled(bool value) {
  
  enabled_ = value;
}
inline void Payment::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Payment.enabled)
}

// string alias = 4 [json_name = "alias"];
inline void Payment::clear_alias() {
  alias_.ClearToEmpty();
}
inline const std::string& Payment::alias() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Payment.alias)
  return _internal_alias();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Payment::set_alias(ArgT0&& arg0, ArgT... args) {
 
 alias_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Payment.alias)
}
inline std::string* Payment::mutable_alias() {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Payment.alias)
  return _s;
}
inline const std::string& Payment::_internal_alias() const {
  return alias_.Get();
}
inline void Payment::_internal_set_alias(const std::string& value) {
  
  alias_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Payment::_internal_mutable_alias() {
  
  return alias_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Payment::release_alias() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Payment.alias)
  return alias_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Payment::set_allocated_alias(std::string* alias) {
  if (alias != nullptr) {
    
  } else {
    
  }
  alias_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), alias,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Payment.alias)
}

// string token_card = 5 [json_name = "tokenCard"];
inline void Payment::clear_token_card() {
  token_card_.ClearToEmpty();
}
inline const std::string& Payment::token_card() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Payment.token_card)
  return _internal_token_card();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Payment::set_token_card(ArgT0&& arg0, ArgT... args) {
 
 token_card_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Payment.token_card)
}
inline std::string* Payment::mutable_token_card() {
  std::string* _s = _internal_mutable_token_card();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Payment.token_card)
  return _s;
}
inline const std::string& Payment::_internal_token_card() const {
  return token_card_.Get();
}
inline void Payment::_internal_set_token_card(const std::string& value) {
  
  token_card_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Payment::_internal_mutable_token_card() {
  
  return token_card_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Payment::release_token_card() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Payment.token_card)
  return token_card_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Payment::set_allocated_token_card(std::string* token_card) {
  if (token_card != nullptr) {
    
  } else {
    
  }
  token_card_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token_card,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Payment.token_card)
}

// .payment.v1alpha1.Card card = 6 [json_name = "card"];
inline bool Payment::_internal_has_card() const {
  return this != internal_default_instance() && card_ != nullptr;
}
inline bool Payment::has_card() const {
  return _internal_has_card();
}
inline void Payment::clear_card() {
  if (GetArenaForAllocation() == nullptr && card_ != nullptr) {
    delete card_;
  }
  card_ = nullptr;
}
inline const ::payment::v1alpha1::Card& Payment::_internal_card() const {
  const ::payment::v1alpha1::Card* p = card_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Card&>(
      ::payment::v1alpha1::_Card_default_instance_);
}
inline const ::payment::v1alpha1::Card& Payment::card() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Payment.card)
  return _internal_card();
}
inline void Payment::unsafe_arena_set_allocated_card(
    ::payment::v1alpha1::Card* card) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(card_);
  }
  card_ = card;
  if (card) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.Payment.card)
}
inline ::payment::v1alpha1::Card* Payment::release_card() {
  
  ::payment::v1alpha1::Card* temp = card_;
  card_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Card* Payment::unsafe_arena_release_card() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Payment.card)
  
  ::payment::v1alpha1::Card* temp = card_;
  card_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Card* Payment::_internal_mutable_card() {
  
  if (card_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Card>(GetArenaForAllocation());
    card_ = p;
  }
  return card_;
}
inline ::payment::v1alpha1::Card* Payment::mutable_card() {
  ::payment::v1alpha1::Card* _msg = _internal_mutable_card();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Payment.card)
  return _msg;
}
inline void Payment::set_allocated_card(::payment::v1alpha1::Card* card) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete card_;
  }
  if (card) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::payment::v1alpha1::Card>::GetOwningArena(card);
    if (message_arena != submessage_arena) {
      card = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, card, submessage_arena);
    }
    
  } else {
    
  }
  card_ = card;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Payment.card)
}

// -------------------------------------------------------------------

// Card

// string id = 1 [json_name = "id"];
inline void Card::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Card::id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Card.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Card::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Card.id)
}
inline std::string* Card::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Card.id)
  return _s;
}
inline const std::string& Card::_internal_id() const {
  return id_.Get();
}
inline void Card::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Card::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Card::release_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Card.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Card::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Card.id)
}

// string number = 2 [json_name = "number"];
inline void Card::clear_number() {
  number_.ClearToEmpty();
}
inline const std::string& Card::number() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Card.number)
  return _internal_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Card::set_number(ArgT0&& arg0, ArgT... args) {
 
 number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Card.number)
}
inline std::string* Card::mutable_number() {
  std::string* _s = _internal_mutable_number();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Card.number)
  return _s;
}
inline const std::string& Card::_internal_number() const {
  return number_.Get();
}
inline void Card::_internal_set_number(const std::string& value) {
  
  number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Card::_internal_mutable_number() {
  
  return number_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Card::release_number() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Card.number)
  return number_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Card::set_allocated_number(std::string* number) {
  if (number != nullptr) {
    
  } else {
    
  }
  number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), number,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Card.number)
}

// string card_holder = 3 [json_name = "cardHolder"];
inline void Card::clear_card_holder() {
  card_holder_.ClearToEmpty();
}
inline const std::string& Card::card_holder() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Card.card_holder)
  return _internal_card_holder();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Card::set_card_holder(ArgT0&& arg0, ArgT... args) {
 
 card_holder_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Card.card_holder)
}
inline std::string* Card::mutable_card_holder() {
  std::string* _s = _internal_mutable_card_holder();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Card.card_holder)
  return _s;
}
inline const std::string& Card::_internal_card_holder() const {
  return card_holder_.Get();
}
inline void Card::_internal_set_card_holder(const std::string& value) {
  
  card_holder_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Card::_internal_mutable_card_holder() {
  
  return card_holder_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Card::release_card_holder() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Card.card_holder)
  return card_holder_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Card::set_allocated_card_holder(std::string* card_holder) {
  if (card_holder != nullptr) {
    
  } else {
    
  }
  card_holder_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_holder,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Card.card_holder)
}

// string expmonth = 4 [json_name = "expmonth"];
inline void Card::clear_expmonth() {
  expmonth_.ClearToEmpty();
}
inline const std::string& Card::expmonth() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Card.expmonth)
  return _internal_expmonth();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Card::set_expmonth(ArgT0&& arg0, ArgT... args) {
 
 expmonth_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Card.expmonth)
}
inline std::string* Card::mutable_expmonth() {
  std::string* _s = _internal_mutable_expmonth();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Card.expmonth)
  return _s;
}
inline const std::string& Card::_internal_expmonth() const {
  return expmonth_.Get();
}
inline void Card::_internal_set_expmonth(const std::string& value) {
  
  expmonth_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Card::_internal_mutable_expmonth() {
  
  return expmonth_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Card::release_expmonth() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Card.expmonth)
  return expmonth_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Card::set_allocated_expmonth(std::string* expmonth) {
  if (expmonth != nullptr) {
    
  } else {
    
  }
  expmonth_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), expmonth,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Card.expmonth)
}

// string expyear = 5 [json_name = "expyear"];
inline void Card::clear_expyear() {
  expyear_.ClearToEmpty();
}
inline const std::string& Card::expyear() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Card.expyear)
  return _internal_expyear();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Card::set_expyear(ArgT0&& arg0, ArgT... args) {
 
 expyear_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Card.expyear)
}
inline std::string* Card::mutable_expyear() {
  std::string* _s = _internal_mutable_expyear();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Card.expyear)
  return _s;
}
inline const std::string& Card::_internal_expyear() const {
  return expyear_.Get();
}
inline void Card::_internal_set_expyear(const std::string& value) {
  
  expyear_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Card::_internal_mutable_expyear() {
  
  return expyear_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Card::release_expyear() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Card.expyear)
  return expyear_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Card::set_allocated_expyear(std::string* expyear) {
  if (expyear != nullptr) {
    
  } else {
    
  }
  expyear_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), expyear,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Card.expyear)
}

// string cvc = 6 [json_name = "cvc"];
inline void Card::clear_cvc() {
  cvc_.ClearToEmpty();
}
inline const std::string& Card::cvc() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Card.cvc)
  return _internal_cvc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Card::set_cvc(ArgT0&& arg0, ArgT... args) {
 
 cvc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Card.cvc)
}
inline std::string* Card::mutable_cvc() {
  std::string* _s = _internal_mutable_cvc();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Card.cvc)
  return _s;
}
inline const std::string& Card::_internal_cvc() const {
  return cvc_.Get();
}
inline void Card::_internal_set_cvc(const std::string& value) {
  
  cvc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Card::_internal_mutable_cvc() {
  
  return cvc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Card::release_cvc() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Card.cvc)
  return cvc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Card::set_allocated_cvc(std::string* cvc) {
  if (cvc != nullptr) {
    
  } else {
    
  }
  cvc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cvc,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Card.cvc)
}

// string brand = 7 [json_name = "brand"];
inline void Card::clear_brand() {
  brand_.ClearToEmpty();
}
inline const std::string& Card::brand() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Card.brand)
  return _internal_brand();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Card::set_brand(ArgT0&& arg0, ArgT... args) {
 
 brand_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Card.brand)
}
inline std::string* Card::mutable_brand() {
  std::string* _s = _internal_mutable_brand();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Card.brand)
  return _s;
}
inline const std::string& Card::_internal_brand() const {
  return brand_.Get();
}
inline void Card::_internal_set_brand(const std::string& value) {
  
  brand_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Card::_internal_mutable_brand() {
  
  return brand_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Card::release_brand() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Card.brand)
  return brand_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Card::set_allocated_brand(std::string* brand) {
  if (brand != nullptr) {
    
  } else {
    
  }
  brand_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), brand,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Card.brand)
}

// -------------------------------------------------------------------

// Invoice

// string id = 1 [json_name = "id"];
inline void Invoice::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Invoice::id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Invoice.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Invoice::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Invoice.id)
}
inline std::string* Invoice::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Invoice.id)
  return _s;
}
inline const std::string& Invoice::_internal_id() const {
  return id_.Get();
}
inline void Invoice::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Invoice::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Invoice::release_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Invoice.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Invoice::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Invoice.id)
}

// int64 amount = 2 [json_name = "amount"];
inline void Invoice::clear_amount() {
  amount_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Invoice::_internal_amount() const {
  return amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Invoice::amount() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Invoice.amount)
  return _internal_amount();
}
inline void Invoice::_internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  amount_ = value;
}
inline void Invoice::set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Invoice.amount)
}

// string period = 3 [json_name = "period"];
inline void Invoice::clear_period() {
  period_.ClearToEmpty();
}
inline const std::string& Invoice::period() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Invoice.period)
  return _internal_period();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Invoice::set_period(ArgT0&& arg0, ArgT... args) {
 
 period_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Invoice.period)
}
inline std::string* Invoice::mutable_period() {
  std::string* _s = _internal_mutable_period();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Invoice.period)
  return _s;
}
inline const std::string& Invoice::_internal_period() const {
  return period_.Get();
}
inline void Invoice::_internal_set_period(const std::string& value) {
  
  period_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Invoice::_internal_mutable_period() {
  
  return period_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Invoice::release_period() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Invoice.period)
  return period_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Invoice::set_allocated_period(std::string* period) {
  if (period != nullptr) {
    
  } else {
    
  }
  period_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), period,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Invoice.period)
}

// string statuspay = 4 [json_name = "statuspay"];
inline void Invoice::clear_statuspay() {
  statuspay_.ClearToEmpty();
}
inline const std::string& Invoice::statuspay() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Invoice.statuspay)
  return _internal_statuspay();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Invoice::set_statuspay(ArgT0&& arg0, ArgT... args) {
 
 statuspay_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Invoice.statuspay)
}
inline std::string* Invoice::mutable_statuspay() {
  std::string* _s = _internal_mutable_statuspay();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Invoice.statuspay)
  return _s;
}
inline const std::string& Invoice::_internal_statuspay() const {
  return statuspay_.Get();
}
inline void Invoice::_internal_set_statuspay(const std::string& value) {
  
  statuspay_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Invoice::_internal_mutable_statuspay() {
  
  return statuspay_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Invoice::release_statuspay() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Invoice.statuspay)
  return statuspay_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Invoice::set_allocated_statuspay(std::string* statuspay) {
  if (statuspay != nullptr) {
    
  } else {
    
  }
  statuspay_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), statuspay,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Invoice.statuspay)
}

// string date = 5 [json_name = "date"];
inline void Invoice::clear_date() {
  date_.ClearToEmpty();
}
inline const std::string& Invoice::date() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Invoice.date)
  return _internal_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Invoice::set_date(ArgT0&& arg0, ArgT... args) {
 
 date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Invoice.date)
}
inline std::string* Invoice::mutable_date() {
  std::string* _s = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Invoice.date)
  return _s;
}
inline const std::string& Invoice::_internal_date() const {
  return date_.Get();
}
inline void Invoice::_internal_set_date(const std::string& value) {
  
  date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Invoice::_internal_mutable_date() {
  
  return date_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Invoice::release_date() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Invoice.date)
  return date_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Invoice::set_allocated_date(std::string* date) {
  if (date != nullptr) {
    
  } else {
    
  }
  date_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), date,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Invoice.date)
}

// string product = 6 [json_name = "product"];
inline void Invoice::clear_product() {
  product_.ClearToEmpty();
}
inline const std::string& Invoice::product() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Invoice.product)
  return _internal_product();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Invoice::set_product(ArgT0&& arg0, ArgT... args) {
 
 product_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Invoice.product)
}
inline std::string* Invoice::mutable_product() {
  std::string* _s = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Invoice.product)
  return _s;
}
inline const std::string& Invoice::_internal_product() const {
  return product_.Get();
}
inline void Invoice::_internal_set_product(const std::string& value) {
  
  product_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Invoice::_internal_mutable_product() {
  
  return product_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Invoice::release_product() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Invoice.product)
  return product_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Invoice::set_allocated_product(std::string* product) {
  if (product != nullptr) {
    
  } else {
    
  }
  product_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Invoice.product)
}

// -------------------------------------------------------------------

// Biling

// string id = 1 [json_name = "id"];
inline void Biling::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Biling::id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Biling.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Biling::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Biling.id)
}
inline std::string* Biling::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Biling.id)
  return _s;
}
inline const std::string& Biling::_internal_id() const {
  return id_.Get();
}
inline void Biling::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Biling::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Biling::release_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Biling.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Biling::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Biling.id)
}

// string invoice_id = 2 [json_name = "invoiceId"];
inline void Biling::clear_invoice_id() {
  invoice_id_.ClearToEmpty();
}
inline const std::string& Biling::invoice_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Biling.invoice_id)
  return _internal_invoice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Biling::set_invoice_id(ArgT0&& arg0, ArgT... args) {
 
 invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Biling.invoice_id)
}
inline std::string* Biling::mutable_invoice_id() {
  std::string* _s = _internal_mutable_invoice_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Biling.invoice_id)
  return _s;
}
inline const std::string& Biling::_internal_invoice_id() const {
  return invoice_id_.Get();
}
inline void Biling::_internal_set_invoice_id(const std::string& value) {
  
  invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Biling::_internal_mutable_invoice_id() {
  
  return invoice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Biling::release_invoice_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Biling.invoice_id)
  return invoice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Biling::set_allocated_invoice_id(std::string* invoice_id) {
  if (invoice_id != nullptr) {
    
  } else {
    
  }
  invoice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invoice_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Biling.invoice_id)
}

// string account_name = 3 [json_name = "accountName"];
inline void Biling::clear_account_name() {
  account_name_.ClearToEmpty();
}
inline const std::string& Biling::account_name() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Biling.account_name)
  return _internal_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Biling::set_account_name(ArgT0&& arg0, ArgT... args) {
 
 account_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Biling.account_name)
}
inline std::string* Biling::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Biling.account_name)
  return _s;
}
inline const std::string& Biling::_internal_account_name() const {
  return account_name_.Get();
}
inline void Biling::_internal_set_account_name(const std::string& value) {
  
  account_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Biling::_internal_mutable_account_name() {
  
  return account_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Biling::release_account_name() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Biling.account_name)
  return account_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Biling::set_allocated_account_name(std::string* account_name) {
  if (account_name != nullptr) {
    
  } else {
    
  }
  account_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Biling.account_name)
}

// int64 totalusage = 4 [json_name = "totalusage"];
inline void Biling::clear_totalusage() {
  totalusage_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Biling::_internal_totalusage() const {
  return totalusage_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Biling::totalusage() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Biling.totalusage)
  return _internal_totalusage();
}
inline void Biling::_internal_set_totalusage(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  totalusage_ = value;
}
inline void Biling::set_totalusage(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_totalusage(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Biling.totalusage)
}

// double cpu = 5 [json_name = "cpu"];
inline void Biling::clear_cpu() {
  cpu_ = 0;
}
inline double Biling::_internal_cpu() const {
  return cpu_;
}
inline double Biling::cpu() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Biling.cpu)
  return _internal_cpu();
}
inline void Biling::_internal_set_cpu(double value) {
  
  cpu_ = value;
}
inline void Biling::set_cpu(double value) {
  _internal_set_cpu(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Biling.cpu)
}

// double ram = 6 [json_name = "ram"];
inline void Biling::clear_ram() {
  ram_ = 0;
}
inline double Biling::_internal_ram() const {
  return ram_;
}
inline double Biling::ram() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Biling.ram)
  return _internal_ram();
}
inline void Biling::_internal_set_ram(double value) {
  
  ram_ = value;
}
inline void Biling::set_ram(double value) {
  _internal_set_ram(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Biling.ram)
}

// double pipeline = 7 [json_name = "pipeline"];
inline void Biling::clear_pipeline() {
  pipeline_ = 0;
}
inline double Biling::_internal_pipeline() const {
  return pipeline_;
}
inline double Biling::pipeline() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Biling.pipeline)
  return _internal_pipeline();
}
inline void Biling::_internal_set_pipeline(double value) {
  
  pipeline_ = value;
}
inline void Biling::set_pipeline(double value) {
  _internal_set_pipeline(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Biling.pipeline)
}

// string month = 8 [json_name = "month"];
inline void Biling::clear_month() {
  month_.ClearToEmpty();
}
inline const std::string& Biling::month() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Biling.month)
  return _internal_month();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Biling::set_month(ArgT0&& arg0, ArgT... args) {
 
 month_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Biling.month)
}
inline std::string* Biling::mutable_month() {
  std::string* _s = _internal_mutable_month();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Biling.month)
  return _s;
}
inline const std::string& Biling::_internal_month() const {
  return month_.Get();
}
inline void Biling::_internal_set_month(const std::string& value) {
  
  month_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Biling::_internal_mutable_month() {
  
  return month_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Biling::release_month() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Biling.month)
  return month_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Biling::set_allocated_month(std::string* month) {
  if (month != nullptr) {
    
  } else {
    
  }
  month_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), month,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Biling.month)
}

// string year = 9 [json_name = "year"];
inline void Biling::clear_year() {
  year_.ClearToEmpty();
}
inline const std::string& Biling::year() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Biling.year)
  return _internal_year();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Biling::set_year(ArgT0&& arg0, ArgT... args) {
 
 year_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Biling.year)
}
inline std::string* Biling::mutable_year() {
  std::string* _s = _internal_mutable_year();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Biling.year)
  return _s;
}
inline const std::string& Biling::_internal_year() const {
  return year_.Get();
}
inline void Biling::_internal_set_year(const std::string& value) {
  
  year_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Biling::_internal_mutable_year() {
  
  return year_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Biling::release_year() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Biling.year)
  return year_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Biling::set_allocated_year(std::string* year) {
  if (year != nullptr) {
    
  } else {
    
  }
  year_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), year,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Biling.year)
}

// int64 amount = 10 [json_name = "amount"];
inline void Biling::clear_amount() {
  amount_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Biling::_internal_amount() const {
  return amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Biling::amount() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Biling.amount)
  return _internal_amount();
}
inline void Biling::_internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  amount_ = value;
}
inline void Biling::set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Biling.amount)
}

// string period = 11 [json_name = "period"];
inline void Biling::clear_period() {
  period_.ClearToEmpty();
}
inline const std::string& Biling::period() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Biling.period)
  return _internal_period();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Biling::set_period(ArgT0&& arg0, ArgT... args) {
 
 period_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Biling.period)
}
inline std::string* Biling::mutable_period() {
  std::string* _s = _internal_mutable_period();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Biling.period)
  return _s;
}
inline const std::string& Biling::_internal_period() const {
  return period_.Get();
}
inline void Biling::_internal_set_period(const std::string& value) {
  
  period_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Biling::_internal_mutable_period() {
  
  return period_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Biling::release_period() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Biling.period)
  return period_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Biling::set_allocated_period(std::string* period) {
  if (period != nullptr) {
    
  } else {
    
  }
  period_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), period,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Biling.period)
}

// string statuspay = 12 [json_name = "statuspay"];
inline void Biling::clear_statuspay() {
  statuspay_.ClearToEmpty();
}
inline const std::string& Biling::statuspay() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Biling.statuspay)
  return _internal_statuspay();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Biling::set_statuspay(ArgT0&& arg0, ArgT... args) {
 
 statuspay_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Biling.statuspay)
}
inline std::string* Biling::mutable_statuspay() {
  std::string* _s = _internal_mutable_statuspay();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Biling.statuspay)
  return _s;
}
inline const std::string& Biling::_internal_statuspay() const {
  return statuspay_.Get();
}
inline void Biling::_internal_set_statuspay(const std::string& value) {
  
  statuspay_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Biling::_internal_mutable_statuspay() {
  
  return statuspay_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Biling::release_statuspay() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Biling.statuspay)
  return statuspay_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Biling::set_allocated_statuspay(std::string* statuspay) {
  if (statuspay != nullptr) {
    
  } else {
    
  }
  statuspay_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), statuspay,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Biling.statuspay)
}

// string date = 13 [json_name = "date"];
inline void Biling::clear_date() {
  date_.ClearToEmpty();
}
inline const std::string& Biling::date() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Biling.date)
  return _internal_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Biling::set_date(ArgT0&& arg0, ArgT... args) {
 
 date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Biling.date)
}
inline std::string* Biling::mutable_date() {
  std::string* _s = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Biling.date)
  return _s;
}
inline const std::string& Biling::_internal_date() const {
  return date_.Get();
}
inline void Biling::_internal_set_date(const std::string& value) {
  
  date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Biling::_internal_mutable_date() {
  
  return date_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Biling::release_date() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Biling.date)
  return date_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Biling::set_allocated_date(std::string* date) {
  if (date != nullptr) {
    
  } else {
    
  }
  date_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), date,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Biling.date)
}

// string product = 14 [json_name = "product"];
inline void Biling::clear_product() {
  product_.ClearToEmpty();
}
inline const std::string& Biling::product() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.Biling.product)
  return _internal_product();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Biling::set_product(ArgT0&& arg0, ArgT... args) {
 
 product_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.Biling.product)
}
inline std::string* Biling::mutable_product() {
  std::string* _s = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.Biling.product)
  return _s;
}
inline const std::string& Biling::_internal_product() const {
  return product_.Get();
}
inline void Biling::_internal_set_product(const std::string& value) {
  
  product_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Biling::_internal_mutable_product() {
  
  return product_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Biling::release_product() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.Biling.product)
  return product_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Biling::set_allocated_product(std::string* product) {
  if (product != nullptr) {
    
  } else {
    
  }
  product_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.Biling.product)
}

// -------------------------------------------------------------------

// SubscriptionItems

// string id = 1 [json_name = "id"];
inline void SubscriptionItems::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& SubscriptionItems::id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.SubscriptionItems.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionItems::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.SubscriptionItems.id)
}
inline std::string* SubscriptionItems::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.SubscriptionItems.id)
  return _s;
}
inline const std::string& SubscriptionItems::_internal_id() const {
  return id_.Get();
}
inline void SubscriptionItems::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscriptionItems::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscriptionItems::release_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.SubscriptionItems.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscriptionItems::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.SubscriptionItems.id)
}

// string subscription_item_id = 2 [json_name = "subscriptionItemId"];
inline void SubscriptionItems::clear_subscription_item_id() {
  subscription_item_id_.ClearToEmpty();
}
inline const std::string& SubscriptionItems::subscription_item_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.SubscriptionItems.subscription_item_id)
  return _internal_subscription_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionItems::set_subscription_item_id(ArgT0&& arg0, ArgT... args) {
 
 subscription_item_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.SubscriptionItems.subscription_item_id)
}
inline std::string* SubscriptionItems::mutable_subscription_item_id() {
  std::string* _s = _internal_mutable_subscription_item_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.SubscriptionItems.subscription_item_id)
  return _s;
}
inline const std::string& SubscriptionItems::_internal_subscription_item_id() const {
  return subscription_item_id_.Get();
}
inline void SubscriptionItems::_internal_set_subscription_item_id(const std::string& value) {
  
  subscription_item_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscriptionItems::_internal_mutable_subscription_item_id() {
  
  return subscription_item_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscriptionItems::release_subscription_item_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.SubscriptionItems.subscription_item_id)
  return subscription_item_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscriptionItems::set_allocated_subscription_item_id(std::string* subscription_item_id) {
  if (subscription_item_id != nullptr) {
    
  } else {
    
  }
  subscription_item_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subscription_item_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.SubscriptionItems.subscription_item_id)
}

// string price_id = 3 [json_name = "priceId"];
inline void SubscriptionItems::clear_price_id() {
  price_id_.ClearToEmpty();
}
inline const std::string& SubscriptionItems::price_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.SubscriptionItems.price_id)
  return _internal_price_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionItems::set_price_id(ArgT0&& arg0, ArgT... args) {
 
 price_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.SubscriptionItems.price_id)
}
inline std::string* SubscriptionItems::mutable_price_id() {
  std::string* _s = _internal_mutable_price_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.SubscriptionItems.price_id)
  return _s;
}
inline const std::string& SubscriptionItems::_internal_price_id() const {
  return price_id_.Get();
}
inline void SubscriptionItems::_internal_set_price_id(const std::string& value) {
  
  price_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscriptionItems::_internal_mutable_price_id() {
  
  return price_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscriptionItems::release_price_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.SubscriptionItems.price_id)
  return price_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscriptionItems::set_allocated_price_id(std::string* price_id) {
  if (price_id != nullptr) {
    
  } else {
    
  }
  price_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), price_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.SubscriptionItems.price_id)
}

// string product_id = 4 [json_name = "productId"];
inline void SubscriptionItems::clear_product_id() {
  product_id_.ClearToEmpty();
}
inline const std::string& SubscriptionItems::product_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.SubscriptionItems.product_id)
  return _internal_product_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionItems::set_product_id(ArgT0&& arg0, ArgT... args) {
 
 product_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.SubscriptionItems.product_id)
}
inline std::string* SubscriptionItems::mutable_product_id() {
  std::string* _s = _internal_mutable_product_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.SubscriptionItems.product_id)
  return _s;
}
inline const std::string& SubscriptionItems::_internal_product_id() const {
  return product_id_.Get();
}
inline void SubscriptionItems::_internal_set_product_id(const std::string& value) {
  
  product_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscriptionItems::_internal_mutable_product_id() {
  
  return product_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscriptionItems::release_product_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.SubscriptionItems.product_id)
  return product_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscriptionItems::set_allocated_product_id(std::string* product_id) {
  if (product_id != nullptr) {
    
  } else {
    
  }
  product_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.SubscriptionItems.product_id)
}

// -------------------------------------------------------------------

// SubscriptionItemsList

// repeated .payment.v1alpha1.SubscriptionItems items = 1 [json_name = "items"];
inline int SubscriptionItemsList::_internal_items_size() const {
  return items_.size();
}
inline int SubscriptionItemsList::items_size() const {
  return _internal_items_size();
}
inline void SubscriptionItemsList::clear_items() {
  items_.Clear();
}
inline ::payment::v1alpha1::SubscriptionItems* SubscriptionItemsList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.SubscriptionItemsList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::SubscriptionItems >*
SubscriptionItemsList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:payment.v1alpha1.SubscriptionItemsList.items)
  return &items_;
}
inline const ::payment::v1alpha1::SubscriptionItems& SubscriptionItemsList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::payment::v1alpha1::SubscriptionItems& SubscriptionItemsList::items(int index) const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.SubscriptionItemsList.items)
  return _internal_items(index);
}
inline ::payment::v1alpha1::SubscriptionItems* SubscriptionItemsList::_internal_add_items() {
  return items_.Add();
}
inline ::payment::v1alpha1::SubscriptionItems* SubscriptionItemsList::add_items() {
  ::payment::v1alpha1::SubscriptionItems* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:payment.v1alpha1.SubscriptionItemsList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::SubscriptionItems >&
SubscriptionItemsList::items() const {
  // @@protoc_insertion_point(field_list:payment.v1alpha1.SubscriptionItemsList.items)
  return items_;
}

// -------------------------------------------------------------------

// InvoiceList

// repeated .payment.v1alpha1.Invoice items = 1 [json_name = "items"];
inline int InvoiceList::_internal_items_size() const {
  return items_.size();
}
inline int InvoiceList::items_size() const {
  return _internal_items_size();
}
inline void InvoiceList::clear_items() {
  items_.Clear();
}
inline ::payment::v1alpha1::Invoice* InvoiceList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Invoice >*
InvoiceList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:payment.v1alpha1.InvoiceList.items)
  return &items_;
}
inline const ::payment::v1alpha1::Invoice& InvoiceList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::payment::v1alpha1::Invoice& InvoiceList::items(int index) const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceList.items)
  return _internal_items(index);
}
inline ::payment::v1alpha1::Invoice* InvoiceList::_internal_add_items() {
  return items_.Add();
}
inline ::payment::v1alpha1::Invoice* InvoiceList::add_items() {
  ::payment::v1alpha1::Invoice* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:payment.v1alpha1.InvoiceList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Invoice >&
InvoiceList::items() const {
  // @@protoc_insertion_point(field_list:payment.v1alpha1.InvoiceList.items)
  return items_;
}

// -------------------------------------------------------------------

// CustomerList

// repeated .payment.v1alpha1.Customer items = 1 [json_name = "items"];
inline int CustomerList::_internal_items_size() const {
  return items_.size();
}
inline int CustomerList::items_size() const {
  return _internal_items_size();
}
inline void CustomerList::clear_items() {
  items_.Clear();
}
inline ::payment::v1alpha1::Customer* CustomerList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CustomerList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Customer >*
CustomerList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:payment.v1alpha1.CustomerList.items)
  return &items_;
}
inline const ::payment::v1alpha1::Customer& CustomerList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::payment::v1alpha1::Customer& CustomerList::items(int index) const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CustomerList.items)
  return _internal_items(index);
}
inline ::payment::v1alpha1::Customer* CustomerList::_internal_add_items() {
  return items_.Add();
}
inline ::payment::v1alpha1::Customer* CustomerList::add_items() {
  ::payment::v1alpha1::Customer* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:payment.v1alpha1.CustomerList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Customer >&
CustomerList::items() const {
  // @@protoc_insertion_point(field_list:payment.v1alpha1.CustomerList.items)
  return items_;
}

// -------------------------------------------------------------------

// BilingList

// repeated .payment.v1alpha1.Biling items = 1 [json_name = "items"];
inline int BilingList::_internal_items_size() const {
  return items_.size();
}
inline int BilingList::items_size() const {
  return _internal_items_size();
}
inline void BilingList::clear_items() {
  items_.Clear();
}
inline ::payment::v1alpha1::Biling* BilingList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.BilingList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Biling >*
BilingList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:payment.v1alpha1.BilingList.items)
  return &items_;
}
inline const ::payment::v1alpha1::Biling& BilingList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::payment::v1alpha1::Biling& BilingList::items(int index) const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.BilingList.items)
  return _internal_items(index);
}
inline ::payment::v1alpha1::Biling* BilingList::_internal_add_items() {
  return items_.Add();
}
inline ::payment::v1alpha1::Biling* BilingList::add_items() {
  ::payment::v1alpha1::Biling* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:payment.v1alpha1.BilingList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Biling >&
BilingList::items() const {
  // @@protoc_insertion_point(field_list:payment.v1alpha1.BilingList.items)
  return items_;
}

// -------------------------------------------------------------------

// SubscriptionList

// repeated .payment.v1alpha1.Subscription items = 1 [json_name = "items"];
inline int SubscriptionList::_internal_items_size() const {
  return items_.size();
}
inline int SubscriptionList::items_size() const {
  return _internal_items_size();
}
inline void SubscriptionList::clear_items() {
  items_.Clear();
}
inline ::payment::v1alpha1::Subscription* SubscriptionList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.SubscriptionList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Subscription >*
SubscriptionList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:payment.v1alpha1.SubscriptionList.items)
  return &items_;
}
inline const ::payment::v1alpha1::Subscription& SubscriptionList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::payment::v1alpha1::Subscription& SubscriptionList::items(int index) const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.SubscriptionList.items)
  return _internal_items(index);
}
inline ::payment::v1alpha1::Subscription* SubscriptionList::_internal_add_items() {
  return items_.Add();
}
inline ::payment::v1alpha1::Subscription* SubscriptionList::add_items() {
  ::payment::v1alpha1::Subscription* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:payment.v1alpha1.SubscriptionList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Subscription >&
SubscriptionList::items() const {
  // @@protoc_insertion_point(field_list:payment.v1alpha1.SubscriptionList.items)
  return items_;
}

// -------------------------------------------------------------------

// CardList

// repeated .payment.v1alpha1.Card items = 1 [json_name = "items"];
inline int CardList::_internal_items_size() const {
  return items_.size();
}
inline int CardList::items_size() const {
  return _internal_items_size();
}
inline void CardList::clear_items() {
  items_.Clear();
}
inline ::payment::v1alpha1::Card* CardList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CardList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Card >*
CardList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:payment.v1alpha1.CardList.items)
  return &items_;
}
inline const ::payment::v1alpha1::Card& CardList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::payment::v1alpha1::Card& CardList::items(int index) const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CardList.items)
  return _internal_items(index);
}
inline ::payment::v1alpha1::Card* CardList::_internal_add_items() {
  return items_.Add();
}
inline ::payment::v1alpha1::Card* CardList::add_items() {
  ::payment::v1alpha1::Card* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:payment.v1alpha1.CardList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Card >&
CardList::items() const {
  // @@protoc_insertion_point(field_list:payment.v1alpha1.CardList.items)
  return items_;
}

// -------------------------------------------------------------------

// PaymentList

// repeated .payment.v1alpha1.Payment items = 1 [json_name = "items"];
inline int PaymentList::_internal_items_size() const {
  return items_.size();
}
inline int PaymentList::items_size() const {
  return _internal_items_size();
}
inline void PaymentList::clear_items() {
  items_.Clear();
}
inline ::payment::v1alpha1::Payment* PaymentList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.PaymentList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Payment >*
PaymentList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:payment.v1alpha1.PaymentList.items)
  return &items_;
}
inline const ::payment::v1alpha1::Payment& PaymentList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::payment::v1alpha1::Payment& PaymentList::items(int index) const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.PaymentList.items)
  return _internal_items(index);
}
inline ::payment::v1alpha1::Payment* PaymentList::_internal_add_items() {
  return items_.Add();
}
inline ::payment::v1alpha1::Payment* PaymentList::add_items() {
  ::payment::v1alpha1::Payment* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:payment.v1alpha1.PaymentList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Payment >&
PaymentList::items() const {
  // @@protoc_insertion_point(field_list:payment.v1alpha1.PaymentList.items)
  return items_;
}

// -------------------------------------------------------------------

// ProjectList

// repeated .payment.v1alpha1.Project items = 1 [json_name = "items"];
inline int ProjectList::_internal_items_size() const {
  return items_.size();
}
inline int ProjectList::items_size() const {
  return _internal_items_size();
}
inline void ProjectList::clear_items() {
  items_.Clear();
}
inline ::payment::v1alpha1::Project* ProjectList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ProjectList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Project >*
ProjectList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:payment.v1alpha1.ProjectList.items)
  return &items_;
}
inline const ::payment::v1alpha1::Project& ProjectList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::payment::v1alpha1::Project& ProjectList::items(int index) const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ProjectList.items)
  return _internal_items(index);
}
inline ::payment::v1alpha1::Project* ProjectList::_internal_add_items() {
  return items_.Add();
}
inline ::payment::v1alpha1::Project* ProjectList::add_items() {
  ::payment::v1alpha1::Project* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:payment.v1alpha1.ProjectList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::Project >&
ProjectList::items() const {
  // @@protoc_insertion_point(field_list:payment.v1alpha1.ProjectList.items)
  return items_;
}

// -------------------------------------------------------------------

// ProjectBilling

// string id = 1 [json_name = "id"];
inline void ProjectBilling::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& ProjectBilling::id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ProjectBilling.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectBilling::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ProjectBilling.id)
}
inline std::string* ProjectBilling::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ProjectBilling.id)
  return _s;
}
inline const std::string& ProjectBilling::_internal_id() const {
  return id_.Get();
}
inline void ProjectBilling::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProjectBilling::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProjectBilling::release_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ProjectBilling.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProjectBilling::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ProjectBilling.id)
}

// string project_id = 2 [json_name = "projectId"];
inline void ProjectBilling::clear_project_id() {
  project_id_.ClearToEmpty();
}
inline const std::string& ProjectBilling::project_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ProjectBilling.project_id)
  return _internal_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectBilling::set_project_id(ArgT0&& arg0, ArgT... args) {
 
 project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ProjectBilling.project_id)
}
inline std::string* ProjectBilling::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ProjectBilling.project_id)
  return _s;
}
inline const std::string& ProjectBilling::_internal_project_id() const {
  return project_id_.Get();
}
inline void ProjectBilling::_internal_set_project_id(const std::string& value) {
  
  project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProjectBilling::_internal_mutable_project_id() {
  
  return project_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProjectBilling::release_project_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ProjectBilling.project_id)
  return project_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProjectBilling::set_allocated_project_id(std::string* project_id) {
  if (project_id != nullptr) {
    
  } else {
    
  }
  project_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ProjectBilling.project_id)
}

// string name_project = 3 [json_name = "nameProject"];
inline void ProjectBilling::clear_name_project() {
  name_project_.ClearToEmpty();
}
inline const std::string& ProjectBilling::name_project() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ProjectBilling.name_project)
  return _internal_name_project();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectBilling::set_name_project(ArgT0&& arg0, ArgT... args) {
 
 name_project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ProjectBilling.name_project)
}
inline std::string* ProjectBilling::mutable_name_project() {
  std::string* _s = _internal_mutable_name_project();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ProjectBilling.name_project)
  return _s;
}
inline const std::string& ProjectBilling::_internal_name_project() const {
  return name_project_.Get();
}
inline void ProjectBilling::_internal_set_name_project(const std::string& value) {
  
  name_project_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProjectBilling::_internal_mutable_name_project() {
  
  return name_project_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProjectBilling::release_name_project() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ProjectBilling.name_project)
  return name_project_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProjectBilling::set_allocated_name_project(std::string* name_project) {
  if (name_project != nullptr) {
    
  } else {
    
  }
  name_project_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name_project,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ProjectBilling.name_project)
}

// string ram = 4 [json_name = "ram"];
inline void ProjectBilling::clear_ram() {
  ram_.ClearToEmpty();
}
inline const std::string& ProjectBilling::ram() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ProjectBilling.ram)
  return _internal_ram();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectBilling::set_ram(ArgT0&& arg0, ArgT... args) {
 
 ram_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ProjectBilling.ram)
}
inline std::string* ProjectBilling::mutable_ram() {
  std::string* _s = _internal_mutable_ram();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ProjectBilling.ram)
  return _s;
}
inline const std::string& ProjectBilling::_internal_ram() const {
  return ram_.Get();
}
inline void ProjectBilling::_internal_set_ram(const std::string& value) {
  
  ram_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProjectBilling::_internal_mutable_ram() {
  
  return ram_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProjectBilling::release_ram() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ProjectBilling.ram)
  return ram_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProjectBilling::set_allocated_ram(std::string* ram) {
  if (ram != nullptr) {
    
  } else {
    
  }
  ram_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ram,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ProjectBilling.ram)
}

// string cpu = 5 [json_name = "cpu"];
inline void ProjectBilling::clear_cpu() {
  cpu_.ClearToEmpty();
}
inline const std::string& ProjectBilling::cpu() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ProjectBilling.cpu)
  return _internal_cpu();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectBilling::set_cpu(ArgT0&& arg0, ArgT... args) {
 
 cpu_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ProjectBilling.cpu)
}
inline std::string* ProjectBilling::mutable_cpu() {
  std::string* _s = _internal_mutable_cpu();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ProjectBilling.cpu)
  return _s;
}
inline const std::string& ProjectBilling::_internal_cpu() const {
  return cpu_.Get();
}
inline void ProjectBilling::_internal_set_cpu(const std::string& value) {
  
  cpu_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProjectBilling::_internal_mutable_cpu() {
  
  return cpu_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProjectBilling::release_cpu() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ProjectBilling.cpu)
  return cpu_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProjectBilling::set_allocated_cpu(std::string* cpu) {
  if (cpu != nullptr) {
    
  } else {
    
  }
  cpu_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cpu,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ProjectBilling.cpu)
}

// string pipeline = 6 [json_name = "pipeline"];
inline void ProjectBilling::clear_pipeline() {
  pipeline_.ClearToEmpty();
}
inline const std::string& ProjectBilling::pipeline() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ProjectBilling.pipeline)
  return _internal_pipeline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProjectBilling::set_pipeline(ArgT0&& arg0, ArgT... args) {
 
 pipeline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ProjectBilling.pipeline)
}
inline std::string* ProjectBilling::mutable_pipeline() {
  std::string* _s = _internal_mutable_pipeline();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ProjectBilling.pipeline)
  return _s;
}
inline const std::string& ProjectBilling::_internal_pipeline() const {
  return pipeline_.Get();
}
inline void ProjectBilling::_internal_set_pipeline(const std::string& value) {
  
  pipeline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProjectBilling::_internal_mutable_pipeline() {
  
  return pipeline_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProjectBilling::release_pipeline() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ProjectBilling.pipeline)
  return pipeline_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProjectBilling::set_allocated_pipeline(std::string* pipeline) {
  if (pipeline != nullptr) {
    
  } else {
    
  }
  pipeline_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pipeline,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ProjectBilling.pipeline)
}

// -------------------------------------------------------------------

// ProjectBillingList

// repeated .payment.v1alpha1.ProjectBilling items = 1 [json_name = "items"];
inline int ProjectBillingList::_internal_items_size() const {
  return items_.size();
}
inline int ProjectBillingList::items_size() const {
  return _internal_items_size();
}
inline void ProjectBillingList::clear_items() {
  items_.Clear();
}
inline ::payment::v1alpha1::ProjectBilling* ProjectBillingList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ProjectBillingList.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::ProjectBilling >*
ProjectBillingList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:payment.v1alpha1.ProjectBillingList.items)
  return &items_;
}
inline const ::payment::v1alpha1::ProjectBilling& ProjectBillingList::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::payment::v1alpha1::ProjectBilling& ProjectBillingList::items(int index) const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ProjectBillingList.items)
  return _internal_items(index);
}
inline ::payment::v1alpha1::ProjectBilling* ProjectBillingList::_internal_add_items() {
  return items_.Add();
}
inline ::payment::v1alpha1::ProjectBilling* ProjectBillingList::add_items() {
  ::payment::v1alpha1::ProjectBilling* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:payment.v1alpha1.ProjectBillingList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payment::v1alpha1::ProjectBilling >&
ProjectBillingList::items() const {
  // @@protoc_insertion_point(field_list:payment.v1alpha1.ProjectBillingList.items)
  return items_;
}

// -------------------------------------------------------------------

// BlockChain

// string blockchain_id = 1 [json_name = "blockchainId"];
inline void BlockChain::clear_blockchain_id() {
  blockchain_id_.ClearToEmpty();
}
inline const std::string& BlockChain::blockchain_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.BlockChain.blockchain_id)
  return _internal_blockchain_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockChain::set_blockchain_id(ArgT0&& arg0, ArgT... args) {
 
 blockchain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.BlockChain.blockchain_id)
}
inline std::string* BlockChain::mutable_blockchain_id() {
  std::string* _s = _internal_mutable_blockchain_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.BlockChain.blockchain_id)
  return _s;
}
inline const std::string& BlockChain::_internal_blockchain_id() const {
  return blockchain_id_.Get();
}
inline void BlockChain::_internal_set_blockchain_id(const std::string& value) {
  
  blockchain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockChain::_internal_mutable_blockchain_id() {
  
  return blockchain_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockChain::release_blockchain_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.BlockChain.blockchain_id)
  return blockchain_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockChain::set_allocated_blockchain_id(std::string* blockchain_id) {
  if (blockchain_id != nullptr) {
    
  } else {
    
  }
  blockchain_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blockchain_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.BlockChain.blockchain_id)
}

// string blockchain_name = 2 [json_name = "blockchainName"];
inline void BlockChain::clear_blockchain_name() {
  blockchain_name_.ClearToEmpty();
}
inline const std::string& BlockChain::blockchain_name() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.BlockChain.blockchain_name)
  return _internal_blockchain_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockChain::set_blockchain_name(ArgT0&& arg0, ArgT... args) {
 
 blockchain_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.BlockChain.blockchain_name)
}
inline std::string* BlockChain::mutable_blockchain_name() {
  std::string* _s = _internal_mutable_blockchain_name();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.BlockChain.blockchain_name)
  return _s;
}
inline const std::string& BlockChain::_internal_blockchain_name() const {
  return blockchain_name_.Get();
}
inline void BlockChain::_internal_set_blockchain_name(const std::string& value) {
  
  blockchain_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockChain::_internal_mutable_blockchain_name() {
  
  return blockchain_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockChain::release_blockchain_name() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.BlockChain.blockchain_name)
  return blockchain_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockChain::set_allocated_blockchain_name(std::string* blockchain_name) {
  if (blockchain_name != nullptr) {
    
  } else {
    
  }
  blockchain_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blockchain_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.BlockChain.blockchain_name)
}

// string node_name = 3 [json_name = "nodeName"];
inline void BlockChain::clear_node_name() {
  node_name_.ClearToEmpty();
}
inline const std::string& BlockChain::node_name() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.BlockChain.node_name)
  return _internal_node_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockChain::set_node_name(ArgT0&& arg0, ArgT... args) {
 
 node_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.BlockChain.node_name)
}
inline std::string* BlockChain::mutable_node_name() {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.BlockChain.node_name)
  return _s;
}
inline const std::string& BlockChain::_internal_node_name() const {
  return node_name_.Get();
}
inline void BlockChain::_internal_set_node_name(const std::string& value) {
  
  node_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockChain::_internal_mutable_node_name() {
  
  return node_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockChain::release_node_name() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.BlockChain.node_name)
  return node_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockChain::set_allocated_node_name(std::string* node_name) {
  if (node_name != nullptr) {
    
  } else {
    
  }
  node_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.BlockChain.node_name)
}

// string budget = 4 [json_name = "budget"];
inline void BlockChain::clear_budget() {
  budget_.ClearToEmpty();
}
inline const std::string& BlockChain::budget() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.BlockChain.budget)
  return _internal_budget();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockChain::set_budget(ArgT0&& arg0, ArgT... args) {
 
 budget_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.BlockChain.budget)
}
inline std::string* BlockChain::mutable_budget() {
  std::string* _s = _internal_mutable_budget();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.BlockChain.budget)
  return _s;
}
inline const std::string& BlockChain::_internal_budget() const {
  return budget_.Get();
}
inline void BlockChain::_internal_set_budget(const std::string& value) {
  
  budget_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockChain::_internal_mutable_budget() {
  
  return budget_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockChain::release_budget() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.BlockChain.budget)
  return budget_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockChain::set_allocated_budget(std::string* budget) {
  if (budget != nullptr) {
    
  } else {
    
  }
  budget_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), budget,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.BlockChain.budget)
}

// .payment.v1alpha1.Subscription subscription = 5 [json_name = "subscription"];
inline bool BlockChain::_internal_has_subscription() const {
  return this != internal_default_instance() && subscription_ != nullptr;
}
inline bool BlockChain::has_subscription() const {
  return _internal_has_subscription();
}
inline void BlockChain::clear_subscription() {
  if (GetArenaForAllocation() == nullptr && subscription_ != nullptr) {
    delete subscription_;
  }
  subscription_ = nullptr;
}
inline const ::payment::v1alpha1::Subscription& BlockChain::_internal_subscription() const {
  const ::payment::v1alpha1::Subscription* p = subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Subscription&>(
      ::payment::v1alpha1::_Subscription_default_instance_);
}
inline const ::payment::v1alpha1::Subscription& BlockChain::subscription() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.BlockChain.subscription)
  return _internal_subscription();
}
inline void BlockChain::unsafe_arena_set_allocated_subscription(
    ::payment::v1alpha1::Subscription* subscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_);
  }
  subscription_ = subscription;
  if (subscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.BlockChain.subscription)
}
inline ::payment::v1alpha1::Subscription* BlockChain::release_subscription() {
  
  ::payment::v1alpha1::Subscription* temp = subscription_;
  subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Subscription* BlockChain::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.BlockChain.subscription)
  
  ::payment::v1alpha1::Subscription* temp = subscription_;
  subscription_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Subscription* BlockChain::_internal_mutable_subscription() {
  
  if (subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Subscription>(GetArenaForAllocation());
    subscription_ = p;
  }
  return subscription_;
}
inline ::payment::v1alpha1::Subscription* BlockChain::mutable_subscription() {
  ::payment::v1alpha1::Subscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.BlockChain.subscription)
  return _msg;
}
inline void BlockChain::set_allocated_subscription(::payment::v1alpha1::Subscription* subscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subscription_;
  }
  if (subscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::payment::v1alpha1::Subscription>::GetOwningArena(subscription);
    if (message_arena != submessage_arena) {
      subscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscription, submessage_arena);
    }
    
  } else {
    
  }
  subscription_ = subscription;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.BlockChain.subscription)
}

// string created_at = 6 [json_name = "createdAt"];
inline void BlockChain::clear_created_at() {
  created_at_.ClearToEmpty();
}
inline const std::string& BlockChain::created_at() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.BlockChain.created_at)
  return _internal_created_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockChain::set_created_at(ArgT0&& arg0, ArgT... args) {
 
 created_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.BlockChain.created_at)
}
inline std::string* BlockChain::mutable_created_at() {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.BlockChain.created_at)
  return _s;
}
inline const std::string& BlockChain::_internal_created_at() const {
  return created_at_.Get();
}
inline void BlockChain::_internal_set_created_at(const std::string& value) {
  
  created_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockChain::_internal_mutable_created_at() {
  
  return created_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockChain::release_created_at() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.BlockChain.created_at)
  return created_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockChain::set_allocated_created_at(std::string* created_at) {
  if (created_at != nullptr) {
    
  } else {
    
  }
  created_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), created_at,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.BlockChain.created_at)
}

// string updated_at = 7 [json_name = "updatedAt"];
inline void BlockChain::clear_updated_at() {
  updated_at_.ClearToEmpty();
}
inline const std::string& BlockChain::updated_at() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.BlockChain.updated_at)
  return _internal_updated_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockChain::set_updated_at(ArgT0&& arg0, ArgT... args) {
 
 updated_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.BlockChain.updated_at)
}
inline std::string* BlockChain::mutable_updated_at() {
  std::string* _s = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.BlockChain.updated_at)
  return _s;
}
inline const std::string& BlockChain::_internal_updated_at() const {
  return updated_at_.Get();
}
inline void BlockChain::_internal_set_updated_at(const std::string& value) {
  
  updated_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockChain::_internal_mutable_updated_at() {
  
  return updated_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockChain::release_updated_at() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.BlockChain.updated_at)
  return updated_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockChain::set_allocated_updated_at(std::string* updated_at) {
  if (updated_at != nullptr) {
    
  } else {
    
  }
  updated_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), updated_at,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.BlockChain.updated_at)
}

// bool status = 8 [json_name = "status"];
inline void BlockChain::clear_status() {
  status_ = false;
}
inline bool BlockChain::_internal_status() const {
  return status_;
}
inline bool BlockChain::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.BlockChain.status)
  return _internal_status();
}
inline void BlockChain::_internal_set_status(bool value) {
  
  status_ = value;
}
inline void BlockChain::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.BlockChain.status)
}

// bool is_suspended = 9 [json_name = "isSuspended"];
inline void BlockChain::clear_is_suspended() {
  is_suspended_ = false;
}
inline bool BlockChain::_internal_is_suspended() const {
  return is_suspended_;
}
inline bool BlockChain::is_suspended() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.BlockChain.is_suspended)
  return _internal_is_suspended();
}
inline void BlockChain::_internal_set_is_suspended(bool value) {
  
  is_suspended_ = value;
}
inline void BlockChain::set_is_suspended(bool value) {
  _internal_set_is_suspended(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.BlockChain.is_suspended)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace payment

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_payment_2fv1alpha1_2fpayment_2eproto
