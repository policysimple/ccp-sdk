// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: payment/v1alpha1/payment_api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_payment_2fv1alpha1_2fpayment_5fapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_payment_2fv1alpha1_2fpayment_5fapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "payment/v1alpha1/payment.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_payment_2fv1alpha1_2fpayment_5fapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
namespace payment {
namespace v1alpha1 {
class CreatePaymentRequest;
struct CreatePaymentRequestDefaultTypeInternal;
extern CreatePaymentRequestDefaultTypeInternal _CreatePaymentRequest_default_instance_;
class CreatePaymentResponse;
struct CreatePaymentResponseDefaultTypeInternal;
extern CreatePaymentResponseDefaultTypeInternal _CreatePaymentResponse_default_instance_;
class DeletePaymentRequest;
struct DeletePaymentRequestDefaultTypeInternal;
extern DeletePaymentRequestDefaultTypeInternal _DeletePaymentRequest_default_instance_;
class DeletePaymentResponse;
struct DeletePaymentResponseDefaultTypeInternal;
extern DeletePaymentResponseDefaultTypeInternal _DeletePaymentResponse_default_instance_;
class GetPaymentRequest;
struct GetPaymentRequestDefaultTypeInternal;
extern GetPaymentRequestDefaultTypeInternal _GetPaymentRequest_default_instance_;
class GetPaymentResponse;
struct GetPaymentResponseDefaultTypeInternal;
extern GetPaymentResponseDefaultTypeInternal _GetPaymentResponse_default_instance_;
class ListPaymentRequest;
struct ListPaymentRequestDefaultTypeInternal;
extern ListPaymentRequestDefaultTypeInternal _ListPaymentRequest_default_instance_;
class ListPaymentResponse;
struct ListPaymentResponseDefaultTypeInternal;
extern ListPaymentResponseDefaultTypeInternal _ListPaymentResponse_default_instance_;
class UpdatePaymentRequest;
struct UpdatePaymentRequestDefaultTypeInternal;
extern UpdatePaymentRequestDefaultTypeInternal _UpdatePaymentRequest_default_instance_;
class UpdatePaymentResponse;
struct UpdatePaymentResponseDefaultTypeInternal;
extern UpdatePaymentResponseDefaultTypeInternal _UpdatePaymentResponse_default_instance_;
}  // namespace v1alpha1
}  // namespace payment
PROTOBUF_NAMESPACE_OPEN
template<> ::payment::v1alpha1::CreatePaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreatePaymentRequest>(Arena*);
template<> ::payment::v1alpha1::CreatePaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreatePaymentResponse>(Arena*);
template<> ::payment::v1alpha1::DeletePaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::DeletePaymentRequest>(Arena*);
template<> ::payment::v1alpha1::DeletePaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::DeletePaymentResponse>(Arena*);
template<> ::payment::v1alpha1::GetPaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetPaymentRequest>(Arena*);
template<> ::payment::v1alpha1::GetPaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetPaymentResponse>(Arena*);
template<> ::payment::v1alpha1::ListPaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::ListPaymentRequest>(Arena*);
template<> ::payment::v1alpha1::ListPaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::ListPaymentResponse>(Arena*);
template<> ::payment::v1alpha1::UpdatePaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::UpdatePaymentRequest>(Arena*);
template<> ::payment::v1alpha1::UpdatePaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::UpdatePaymentResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace payment {
namespace v1alpha1 {

// ===================================================================

class CreatePaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreatePaymentRequest) */ {
 public:
  inline CreatePaymentRequest() : CreatePaymentRequest(nullptr) {}
  ~CreatePaymentRequest() override;
  explicit constexpr CreatePaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatePaymentRequest(const CreatePaymentRequest& from);
  CreatePaymentRequest(CreatePaymentRequest&& from) noexcept
    : CreatePaymentRequest() {
    *this = ::std::move(from);
  }

  inline CreatePaymentRequest& operator=(const CreatePaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePaymentRequest& operator=(CreatePaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePaymentRequest* internal_default_instance() {
    return reinterpret_cast<const CreatePaymentRequest*>(
               &_CreatePaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreatePaymentRequest& a, CreatePaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatePaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreatePaymentRequest* New() const final {
    return new CreatePaymentRequest();
  }

  CreatePaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreatePaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatePaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreatePaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreatePaymentRequest";
  }
  protected:
  explicit CreatePaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPaymentFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::Payment& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Payment* release_payment();
  ::payment::v1alpha1::Payment* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::Payment* payment);
  private:
  const ::payment::v1alpha1::Payment& _internal_payment() const;
  ::payment::v1alpha1::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::Payment* payment);
  ::payment::v1alpha1::Payment* unsafe_arena_release_payment();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreatePaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Payment* payment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreatePaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreatePaymentResponse) */ {
 public:
  inline CreatePaymentResponse() : CreatePaymentResponse(nullptr) {}
  ~CreatePaymentResponse() override;
  explicit constexpr CreatePaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatePaymentResponse(const CreatePaymentResponse& from);
  CreatePaymentResponse(CreatePaymentResponse&& from) noexcept
    : CreatePaymentResponse() {
    *this = ::std::move(from);
  }

  inline CreatePaymentResponse& operator=(const CreatePaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePaymentResponse& operator=(CreatePaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePaymentResponse* internal_default_instance() {
    return reinterpret_cast<const CreatePaymentResponse*>(
               &_CreatePaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreatePaymentResponse& a, CreatePaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatePaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreatePaymentResponse* New() const final {
    return new CreatePaymentResponse();
  }

  CreatePaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreatePaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatePaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreatePaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreatePaymentResponse";
  }
  protected:
  explicit CreatePaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPaymentFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::Payment& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Payment* release_payment();
  ::payment::v1alpha1::Payment* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::Payment* payment);
  private:
  const ::payment::v1alpha1::Payment& _internal_payment() const;
  ::payment::v1alpha1::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::Payment* payment);
  ::payment::v1alpha1::Payment* unsafe_arena_release_payment();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreatePaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Payment* payment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UpdatePaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.UpdatePaymentRequest) */ {
 public:
  inline UpdatePaymentRequest() : UpdatePaymentRequest(nullptr) {}
  ~UpdatePaymentRequest() override;
  explicit constexpr UpdatePaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdatePaymentRequest(const UpdatePaymentRequest& from);
  UpdatePaymentRequest(UpdatePaymentRequest&& from) noexcept
    : UpdatePaymentRequest() {
    *this = ::std::move(from);
  }

  inline UpdatePaymentRequest& operator=(const UpdatePaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePaymentRequest& operator=(UpdatePaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePaymentRequest* internal_default_instance() {
    return reinterpret_cast<const UpdatePaymentRequest*>(
               &_UpdatePaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UpdatePaymentRequest& a, UpdatePaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdatePaymentRequest* New() const final {
    return new UpdatePaymentRequest();
  }

  UpdatePaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdatePaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdatePaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.UpdatePaymentRequest";
  }
  protected:
  explicit UpdatePaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPaymentFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::Payment& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Payment* release_payment();
  ::payment::v1alpha1::Payment* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::Payment* payment);
  private:
  const ::payment::v1alpha1::Payment& _internal_payment() const;
  ::payment::v1alpha1::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::Payment* payment);
  ::payment::v1alpha1::Payment* unsafe_arena_release_payment();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.UpdatePaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Payment* payment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UpdatePaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.UpdatePaymentResponse) */ {
 public:
  inline UpdatePaymentResponse() : UpdatePaymentResponse(nullptr) {}
  ~UpdatePaymentResponse() override;
  explicit constexpr UpdatePaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdatePaymentResponse(const UpdatePaymentResponse& from);
  UpdatePaymentResponse(UpdatePaymentResponse&& from) noexcept
    : UpdatePaymentResponse() {
    *this = ::std::move(from);
  }

  inline UpdatePaymentResponse& operator=(const UpdatePaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePaymentResponse& operator=(UpdatePaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePaymentResponse* internal_default_instance() {
    return reinterpret_cast<const UpdatePaymentResponse*>(
               &_UpdatePaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UpdatePaymentResponse& a, UpdatePaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdatePaymentResponse* New() const final {
    return new UpdatePaymentResponse();
  }

  UpdatePaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdatePaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdatePaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.UpdatePaymentResponse";
  }
  protected:
  explicit UpdatePaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPaymentFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::Payment& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Payment* release_payment();
  ::payment::v1alpha1::Payment* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::Payment* payment);
  private:
  const ::payment::v1alpha1::Payment& _internal_payment() const;
  ::payment::v1alpha1::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::Payment* payment);
  ::payment::v1alpha1::Payment* unsafe_arena_release_payment();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.UpdatePaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Payment* payment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeletePaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeletePaymentRequest) */ {
 public:
  inline DeletePaymentRequest() : DeletePaymentRequest(nullptr) {}
  ~DeletePaymentRequest() override;
  explicit constexpr DeletePaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePaymentRequest(const DeletePaymentRequest& from);
  DeletePaymentRequest(DeletePaymentRequest&& from) noexcept
    : DeletePaymentRequest() {
    *this = ::std::move(from);
  }

  inline DeletePaymentRequest& operator=(const DeletePaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePaymentRequest& operator=(DeletePaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePaymentRequest* internal_default_instance() {
    return reinterpret_cast<const DeletePaymentRequest*>(
               &_DeletePaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeletePaymentRequest& a, DeletePaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeletePaymentRequest* New() const final {
    return new DeletePaymentRequest();
  }

  DeletePaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeletePaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeletePaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeletePaymentRequest";
  }
  protected:
  explicit DeletePaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCardHolderNameFieldNumber = 2,
    kCardTypeFieldNumber = 3,
    kCardNumberFieldNumber = 4,
    kCvvNumberFieldNumber = 5,
    kExpiryDateFieldNumber = 6,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string card_holder_name = 2 [json_name = "cardHolderName"];
  void clear_card_holder_name();
  const std::string& card_holder_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_holder_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_holder_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_holder_name();
  void set_allocated_card_holder_name(std::string* card_holder_name);
  private:
  const std::string& _internal_card_holder_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_holder_name(const std::string& value);
  std::string* _internal_mutable_card_holder_name();
  public:

  // string card_type = 3 [json_name = "cardType"];
  void clear_card_type();
  const std::string& card_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_type();
  void set_allocated_card_type(std::string* card_type);
  private:
  const std::string& _internal_card_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_type(const std::string& value);
  std::string* _internal_mutable_card_type();
  public:

  // int32 card_number = 4 [json_name = "cardNumber"];
  void clear_card_number();
  ::PROTOBUF_NAMESPACE_ID::int32 card_number() const;
  void set_card_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_card_number() const;
  void _internal_set_card_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 cvv_number = 5 [json_name = "cvvNumber"];
  void clear_cvv_number();
  ::PROTOBUF_NAMESPACE_ID::int32 cvv_number() const;
  void set_cvv_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cvv_number() const;
  void _internal_set_cvv_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 expiry_date = 6 [json_name = "expiryDate"];
  void clear_expiry_date();
  ::PROTOBUF_NAMESPACE_ID::int32 expiry_date() const;
  void set_expiry_date(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_expiry_date() const;
  void _internal_set_expiry_date(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeletePaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_holder_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 card_number_;
  ::PROTOBUF_NAMESPACE_ID::int32 cvv_number_;
  ::PROTOBUF_NAMESPACE_ID::int32 expiry_date_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeletePaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeletePaymentResponse) */ {
 public:
  inline DeletePaymentResponse() : DeletePaymentResponse(nullptr) {}
  ~DeletePaymentResponse() override;
  explicit constexpr DeletePaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePaymentResponse(const DeletePaymentResponse& from);
  DeletePaymentResponse(DeletePaymentResponse&& from) noexcept
    : DeletePaymentResponse() {
    *this = ::std::move(from);
  }

  inline DeletePaymentResponse& operator=(const DeletePaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePaymentResponse& operator=(DeletePaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePaymentResponse* internal_default_instance() {
    return reinterpret_cast<const DeletePaymentResponse*>(
               &_DeletePaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeletePaymentResponse& a, DeletePaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeletePaymentResponse* New() const final {
    return new DeletePaymentResponse();
  }

  DeletePaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeletePaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeletePaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeletePaymentResponse";
  }
  protected:
  explicit DeletePaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeletePaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetPaymentRequest) */ {
 public:
  inline GetPaymentRequest() : GetPaymentRequest(nullptr) {}
  ~GetPaymentRequest() override;
  explicit constexpr GetPaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaymentRequest(const GetPaymentRequest& from);
  GetPaymentRequest(GetPaymentRequest&& from) noexcept
    : GetPaymentRequest() {
    *this = ::std::move(from);
  }

  inline GetPaymentRequest& operator=(const GetPaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaymentRequest& operator=(GetPaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaymentRequest* internal_default_instance() {
    return reinterpret_cast<const GetPaymentRequest*>(
               &_GetPaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetPaymentRequest& a, GetPaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPaymentRequest* New() const final {
    return new GetPaymentRequest();
  }

  GetPaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetPaymentRequest";
  }
  protected:
  explicit GetPaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetPaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetPaymentResponse) */ {
 public:
  inline GetPaymentResponse() : GetPaymentResponse(nullptr) {}
  ~GetPaymentResponse() override;
  explicit constexpr GetPaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaymentResponse(const GetPaymentResponse& from);
  GetPaymentResponse(GetPaymentResponse&& from) noexcept
    : GetPaymentResponse() {
    *this = ::std::move(from);
  }

  inline GetPaymentResponse& operator=(const GetPaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaymentResponse& operator=(GetPaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaymentResponse* internal_default_instance() {
    return reinterpret_cast<const GetPaymentResponse*>(
               &_GetPaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetPaymentResponse& a, GetPaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPaymentResponse* New() const final {
    return new GetPaymentResponse();
  }

  GetPaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetPaymentResponse";
  }
  protected:
  explicit GetPaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPaymentFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::Payment& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Payment* release_payment();
  ::payment::v1alpha1::Payment* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::Payment* payment);
  private:
  const ::payment::v1alpha1::Payment& _internal_payment() const;
  ::payment::v1alpha1::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::Payment* payment);
  ::payment::v1alpha1::Payment* unsafe_arena_release_payment();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetPaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Payment* payment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListPaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ListPaymentRequest) */ {
 public:
  inline ListPaymentRequest() : ListPaymentRequest(nullptr) {}
  ~ListPaymentRequest() override;
  explicit constexpr ListPaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPaymentRequest(const ListPaymentRequest& from);
  ListPaymentRequest(ListPaymentRequest&& from) noexcept
    : ListPaymentRequest() {
    *this = ::std::move(from);
  }

  inline ListPaymentRequest& operator=(const ListPaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPaymentRequest& operator=(ListPaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPaymentRequest* internal_default_instance() {
    return reinterpret_cast<const ListPaymentRequest*>(
               &_ListPaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ListPaymentRequest& a, ListPaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPaymentRequest* New() const final {
    return new ListPaymentRequest();
  }

  ListPaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ListPaymentRequest";
  }
  protected:
  explicit ListPaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardHolderNameFieldNumber = 2,
    kCardTypeFieldNumber = 3,
    kIdFieldNumber = 1,
    kCardNumberFieldNumber = 4,
  };
  // string card_holder_name = 2 [json_name = "cardHolderName"];
  void clear_card_holder_name();
  const std::string& card_holder_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_holder_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_holder_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_holder_name();
  void set_allocated_card_holder_name(std::string* card_holder_name);
  private:
  const std::string& _internal_card_holder_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_holder_name(const std::string& value);
  std::string* _internal_mutable_card_holder_name();
  public:

  // string card_type = 3 [json_name = "cardType"];
  void clear_card_type();
  const std::string& card_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_type();
  void set_allocated_card_type(std::string* card_type);
  private:
  const std::string& _internal_card_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_type(const std::string& value);
  std::string* _internal_mutable_card_type();
  public:

  // uint32 id = 1 [json_name = "id"];
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 card_number = 4 [json_name = "cardNumber"];
  void clear_card_number();
  ::PROTOBUF_NAMESPACE_ID::int32 card_number() const;
  void set_card_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_card_number() const;
  void _internal_set_card_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ListPaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_holder_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 card_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListPaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ListPaymentResponse) */ {
 public:
  inline ListPaymentResponse() : ListPaymentResponse(nullptr) {}
  ~ListPaymentResponse() override;
  explicit constexpr ListPaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPaymentResponse(const ListPaymentResponse& from);
  ListPaymentResponse(ListPaymentResponse&& from) noexcept
    : ListPaymentResponse() {
    *this = ::std::move(from);
  }

  inline ListPaymentResponse& operator=(const ListPaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPaymentResponse& operator=(ListPaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPaymentResponse* internal_default_instance() {
    return reinterpret_cast<const ListPaymentResponse*>(
               &_ListPaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListPaymentResponse& a, ListPaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPaymentResponse* New() const final {
    return new ListPaymentResponse();
  }

  ListPaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ListPaymentResponse";
  }
  protected:
  explicit ListPaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPaymentListFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.PaymentList payment_list = 1 [json_name = "paymentList"];
  bool has_payment_list() const;
  private:
  bool _internal_has_payment_list() const;
  public:
  void clear_payment_list();
  const ::payment::v1alpha1::PaymentList& payment_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::PaymentList* release_payment_list();
  ::payment::v1alpha1::PaymentList* mutable_payment_list();
  void set_allocated_payment_list(::payment::v1alpha1::PaymentList* payment_list);
  private:
  const ::payment::v1alpha1::PaymentList& _internal_payment_list() const;
  ::payment::v1alpha1::PaymentList* _internal_mutable_payment_list();
  public:
  void unsafe_arena_set_allocated_payment_list(
      ::payment::v1alpha1::PaymentList* payment_list);
  ::payment::v1alpha1::PaymentList* unsafe_arena_release_payment_list();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ListPaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::PaymentList* payment_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreatePaymentRequest

// .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
inline bool CreatePaymentRequest::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool CreatePaymentRequest::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::Payment& CreatePaymentRequest::_internal_payment() const {
  const ::payment::v1alpha1::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Payment&>(
      ::payment::v1alpha1::_Payment_default_instance_);
}
inline const ::payment::v1alpha1::Payment& CreatePaymentRequest::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentRequest.payment)
  return _internal_payment();
}
inline void CreatePaymentRequest::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreatePaymentRequest.payment)
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::release_payment() {
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentRequest.payment)
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::mutable_payment() {
  ::payment::v1alpha1::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentRequest.payment)
  return _msg;
}
inline void CreatePaymentRequest::set_allocated_payment(::payment::v1alpha1::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentRequest.payment)
}

// string status = 2 [json_name = "status"];
inline void CreatePaymentRequest::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreatePaymentRequest::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentRequest.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePaymentRequest::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreatePaymentRequest.status)
}
inline std::string* CreatePaymentRequest::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentRequest.status)
  return _s;
}
inline const std::string& CreatePaymentRequest::_internal_status() const {
  return status_.Get();
}
inline void CreatePaymentRequest::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePaymentRequest::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePaymentRequest::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentRequest.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePaymentRequest::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentRequest.status)
}

// -------------------------------------------------------------------

// CreatePaymentResponse

// .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
inline bool CreatePaymentResponse::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool CreatePaymentResponse::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::Payment& CreatePaymentResponse::_internal_payment() const {
  const ::payment::v1alpha1::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Payment&>(
      ::payment::v1alpha1::_Payment_default_instance_);
}
inline const ::payment::v1alpha1::Payment& CreatePaymentResponse::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentResponse.payment)
  return _internal_payment();
}
inline void CreatePaymentResponse::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreatePaymentResponse.payment)
}
inline ::payment::v1alpha1::Payment* CreatePaymentResponse::release_payment() {
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Payment* CreatePaymentResponse::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentResponse.payment)
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Payment* CreatePaymentResponse::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::Payment* CreatePaymentResponse::mutable_payment() {
  ::payment::v1alpha1::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentResponse.payment)
  return _msg;
}
inline void CreatePaymentResponse::set_allocated_payment(::payment::v1alpha1::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentResponse.payment)
}

// string status = 2 [json_name = "status"];
inline void CreatePaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreatePaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreatePaymentResponse.status)
}
inline std::string* CreatePaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentResponse.status)
  return _s;
}
inline const std::string& CreatePaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void CreatePaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentResponse.status)
}

// -------------------------------------------------------------------

// UpdatePaymentRequest

// .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
inline bool UpdatePaymentRequest::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool UpdatePaymentRequest::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::Payment& UpdatePaymentRequest::_internal_payment() const {
  const ::payment::v1alpha1::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Payment&>(
      ::payment::v1alpha1::_Payment_default_instance_);
}
inline const ::payment::v1alpha1::Payment& UpdatePaymentRequest::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdatePaymentRequest.payment)
  return _internal_payment();
}
inline void UpdatePaymentRequest::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.UpdatePaymentRequest.payment)
}
inline ::payment::v1alpha1::Payment* UpdatePaymentRequest::release_payment() {
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Payment* UpdatePaymentRequest::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.UpdatePaymentRequest.payment)
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Payment* UpdatePaymentRequest::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::Payment* UpdatePaymentRequest::mutable_payment() {
  ::payment::v1alpha1::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.UpdatePaymentRequest.payment)
  return _msg;
}
inline void UpdatePaymentRequest::set_allocated_payment(::payment::v1alpha1::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.UpdatePaymentRequest.payment)
}

// string status = 2 [json_name = "status"];
inline void UpdatePaymentRequest::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& UpdatePaymentRequest::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdatePaymentRequest.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdatePaymentRequest::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.UpdatePaymentRequest.status)
}
inline std::string* UpdatePaymentRequest::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.UpdatePaymentRequest.status)
  return _s;
}
inline const std::string& UpdatePaymentRequest::_internal_status() const {
  return status_.Get();
}
inline void UpdatePaymentRequest::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdatePaymentRequest::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdatePaymentRequest::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.UpdatePaymentRequest.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdatePaymentRequest::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.UpdatePaymentRequest.status)
}

// -------------------------------------------------------------------

// UpdatePaymentResponse

// .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
inline bool UpdatePaymentResponse::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool UpdatePaymentResponse::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::Payment& UpdatePaymentResponse::_internal_payment() const {
  const ::payment::v1alpha1::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Payment&>(
      ::payment::v1alpha1::_Payment_default_instance_);
}
inline const ::payment::v1alpha1::Payment& UpdatePaymentResponse::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdatePaymentResponse.payment)
  return _internal_payment();
}
inline void UpdatePaymentResponse::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.UpdatePaymentResponse.payment)
}
inline ::payment::v1alpha1::Payment* UpdatePaymentResponse::release_payment() {
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Payment* UpdatePaymentResponse::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.UpdatePaymentResponse.payment)
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Payment* UpdatePaymentResponse::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::Payment* UpdatePaymentResponse::mutable_payment() {
  ::payment::v1alpha1::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.UpdatePaymentResponse.payment)
  return _msg;
}
inline void UpdatePaymentResponse::set_allocated_payment(::payment::v1alpha1::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.UpdatePaymentResponse.payment)
}

// string status = 2 [json_name = "status"];
inline void UpdatePaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& UpdatePaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdatePaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdatePaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.UpdatePaymentResponse.status)
}
inline std::string* UpdatePaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.UpdatePaymentResponse.status)
  return _s;
}
inline const std::string& UpdatePaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void UpdatePaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdatePaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdatePaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.UpdatePaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdatePaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.UpdatePaymentResponse.status)
}

// -------------------------------------------------------------------

// DeletePaymentRequest

// string id = 1 [json_name = "id"];
inline void DeletePaymentRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeletePaymentRequest::id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePaymentRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentRequest.id)
}
inline std::string* DeletePaymentRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeletePaymentRequest.id)
  return _s;
}
inline const std::string& DeletePaymentRequest::_internal_id() const {
  return id_.Get();
}
inline void DeletePaymentRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::release_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeletePaymentRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePaymentRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeletePaymentRequest.id)
}

// string card_holder_name = 2 [json_name = "cardHolderName"];
inline void DeletePaymentRequest::clear_card_holder_name() {
  card_holder_name_.ClearToEmpty();
}
inline const std::string& DeletePaymentRequest::card_holder_name() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentRequest.card_holder_name)
  return _internal_card_holder_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePaymentRequest::set_card_holder_name(ArgT0&& arg0, ArgT... args) {
 
 card_holder_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentRequest.card_holder_name)
}
inline std::string* DeletePaymentRequest::mutable_card_holder_name() {
  std::string* _s = _internal_mutable_card_holder_name();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeletePaymentRequest.card_holder_name)
  return _s;
}
inline const std::string& DeletePaymentRequest::_internal_card_holder_name() const {
  return card_holder_name_.Get();
}
inline void DeletePaymentRequest::_internal_set_card_holder_name(const std::string& value) {
  
  card_holder_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::_internal_mutable_card_holder_name() {
  
  return card_holder_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::release_card_holder_name() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeletePaymentRequest.card_holder_name)
  return card_holder_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePaymentRequest::set_allocated_card_holder_name(std::string* card_holder_name) {
  if (card_holder_name != nullptr) {
    
  } else {
    
  }
  card_holder_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_holder_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeletePaymentRequest.card_holder_name)
}

// string card_type = 3 [json_name = "cardType"];
inline void DeletePaymentRequest::clear_card_type() {
  card_type_.ClearToEmpty();
}
inline const std::string& DeletePaymentRequest::card_type() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentRequest.card_type)
  return _internal_card_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePaymentRequest::set_card_type(ArgT0&& arg0, ArgT... args) {
 
 card_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentRequest.card_type)
}
inline std::string* DeletePaymentRequest::mutable_card_type() {
  std::string* _s = _internal_mutable_card_type();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeletePaymentRequest.card_type)
  return _s;
}
inline const std::string& DeletePaymentRequest::_internal_card_type() const {
  return card_type_.Get();
}
inline void DeletePaymentRequest::_internal_set_card_type(const std::string& value) {
  
  card_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::_internal_mutable_card_type() {
  
  return card_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::release_card_type() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeletePaymentRequest.card_type)
  return card_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePaymentRequest::set_allocated_card_type(std::string* card_type) {
  if (card_type != nullptr) {
    
  } else {
    
  }
  card_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeletePaymentRequest.card_type)
}

// int32 card_number = 4 [json_name = "cardNumber"];
inline void DeletePaymentRequest::clear_card_number() {
  card_number_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeletePaymentRequest::_internal_card_number() const {
  return card_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeletePaymentRequest::card_number() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentRequest.card_number)
  return _internal_card_number();
}
inline void DeletePaymentRequest::_internal_set_card_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  card_number_ = value;
}
inline void DeletePaymentRequest::set_card_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_card_number(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentRequest.card_number)
}

// int32 cvv_number = 5 [json_name = "cvvNumber"];
inline void DeletePaymentRequest::clear_cvv_number() {
  cvv_number_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeletePaymentRequest::_internal_cvv_number() const {
  return cvv_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeletePaymentRequest::cvv_number() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentRequest.cvv_number)
  return _internal_cvv_number();
}
inline void DeletePaymentRequest::_internal_set_cvv_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cvv_number_ = value;
}
inline void DeletePaymentRequest::set_cvv_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cvv_number(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentRequest.cvv_number)
}

// int32 expiry_date = 6 [json_name = "expiryDate"];
inline void DeletePaymentRequest::clear_expiry_date() {
  expiry_date_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeletePaymentRequest::_internal_expiry_date() const {
  return expiry_date_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeletePaymentRequest::expiry_date() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentRequest.expiry_date)
  return _internal_expiry_date();
}
inline void DeletePaymentRequest::_internal_set_expiry_date(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  expiry_date_ = value;
}
inline void DeletePaymentRequest::set_expiry_date(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_expiry_date(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentRequest.expiry_date)
}

// -------------------------------------------------------------------

// DeletePaymentResponse

// string status = 1 [json_name = "status"];
inline void DeletePaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& DeletePaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentResponse.status)
}
inline std::string* DeletePaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeletePaymentResponse.status)
  return _s;
}
inline const std::string& DeletePaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void DeletePaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeletePaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeletePaymentResponse.status)
}

// -------------------------------------------------------------------

// GetPaymentRequest

// string id = 1 [json_name = "id"];
inline void GetPaymentRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetPaymentRequest::id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentRequest.id)
}
inline std::string* GetPaymentRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentRequest.id)
  return _s;
}
inline const std::string& GetPaymentRequest::_internal_id() const {
  return id_.Get();
}
inline void GetPaymentRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentRequest::release_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentRequest.id)
}

// -------------------------------------------------------------------

// GetPaymentResponse

// .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
inline bool GetPaymentResponse::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool GetPaymentResponse::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::Payment& GetPaymentResponse::_internal_payment() const {
  const ::payment::v1alpha1::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Payment&>(
      ::payment::v1alpha1::_Payment_default_instance_);
}
inline const ::payment::v1alpha1::Payment& GetPaymentResponse::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentResponse.payment)
  return _internal_payment();
}
inline void GetPaymentResponse::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetPaymentResponse.payment)
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::release_payment() {
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentResponse.payment)
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::mutable_payment() {
  ::payment::v1alpha1::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentResponse.payment)
  return _msg;
}
inline void GetPaymentResponse::set_allocated_payment(::payment::v1alpha1::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentResponse.payment)
}

// string status = 2 [json_name = "status"];
inline void GetPaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetPaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentResponse.status)
}
inline std::string* GetPaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentResponse.status)
  return _s;
}
inline const std::string& GetPaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void GetPaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentResponse.status)
}

// -------------------------------------------------------------------

// ListPaymentRequest

// uint32 id = 1 [json_name = "id"];
inline void ListPaymentRequest::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListPaymentRequest::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListPaymentRequest::id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentRequest.id)
  return _internal_id();
}
inline void ListPaymentRequest::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void ListPaymentRequest::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListPaymentRequest.id)
}

// string card_holder_name = 2 [json_name = "cardHolderName"];
inline void ListPaymentRequest::clear_card_holder_name() {
  card_holder_name_.ClearToEmpty();
}
inline const std::string& ListPaymentRequest::card_holder_name() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentRequest.card_holder_name)
  return _internal_card_holder_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPaymentRequest::set_card_holder_name(ArgT0&& arg0, ArgT... args) {
 
 card_holder_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListPaymentRequest.card_holder_name)
}
inline std::string* ListPaymentRequest::mutable_card_holder_name() {
  std::string* _s = _internal_mutable_card_holder_name();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListPaymentRequest.card_holder_name)
  return _s;
}
inline const std::string& ListPaymentRequest::_internal_card_holder_name() const {
  return card_holder_name_.Get();
}
inline void ListPaymentRequest::_internal_set_card_holder_name(const std::string& value) {
  
  card_holder_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPaymentRequest::_internal_mutable_card_holder_name() {
  
  return card_holder_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPaymentRequest::release_card_holder_name() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListPaymentRequest.card_holder_name)
  return card_holder_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPaymentRequest::set_allocated_card_holder_name(std::string* card_holder_name) {
  if (card_holder_name != nullptr) {
    
  } else {
    
  }
  card_holder_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_holder_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListPaymentRequest.card_holder_name)
}

// string card_type = 3 [json_name = "cardType"];
inline void ListPaymentRequest::clear_card_type() {
  card_type_.ClearToEmpty();
}
inline const std::string& ListPaymentRequest::card_type() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentRequest.card_type)
  return _internal_card_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPaymentRequest::set_card_type(ArgT0&& arg0, ArgT... args) {
 
 card_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListPaymentRequest.card_type)
}
inline std::string* ListPaymentRequest::mutable_card_type() {
  std::string* _s = _internal_mutable_card_type();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListPaymentRequest.card_type)
  return _s;
}
inline const std::string& ListPaymentRequest::_internal_card_type() const {
  return card_type_.Get();
}
inline void ListPaymentRequest::_internal_set_card_type(const std::string& value) {
  
  card_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPaymentRequest::_internal_mutable_card_type() {
  
  return card_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPaymentRequest::release_card_type() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListPaymentRequest.card_type)
  return card_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPaymentRequest::set_allocated_card_type(std::string* card_type) {
  if (card_type != nullptr) {
    
  } else {
    
  }
  card_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListPaymentRequest.card_type)
}

// int32 card_number = 4 [json_name = "cardNumber"];
inline void ListPaymentRequest::clear_card_number() {
  card_number_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ListPaymentRequest::_internal_card_number() const {
  return card_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ListPaymentRequest::card_number() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentRequest.card_number)
  return _internal_card_number();
}
inline void ListPaymentRequest::_internal_set_card_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  card_number_ = value;
}
inline void ListPaymentRequest::set_card_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_card_number(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListPaymentRequest.card_number)
}

// -------------------------------------------------------------------

// ListPaymentResponse

// .payment.v1alpha1.PaymentList payment_list = 1 [json_name = "paymentList"];
inline bool ListPaymentResponse::_internal_has_payment_list() const {
  return this != internal_default_instance() && payment_list_ != nullptr;
}
inline bool ListPaymentResponse::has_payment_list() const {
  return _internal_has_payment_list();
}
inline const ::payment::v1alpha1::PaymentList& ListPaymentResponse::_internal_payment_list() const {
  const ::payment::v1alpha1::PaymentList* p = payment_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::PaymentList&>(
      ::payment::v1alpha1::_PaymentList_default_instance_);
}
inline const ::payment::v1alpha1::PaymentList& ListPaymentResponse::payment_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentResponse.payment_list)
  return _internal_payment_list();
}
inline void ListPaymentResponse::unsafe_arena_set_allocated_payment_list(
    ::payment::v1alpha1::PaymentList* payment_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_list_);
  }
  payment_list_ = payment_list;
  if (payment_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.ListPaymentResponse.payment_list)
}
inline ::payment::v1alpha1::PaymentList* ListPaymentResponse::release_payment_list() {
  
  ::payment::v1alpha1::PaymentList* temp = payment_list_;
  payment_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::PaymentList* ListPaymentResponse::unsafe_arena_release_payment_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListPaymentResponse.payment_list)
  
  ::payment::v1alpha1::PaymentList* temp = payment_list_;
  payment_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::PaymentList* ListPaymentResponse::_internal_mutable_payment_list() {
  
  if (payment_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::PaymentList>(GetArenaForAllocation());
    payment_list_ = p;
  }
  return payment_list_;
}
inline ::payment::v1alpha1::PaymentList* ListPaymentResponse::mutable_payment_list() {
  ::payment::v1alpha1::PaymentList* _msg = _internal_mutable_payment_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListPaymentResponse.payment_list)
  return _msg;
}
inline void ListPaymentResponse::set_allocated_payment_list(::payment::v1alpha1::PaymentList* payment_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_list_);
  }
  if (payment_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_list));
    if (message_arena != submessage_arena) {
      payment_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment_list, submessage_arena);
    }
    
  } else {
    
  }
  payment_list_ = payment_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListPaymentResponse.payment_list)
}

// string status = 2 [json_name = "status"];
inline void ListPaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& ListPaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListPaymentResponse.status)
}
inline std::string* ListPaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListPaymentResponse.status)
  return _s;
}
inline const std::string& ListPaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void ListPaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListPaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListPaymentResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace payment

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_payment_2fv1alpha1_2fpayment_5fapi_2eproto
