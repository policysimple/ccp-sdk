// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: payment/v1alpha1/payment_api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_payment_2fv1alpha1_2fpayment_5fapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_payment_2fv1alpha1_2fpayment_5fapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "payment/v1alpha1/payment.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_payment_2fv1alpha1_2fpayment_5fapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[40]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
namespace payment {
namespace v1alpha1 {
class CancelSuscriptionRequest;
struct CancelSuscriptionRequestDefaultTypeInternal;
extern CancelSuscriptionRequestDefaultTypeInternal _CancelSuscriptionRequest_default_instance_;
class CancelSuscriptionResponse;
struct CancelSuscriptionResponseDefaultTypeInternal;
extern CancelSuscriptionResponseDefaultTypeInternal _CancelSuscriptionResponse_default_instance_;
class CreateCardRequest;
struct CreateCardRequestDefaultTypeInternal;
extern CreateCardRequestDefaultTypeInternal _CreateCardRequest_default_instance_;
class CreateCardResponse;
struct CreateCardResponseDefaultTypeInternal;
extern CreateCardResponseDefaultTypeInternal _CreateCardResponse_default_instance_;
class CreateCustomerRequest;
struct CreateCustomerRequestDefaultTypeInternal;
extern CreateCustomerRequestDefaultTypeInternal _CreateCustomerRequest_default_instance_;
class CreateCustomerResponse;
struct CreateCustomerResponseDefaultTypeInternal;
extern CreateCustomerResponseDefaultTypeInternal _CreateCustomerResponse_default_instance_;
class CreateInvoiceRequest;
struct CreateInvoiceRequestDefaultTypeInternal;
extern CreateInvoiceRequestDefaultTypeInternal _CreateInvoiceRequest_default_instance_;
class CreateInvoiceResponse;
struct CreateInvoiceResponseDefaultTypeInternal;
extern CreateInvoiceResponseDefaultTypeInternal _CreateInvoiceResponse_default_instance_;
class CreatePaymentRequest;
struct CreatePaymentRequestDefaultTypeInternal;
extern CreatePaymentRequestDefaultTypeInternal _CreatePaymentRequest_default_instance_;
class CreatePaymentResponse;
struct CreatePaymentResponseDefaultTypeInternal;
extern CreatePaymentResponseDefaultTypeInternal _CreatePaymentResponse_default_instance_;
class CreateProjectRequest;
struct CreateProjectRequestDefaultTypeInternal;
extern CreateProjectRequestDefaultTypeInternal _CreateProjectRequest_default_instance_;
class CreateProjectResponse;
struct CreateProjectResponseDefaultTypeInternal;
extern CreateProjectResponseDefaultTypeInternal _CreateProjectResponse_default_instance_;
class CreateSuscriptionRequest;
struct CreateSuscriptionRequestDefaultTypeInternal;
extern CreateSuscriptionRequestDefaultTypeInternal _CreateSuscriptionRequest_default_instance_;
class CreateSuscriptionResponse;
struct CreateSuscriptionResponseDefaultTypeInternal;
extern CreateSuscriptionResponseDefaultTypeInternal _CreateSuscriptionResponse_default_instance_;
class DeleteCustomerRequest;
struct DeleteCustomerRequestDefaultTypeInternal;
extern DeleteCustomerRequestDefaultTypeInternal _DeleteCustomerRequest_default_instance_;
class DeleteCustomerResponse;
struct DeleteCustomerResponseDefaultTypeInternal;
extern DeleteCustomerResponseDefaultTypeInternal _DeleteCustomerResponse_default_instance_;
class DeletePaymentRequest;
struct DeletePaymentRequestDefaultTypeInternal;
extern DeletePaymentRequestDefaultTypeInternal _DeletePaymentRequest_default_instance_;
class DeletePaymentResponse;
struct DeletePaymentResponseDefaultTypeInternal;
extern DeletePaymentResponseDefaultTypeInternal _DeletePaymentResponse_default_instance_;
class DeleteProjectRequest;
struct DeleteProjectRequestDefaultTypeInternal;
extern DeleteProjectRequestDefaultTypeInternal _DeleteProjectRequest_default_instance_;
class DeleteProjectResponse;
struct DeleteProjectResponseDefaultTypeInternal;
extern DeleteProjectResponseDefaultTypeInternal _DeleteProjectResponse_default_instance_;
class GetBilingMonthRequest;
struct GetBilingMonthRequestDefaultTypeInternal;
extern GetBilingMonthRequestDefaultTypeInternal _GetBilingMonthRequest_default_instance_;
class GetBilingMonthResponse;
struct GetBilingMonthResponseDefaultTypeInternal;
extern GetBilingMonthResponseDefaultTypeInternal _GetBilingMonthResponse_default_instance_;
class GetCustomerRequest;
struct GetCustomerRequestDefaultTypeInternal;
extern GetCustomerRequestDefaultTypeInternal _GetCustomerRequest_default_instance_;
class GetCustomerResponse;
struct GetCustomerResponseDefaultTypeInternal;
extern GetCustomerResponseDefaultTypeInternal _GetCustomerResponse_default_instance_;
class GetOrganizationRequest;
struct GetOrganizationRequestDefaultTypeInternal;
extern GetOrganizationRequestDefaultTypeInternal _GetOrganizationRequest_default_instance_;
class GetOrganizationResponse;
struct GetOrganizationResponseDefaultTypeInternal;
extern GetOrganizationResponseDefaultTypeInternal _GetOrganizationResponse_default_instance_;
class GetPaymentRequest;
struct GetPaymentRequestDefaultTypeInternal;
extern GetPaymentRequestDefaultTypeInternal _GetPaymentRequest_default_instance_;
class GetPaymentResponse;
struct GetPaymentResponseDefaultTypeInternal;
extern GetPaymentResponseDefaultTypeInternal _GetPaymentResponse_default_instance_;
class GetPaymentsRequest;
struct GetPaymentsRequestDefaultTypeInternal;
extern GetPaymentsRequestDefaultTypeInternal _GetPaymentsRequest_default_instance_;
class GetPaymentsResponse;
struct GetPaymentsResponseDefaultTypeInternal;
extern GetPaymentsResponseDefaultTypeInternal _GetPaymentsResponse_default_instance_;
class GetProjectRequest;
struct GetProjectRequestDefaultTypeInternal;
extern GetProjectRequestDefaultTypeInternal _GetProjectRequest_default_instance_;
class GetProjectResponse;
struct GetProjectResponseDefaultTypeInternal;
extern GetProjectResponseDefaultTypeInternal _GetProjectResponse_default_instance_;
class GetSuscriptionRequest;
struct GetSuscriptionRequestDefaultTypeInternal;
extern GetSuscriptionRequestDefaultTypeInternal _GetSuscriptionRequest_default_instance_;
class GetSuscriptionResponse;
struct GetSuscriptionResponseDefaultTypeInternal;
extern GetSuscriptionResponseDefaultTypeInternal _GetSuscriptionResponse_default_instance_;
class InvoiceFilterRequest;
struct InvoiceFilterRequestDefaultTypeInternal;
extern InvoiceFilterRequestDefaultTypeInternal _InvoiceFilterRequest_default_instance_;
class InvoiceFilterResponse;
struct InvoiceFilterResponseDefaultTypeInternal;
extern InvoiceFilterResponseDefaultTypeInternal _InvoiceFilterResponse_default_instance_;
class ListPaymentRequest;
struct ListPaymentRequestDefaultTypeInternal;
extern ListPaymentRequestDefaultTypeInternal _ListPaymentRequest_default_instance_;
class ListPaymentResponse;
struct ListPaymentResponseDefaultTypeInternal;
extern ListPaymentResponseDefaultTypeInternal _ListPaymentResponse_default_instance_;
class ListProjectsRequest;
struct ListProjectsRequestDefaultTypeInternal;
extern ListProjectsRequestDefaultTypeInternal _ListProjectsRequest_default_instance_;
class ListProjectsResponse;
struct ListProjectsResponseDefaultTypeInternal;
extern ListProjectsResponseDefaultTypeInternal _ListProjectsResponse_default_instance_;
}  // namespace v1alpha1
}  // namespace payment
PROTOBUF_NAMESPACE_OPEN
template<> ::payment::v1alpha1::CancelSuscriptionRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CancelSuscriptionRequest>(Arena*);
template<> ::payment::v1alpha1::CancelSuscriptionResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CancelSuscriptionResponse>(Arena*);
template<> ::payment::v1alpha1::CreateCardRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateCardRequest>(Arena*);
template<> ::payment::v1alpha1::CreateCardResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateCardResponse>(Arena*);
template<> ::payment::v1alpha1::CreateCustomerRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateCustomerRequest>(Arena*);
template<> ::payment::v1alpha1::CreateCustomerResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateCustomerResponse>(Arena*);
template<> ::payment::v1alpha1::CreateInvoiceRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateInvoiceRequest>(Arena*);
template<> ::payment::v1alpha1::CreateInvoiceResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateInvoiceResponse>(Arena*);
template<> ::payment::v1alpha1::CreatePaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreatePaymentRequest>(Arena*);
template<> ::payment::v1alpha1::CreatePaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreatePaymentResponse>(Arena*);
template<> ::payment::v1alpha1::CreateProjectRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateProjectRequest>(Arena*);
template<> ::payment::v1alpha1::CreateProjectResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateProjectResponse>(Arena*);
template<> ::payment::v1alpha1::CreateSuscriptionRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateSuscriptionRequest>(Arena*);
template<> ::payment::v1alpha1::CreateSuscriptionResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateSuscriptionResponse>(Arena*);
template<> ::payment::v1alpha1::DeleteCustomerRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::DeleteCustomerRequest>(Arena*);
template<> ::payment::v1alpha1::DeleteCustomerResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::DeleteCustomerResponse>(Arena*);
template<> ::payment::v1alpha1::DeletePaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::DeletePaymentRequest>(Arena*);
template<> ::payment::v1alpha1::DeletePaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::DeletePaymentResponse>(Arena*);
template<> ::payment::v1alpha1::DeleteProjectRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::DeleteProjectRequest>(Arena*);
template<> ::payment::v1alpha1::DeleteProjectResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::DeleteProjectResponse>(Arena*);
template<> ::payment::v1alpha1::GetBilingMonthRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetBilingMonthRequest>(Arena*);
template<> ::payment::v1alpha1::GetBilingMonthResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetBilingMonthResponse>(Arena*);
template<> ::payment::v1alpha1::GetCustomerRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetCustomerRequest>(Arena*);
template<> ::payment::v1alpha1::GetCustomerResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetCustomerResponse>(Arena*);
template<> ::payment::v1alpha1::GetOrganizationRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetOrganizationRequest>(Arena*);
template<> ::payment::v1alpha1::GetOrganizationResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetOrganizationResponse>(Arena*);
template<> ::payment::v1alpha1::GetPaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetPaymentRequest>(Arena*);
template<> ::payment::v1alpha1::GetPaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetPaymentResponse>(Arena*);
template<> ::payment::v1alpha1::GetPaymentsRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetPaymentsRequest>(Arena*);
template<> ::payment::v1alpha1::GetPaymentsResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetPaymentsResponse>(Arena*);
template<> ::payment::v1alpha1::GetProjectRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetProjectRequest>(Arena*);
template<> ::payment::v1alpha1::GetProjectResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetProjectResponse>(Arena*);
template<> ::payment::v1alpha1::GetSuscriptionRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetSuscriptionRequest>(Arena*);
template<> ::payment::v1alpha1::GetSuscriptionResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetSuscriptionResponse>(Arena*);
template<> ::payment::v1alpha1::InvoiceFilterRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::InvoiceFilterRequest>(Arena*);
template<> ::payment::v1alpha1::InvoiceFilterResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::InvoiceFilterResponse>(Arena*);
template<> ::payment::v1alpha1::ListPaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::ListPaymentRequest>(Arena*);
template<> ::payment::v1alpha1::ListPaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::ListPaymentResponse>(Arena*);
template<> ::payment::v1alpha1::ListProjectsRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::ListProjectsRequest>(Arena*);
template<> ::payment::v1alpha1::ListProjectsResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::ListProjectsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace payment {
namespace v1alpha1 {

// ===================================================================

class InvoiceFilterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.InvoiceFilterRequest) */ {
 public:
  inline InvoiceFilterRequest() : InvoiceFilterRequest(nullptr) {}
  ~InvoiceFilterRequest() override;
  explicit constexpr InvoiceFilterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvoiceFilterRequest(const InvoiceFilterRequest& from);
  InvoiceFilterRequest(InvoiceFilterRequest&& from) noexcept
    : InvoiceFilterRequest() {
    *this = ::std::move(from);
  }

  inline InvoiceFilterRequest& operator=(const InvoiceFilterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvoiceFilterRequest& operator=(InvoiceFilterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvoiceFilterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvoiceFilterRequest* internal_default_instance() {
    return reinterpret_cast<const InvoiceFilterRequest*>(
               &_InvoiceFilterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InvoiceFilterRequest& a, InvoiceFilterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InvoiceFilterRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvoiceFilterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InvoiceFilterRequest* New() const final {
    return new InvoiceFilterRequest();
  }

  InvoiceFilterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InvoiceFilterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvoiceFilterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvoiceFilterRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvoiceFilterRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.InvoiceFilterRequest";
  }
  protected:
  explicit InvoiceFilterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvoiceIdFieldNumber = 2,
    kYearFieldNumber = 3,
    kMonthFieldNumber = 4,
    kCustomerListFieldNumber = 5,
    kOrganizationIdFieldNumber = 1,
  };
  // string invoice_id = 2 [json_name = "invoiceId"];
  void clear_invoice_id();
  const std::string& invoice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invoice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invoice_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_invoice_id();
  void set_allocated_invoice_id(std::string* invoice_id);
  private:
  const std::string& _internal_invoice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invoice_id(const std::string& value);
  std::string* _internal_mutable_invoice_id();
  public:

  // string year = 3 [json_name = "year"];
  void clear_year();
  const std::string& year() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_year(ArgT0&& arg0, ArgT... args);
  std::string* mutable_year();
  PROTOBUF_MUST_USE_RESULT std::string* release_year();
  void set_allocated_year(std::string* year);
  private:
  const std::string& _internal_year() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_year(const std::string& value);
  std::string* _internal_mutable_year();
  public:

  // string month = 4 [json_name = "month"];
  void clear_month();
  const std::string& month() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_month(ArgT0&& arg0, ArgT... args);
  std::string* mutable_month();
  PROTOBUF_MUST_USE_RESULT std::string* release_month();
  void set_allocated_month(std::string* month);
  private:
  const std::string& _internal_month() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_month(const std::string& value);
  std::string* _internal_mutable_month();
  public:

  // .payment.v1alpha1.CustomerList customer_list = 5 [json_name = "customerList"];
  bool has_customer_list() const;
  private:
  bool _internal_has_customer_list() const;
  public:
  void clear_customer_list();
  const ::payment::v1alpha1::CustomerList& customer_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::CustomerList* release_customer_list();
  ::payment::v1alpha1::CustomerList* mutable_customer_list();
  void set_allocated_customer_list(::payment::v1alpha1::CustomerList* customer_list);
  private:
  const ::payment::v1alpha1::CustomerList& _internal_customer_list() const;
  ::payment::v1alpha1::CustomerList* _internal_mutable_customer_list();
  public:
  void unsafe_arena_set_allocated_customer_list(
      ::payment::v1alpha1::CustomerList* customer_list);
  ::payment::v1alpha1::CustomerList* unsafe_arena_release_customer_list();

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.InvoiceFilterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invoice_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr year_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr month_;
  ::payment::v1alpha1::CustomerList* customer_list_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class InvoiceFilterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.InvoiceFilterResponse) */ {
 public:
  inline InvoiceFilterResponse() : InvoiceFilterResponse(nullptr) {}
  ~InvoiceFilterResponse() override;
  explicit constexpr InvoiceFilterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvoiceFilterResponse(const InvoiceFilterResponse& from);
  InvoiceFilterResponse(InvoiceFilterResponse&& from) noexcept
    : InvoiceFilterResponse() {
    *this = ::std::move(from);
  }

  inline InvoiceFilterResponse& operator=(const InvoiceFilterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvoiceFilterResponse& operator=(InvoiceFilterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvoiceFilterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvoiceFilterResponse* internal_default_instance() {
    return reinterpret_cast<const InvoiceFilterResponse*>(
               &_InvoiceFilterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InvoiceFilterResponse& a, InvoiceFilterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InvoiceFilterResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvoiceFilterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InvoiceFilterResponse* New() const final {
    return new InvoiceFilterResponse();
  }

  InvoiceFilterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InvoiceFilterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvoiceFilterResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvoiceFilterResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvoiceFilterResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.InvoiceFilterResponse";
  }
  protected:
  explicit InvoiceFilterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 5,
    kCustomerListFieldNumber = 1,
    kInvoiceListFieldNumber = 2,
    kBilingListFieldNumber = 3,
    kSuscriptionListFieldNumber = 4,
  };
  // string status = 5 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.CustomerList customer_list = 1 [json_name = "customerList"];
  bool has_customer_list() const;
  private:
  bool _internal_has_customer_list() const;
  public:
  void clear_customer_list();
  const ::payment::v1alpha1::CustomerList& customer_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::CustomerList* release_customer_list();
  ::payment::v1alpha1::CustomerList* mutable_customer_list();
  void set_allocated_customer_list(::payment::v1alpha1::CustomerList* customer_list);
  private:
  const ::payment::v1alpha1::CustomerList& _internal_customer_list() const;
  ::payment::v1alpha1::CustomerList* _internal_mutable_customer_list();
  public:
  void unsafe_arena_set_allocated_customer_list(
      ::payment::v1alpha1::CustomerList* customer_list);
  ::payment::v1alpha1::CustomerList* unsafe_arena_release_customer_list();

  // .payment.v1alpha1.InvoiceList invoice_list = 2 [json_name = "invoiceList"];
  bool has_invoice_list() const;
  private:
  bool _internal_has_invoice_list() const;
  public:
  void clear_invoice_list();
  const ::payment::v1alpha1::InvoiceList& invoice_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::InvoiceList* release_invoice_list();
  ::payment::v1alpha1::InvoiceList* mutable_invoice_list();
  void set_allocated_invoice_list(::payment::v1alpha1::InvoiceList* invoice_list);
  private:
  const ::payment::v1alpha1::InvoiceList& _internal_invoice_list() const;
  ::payment::v1alpha1::InvoiceList* _internal_mutable_invoice_list();
  public:
  void unsafe_arena_set_allocated_invoice_list(
      ::payment::v1alpha1::InvoiceList* invoice_list);
  ::payment::v1alpha1::InvoiceList* unsafe_arena_release_invoice_list();

  // .payment.v1alpha1.BilingList biling_list = 3 [json_name = "bilingList"];
  bool has_biling_list() const;
  private:
  bool _internal_has_biling_list() const;
  public:
  void clear_biling_list();
  const ::payment::v1alpha1::BilingList& biling_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::BilingList* release_biling_list();
  ::payment::v1alpha1::BilingList* mutable_biling_list();
  void set_allocated_biling_list(::payment::v1alpha1::BilingList* biling_list);
  private:
  const ::payment::v1alpha1::BilingList& _internal_biling_list() const;
  ::payment::v1alpha1::BilingList* _internal_mutable_biling_list();
  public:
  void unsafe_arena_set_allocated_biling_list(
      ::payment::v1alpha1::BilingList* biling_list);
  ::payment::v1alpha1::BilingList* unsafe_arena_release_biling_list();

  // .payment.v1alpha1.SuscriptionList suscription_list = 4 [json_name = "suscriptionList"];
  bool has_suscription_list() const;
  private:
  bool _internal_has_suscription_list() const;
  public:
  void clear_suscription_list();
  const ::payment::v1alpha1::SuscriptionList& suscription_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::SuscriptionList* release_suscription_list();
  ::payment::v1alpha1::SuscriptionList* mutable_suscription_list();
  void set_allocated_suscription_list(::payment::v1alpha1::SuscriptionList* suscription_list);
  private:
  const ::payment::v1alpha1::SuscriptionList& _internal_suscription_list() const;
  ::payment::v1alpha1::SuscriptionList* _internal_mutable_suscription_list();
  public:
  void unsafe_arena_set_allocated_suscription_list(
      ::payment::v1alpha1::SuscriptionList* suscription_list);
  ::payment::v1alpha1::SuscriptionList* unsafe_arena_release_suscription_list();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.InvoiceFilterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::CustomerList* customer_list_;
  ::payment::v1alpha1::InvoiceList* invoice_list_;
  ::payment::v1alpha1::BilingList* biling_list_;
  ::payment::v1alpha1::SuscriptionList* suscription_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteCustomerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeleteCustomerRequest) */ {
 public:
  inline DeleteCustomerRequest() : DeleteCustomerRequest(nullptr) {}
  ~DeleteCustomerRequest() override;
  explicit constexpr DeleteCustomerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteCustomerRequest(const DeleteCustomerRequest& from);
  DeleteCustomerRequest(DeleteCustomerRequest&& from) noexcept
    : DeleteCustomerRequest() {
    *this = ::std::move(from);
  }

  inline DeleteCustomerRequest& operator=(const DeleteCustomerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteCustomerRequest& operator=(DeleteCustomerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteCustomerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteCustomerRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteCustomerRequest*>(
               &_DeleteCustomerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DeleteCustomerRequest& a, DeleteCustomerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteCustomerRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteCustomerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteCustomerRequest* New() const final {
    return new DeleteCustomerRequest();
  }

  DeleteCustomerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteCustomerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteCustomerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteCustomerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteCustomerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeleteCustomerRequest";
  }
  protected:
  explicit DeleteCustomerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeleteCustomerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteCustomerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeleteCustomerResponse) */ {
 public:
  inline DeleteCustomerResponse() : DeleteCustomerResponse(nullptr) {}
  ~DeleteCustomerResponse() override;
  explicit constexpr DeleteCustomerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteCustomerResponse(const DeleteCustomerResponse& from);
  DeleteCustomerResponse(DeleteCustomerResponse&& from) noexcept
    : DeleteCustomerResponse() {
    *this = ::std::move(from);
  }

  inline DeleteCustomerResponse& operator=(const DeleteCustomerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteCustomerResponse& operator=(DeleteCustomerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteCustomerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteCustomerResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteCustomerResponse*>(
               &_DeleteCustomerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeleteCustomerResponse& a, DeleteCustomerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteCustomerResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteCustomerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteCustomerResponse* New() const final {
    return new DeleteCustomerResponse();
  }

  DeleteCustomerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteCustomerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteCustomerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteCustomerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteCustomerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeleteCustomerResponse";
  }
  protected:
  explicit DeleteCustomerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeleteCustomerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetSuscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetSuscriptionRequest) */ {
 public:
  inline GetSuscriptionRequest() : GetSuscriptionRequest(nullptr) {}
  ~GetSuscriptionRequest() override;
  explicit constexpr GetSuscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSuscriptionRequest(const GetSuscriptionRequest& from);
  GetSuscriptionRequest(GetSuscriptionRequest&& from) noexcept
    : GetSuscriptionRequest() {
    *this = ::std::move(from);
  }

  inline GetSuscriptionRequest& operator=(const GetSuscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSuscriptionRequest& operator=(GetSuscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSuscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSuscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const GetSuscriptionRequest*>(
               &_GetSuscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetSuscriptionRequest& a, GetSuscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSuscriptionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSuscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetSuscriptionRequest* New() const final {
    return new GetSuscriptionRequest();
  }

  GetSuscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetSuscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSuscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSuscriptionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSuscriptionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetSuscriptionRequest";
  }
  protected:
  explicit GetSuscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuscriptionIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string suscription_id = 2 [json_name = "suscriptionId"];
  void clear_suscription_id();
  const std::string& suscription_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_suscription_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_suscription_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_suscription_id();
  void set_allocated_suscription_id(std::string* suscription_id);
  private:
  const std::string& _internal_suscription_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suscription_id(const std::string& value);
  std::string* _internal_mutable_suscription_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetSuscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr suscription_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetSuscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetSuscriptionResponse) */ {
 public:
  inline GetSuscriptionResponse() : GetSuscriptionResponse(nullptr) {}
  ~GetSuscriptionResponse() override;
  explicit constexpr GetSuscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSuscriptionResponse(const GetSuscriptionResponse& from);
  GetSuscriptionResponse(GetSuscriptionResponse&& from) noexcept
    : GetSuscriptionResponse() {
    *this = ::std::move(from);
  }

  inline GetSuscriptionResponse& operator=(const GetSuscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSuscriptionResponse& operator=(GetSuscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSuscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSuscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const GetSuscriptionResponse*>(
               &_GetSuscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetSuscriptionResponse& a, GetSuscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSuscriptionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSuscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetSuscriptionResponse* New() const final {
    return new GetSuscriptionResponse();
  }

  GetSuscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetSuscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSuscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSuscriptionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSuscriptionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetSuscriptionResponse";
  }
  protected:
  explicit GetSuscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kSuscriptionFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Suscription suscription = 1 [json_name = "suscription"];
  bool has_suscription() const;
  private:
  bool _internal_has_suscription() const;
  public:
  void clear_suscription();
  const ::payment::v1alpha1::Suscription& suscription() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Suscription* release_suscription();
  ::payment::v1alpha1::Suscription* mutable_suscription();
  void set_allocated_suscription(::payment::v1alpha1::Suscription* suscription);
  private:
  const ::payment::v1alpha1::Suscription& _internal_suscription() const;
  ::payment::v1alpha1::Suscription* _internal_mutable_suscription();
  public:
  void unsafe_arena_set_allocated_suscription(
      ::payment::v1alpha1::Suscription* suscription);
  ::payment::v1alpha1::Suscription* unsafe_arena_release_suscription();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetSuscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Suscription* suscription_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetOrganizationRequest) */ {
 public:
  inline GetOrganizationRequest() : GetOrganizationRequest(nullptr) {}
  ~GetOrganizationRequest() override;
  explicit constexpr GetOrganizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationRequest(const GetOrganizationRequest& from);
  GetOrganizationRequest(GetOrganizationRequest&& from) noexcept
    : GetOrganizationRequest() {
    *this = ::std::move(from);
  }

  inline GetOrganizationRequest& operator=(const GetOrganizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationRequest& operator=(GetOrganizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationRequest* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationRequest*>(
               &_GetOrganizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetOrganizationRequest& a, GetOrganizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetOrganizationRequest* New() const final {
    return new GetOrganizationRequest();
  }

  GetOrganizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOrganizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetOrganizationRequest";
  }
  protected:
  explicit GetOrganizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetOrganizationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetOrganizationResponse) */ {
 public:
  inline GetOrganizationResponse() : GetOrganizationResponse(nullptr) {}
  ~GetOrganizationResponse() override;
  explicit constexpr GetOrganizationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationResponse(const GetOrganizationResponse& from);
  GetOrganizationResponse(GetOrganizationResponse&& from) noexcept
    : GetOrganizationResponse() {
    *this = ::std::move(from);
  }

  inline GetOrganizationResponse& operator=(const GetOrganizationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationResponse& operator=(GetOrganizationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationResponse* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationResponse*>(
               &_GetOrganizationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetOrganizationResponse& a, GetOrganizationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetOrganizationResponse* New() const final {
    return new GetOrganizationResponse();
  }

  GetOrganizationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOrganizationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetOrganizationResponse";
  }
  protected:
  explicit GetOrganizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kCustomerFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetOrganizationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetCustomerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetCustomerRequest) */ {
 public:
  inline GetCustomerRequest() : GetCustomerRequest(nullptr) {}
  ~GetCustomerRequest() override;
  explicit constexpr GetCustomerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCustomerRequest(const GetCustomerRequest& from);
  GetCustomerRequest(GetCustomerRequest&& from) noexcept
    : GetCustomerRequest() {
    *this = ::std::move(from);
  }

  inline GetCustomerRequest& operator=(const GetCustomerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCustomerRequest& operator=(GetCustomerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCustomerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCustomerRequest* internal_default_instance() {
    return reinterpret_cast<const GetCustomerRequest*>(
               &_GetCustomerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetCustomerRequest& a, GetCustomerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCustomerRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCustomerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetCustomerRequest* New() const final {
    return new GetCustomerRequest();
  }

  GetCustomerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetCustomerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCustomerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetCustomerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCustomerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetCustomerRequest";
  }
  protected:
  explicit GetCustomerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetCustomerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetCustomerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetCustomerResponse) */ {
 public:
  inline GetCustomerResponse() : GetCustomerResponse(nullptr) {}
  ~GetCustomerResponse() override;
  explicit constexpr GetCustomerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCustomerResponse(const GetCustomerResponse& from);
  GetCustomerResponse(GetCustomerResponse&& from) noexcept
    : GetCustomerResponse() {
    *this = ::std::move(from);
  }

  inline GetCustomerResponse& operator=(const GetCustomerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCustomerResponse& operator=(GetCustomerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCustomerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCustomerResponse* internal_default_instance() {
    return reinterpret_cast<const GetCustomerResponse*>(
               &_GetCustomerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetCustomerResponse& a, GetCustomerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCustomerResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCustomerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetCustomerResponse* New() const final {
    return new GetCustomerResponse();
  }

  GetCustomerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetCustomerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCustomerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetCustomerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCustomerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetCustomerResponse";
  }
  protected:
  explicit GetCustomerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kCustomerFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetCustomerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetBilingMonthRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetBilingMonthRequest) */ {
 public:
  inline GetBilingMonthRequest() : GetBilingMonthRequest(nullptr) {}
  ~GetBilingMonthRequest() override;
  explicit constexpr GetBilingMonthRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBilingMonthRequest(const GetBilingMonthRequest& from);
  GetBilingMonthRequest(GetBilingMonthRequest&& from) noexcept
    : GetBilingMonthRequest() {
    *this = ::std::move(from);
  }

  inline GetBilingMonthRequest& operator=(const GetBilingMonthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBilingMonthRequest& operator=(GetBilingMonthRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBilingMonthRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBilingMonthRequest* internal_default_instance() {
    return reinterpret_cast<const GetBilingMonthRequest*>(
               &_GetBilingMonthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetBilingMonthRequest& a, GetBilingMonthRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBilingMonthRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBilingMonthRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBilingMonthRequest* New() const final {
    return new GetBilingMonthRequest();
  }

  GetBilingMonthRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBilingMonthRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBilingMonthRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBilingMonthRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBilingMonthRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetBilingMonthRequest";
  }
  protected:
  explicit GetBilingMonthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvoiceIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string invoice_id = 2 [json_name = "invoiceId"];
  void clear_invoice_id();
  const std::string& invoice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invoice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invoice_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_invoice_id();
  void set_allocated_invoice_id(std::string* invoice_id);
  private:
  const std::string& _internal_invoice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invoice_id(const std::string& value);
  std::string* _internal_mutable_invoice_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetBilingMonthRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invoice_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetBilingMonthResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetBilingMonthResponse) */ {
 public:
  inline GetBilingMonthResponse() : GetBilingMonthResponse(nullptr) {}
  ~GetBilingMonthResponse() override;
  explicit constexpr GetBilingMonthResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBilingMonthResponse(const GetBilingMonthResponse& from);
  GetBilingMonthResponse(GetBilingMonthResponse&& from) noexcept
    : GetBilingMonthResponse() {
    *this = ::std::move(from);
  }

  inline GetBilingMonthResponse& operator=(const GetBilingMonthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBilingMonthResponse& operator=(GetBilingMonthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBilingMonthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBilingMonthResponse* internal_default_instance() {
    return reinterpret_cast<const GetBilingMonthResponse*>(
               &_GetBilingMonthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetBilingMonthResponse& a, GetBilingMonthResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBilingMonthResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBilingMonthResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBilingMonthResponse* New() const final {
    return new GetBilingMonthResponse();
  }

  GetBilingMonthResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBilingMonthResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBilingMonthResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBilingMonthResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBilingMonthResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetBilingMonthResponse";
  }
  protected:
  explicit GetBilingMonthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kBilingFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Biling biling = 1 [json_name = "biling"];
  bool has_biling() const;
  private:
  bool _internal_has_biling() const;
  public:
  void clear_biling();
  const ::payment::v1alpha1::Biling& biling() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Biling* release_biling();
  ::payment::v1alpha1::Biling* mutable_biling();
  void set_allocated_biling(::payment::v1alpha1::Biling* biling);
  private:
  const ::payment::v1alpha1::Biling& _internal_biling() const;
  ::payment::v1alpha1::Biling* _internal_mutable_biling();
  public:
  void unsafe_arena_set_allocated_biling(
      ::payment::v1alpha1::Biling* biling);
  ::payment::v1alpha1::Biling* unsafe_arena_release_biling();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetBilingMonthResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Biling* biling_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPaymentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetPaymentsRequest) */ {
 public:
  inline GetPaymentsRequest() : GetPaymentsRequest(nullptr) {}
  ~GetPaymentsRequest() override;
  explicit constexpr GetPaymentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaymentsRequest(const GetPaymentsRequest& from);
  GetPaymentsRequest(GetPaymentsRequest&& from) noexcept
    : GetPaymentsRequest() {
    *this = ::std::move(from);
  }

  inline GetPaymentsRequest& operator=(const GetPaymentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaymentsRequest& operator=(GetPaymentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaymentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaymentsRequest* internal_default_instance() {
    return reinterpret_cast<const GetPaymentsRequest*>(
               &_GetPaymentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetPaymentsRequest& a, GetPaymentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaymentsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaymentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPaymentsRequest* New() const final {
    return new GetPaymentsRequest();
  }

  GetPaymentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPaymentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPaymentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPaymentsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPaymentsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetPaymentsRequest";
  }
  protected:
  explicit GetPaymentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetPaymentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPaymentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetPaymentsResponse) */ {
 public:
  inline GetPaymentsResponse() : GetPaymentsResponse(nullptr) {}
  ~GetPaymentsResponse() override;
  explicit constexpr GetPaymentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaymentsResponse(const GetPaymentsResponse& from);
  GetPaymentsResponse(GetPaymentsResponse&& from) noexcept
    : GetPaymentsResponse() {
    *this = ::std::move(from);
  }

  inline GetPaymentsResponse& operator=(const GetPaymentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaymentsResponse& operator=(GetPaymentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaymentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaymentsResponse* internal_default_instance() {
    return reinterpret_cast<const GetPaymentsResponse*>(
               &_GetPaymentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetPaymentsResponse& a, GetPaymentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaymentsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaymentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPaymentsResponse* New() const final {
    return new GetPaymentsResponse();
  }

  GetPaymentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPaymentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPaymentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPaymentsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPaymentsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetPaymentsResponse";
  }
  protected:
  explicit GetPaymentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPaymentFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.PaymentList payment = 1 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::PaymentList& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::PaymentList* release_payment();
  ::payment::v1alpha1::PaymentList* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::PaymentList* payment);
  private:
  const ::payment::v1alpha1::PaymentList& _internal_payment() const;
  ::payment::v1alpha1::PaymentList* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::PaymentList* payment);
  ::payment::v1alpha1::PaymentList* unsafe_arena_release_payment();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetPaymentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::PaymentList* payment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateSuscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateSuscriptionRequest) */ {
 public:
  inline CreateSuscriptionRequest() : CreateSuscriptionRequest(nullptr) {}
  ~CreateSuscriptionRequest() override;
  explicit constexpr CreateSuscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSuscriptionRequest(const CreateSuscriptionRequest& from);
  CreateSuscriptionRequest(CreateSuscriptionRequest&& from) noexcept
    : CreateSuscriptionRequest() {
    *this = ::std::move(from);
  }

  inline CreateSuscriptionRequest& operator=(const CreateSuscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSuscriptionRequest& operator=(CreateSuscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSuscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSuscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSuscriptionRequest*>(
               &_CreateSuscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CreateSuscriptionRequest& a, CreateSuscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSuscriptionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSuscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateSuscriptionRequest* New() const final {
    return new CreateSuscriptionRequest();
  }

  CreateSuscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateSuscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSuscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateSuscriptionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSuscriptionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateSuscriptionRequest";
  }
  protected:
  explicit CreateSuscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kSuscriptionFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // .payment.v1alpha1.Suscription suscription = 3 [json_name = "suscription"];
  bool has_suscription() const;
  private:
  bool _internal_has_suscription() const;
  public:
  void clear_suscription();
  const ::payment::v1alpha1::Suscription& suscription() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Suscription* release_suscription();
  ::payment::v1alpha1::Suscription* mutable_suscription();
  void set_allocated_suscription(::payment::v1alpha1::Suscription* suscription);
  private:
  const ::payment::v1alpha1::Suscription& _internal_suscription() const;
  ::payment::v1alpha1::Suscription* _internal_mutable_suscription();
  public:
  void unsafe_arena_set_allocated_suscription(
      ::payment::v1alpha1::Suscription* suscription);
  ::payment::v1alpha1::Suscription* unsafe_arena_release_suscription();

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateSuscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::payment::v1alpha1::Suscription* suscription_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateSuscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateSuscriptionResponse) */ {
 public:
  inline CreateSuscriptionResponse() : CreateSuscriptionResponse(nullptr) {}
  ~CreateSuscriptionResponse() override;
  explicit constexpr CreateSuscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSuscriptionResponse(const CreateSuscriptionResponse& from);
  CreateSuscriptionResponse(CreateSuscriptionResponse&& from) noexcept
    : CreateSuscriptionResponse() {
    *this = ::std::move(from);
  }

  inline CreateSuscriptionResponse& operator=(const CreateSuscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSuscriptionResponse& operator=(CreateSuscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSuscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSuscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const CreateSuscriptionResponse*>(
               &_CreateSuscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CreateSuscriptionResponse& a, CreateSuscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSuscriptionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSuscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateSuscriptionResponse* New() const final {
    return new CreateSuscriptionResponse();
  }

  CreateSuscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateSuscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSuscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateSuscriptionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSuscriptionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateSuscriptionResponse";
  }
  protected:
  explicit CreateSuscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kSuscriptionFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Suscription suscription = 1 [json_name = "suscription"];
  bool has_suscription() const;
  private:
  bool _internal_has_suscription() const;
  public:
  void clear_suscription();
  const ::payment::v1alpha1::Suscription& suscription() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Suscription* release_suscription();
  ::payment::v1alpha1::Suscription* mutable_suscription();
  void set_allocated_suscription(::payment::v1alpha1::Suscription* suscription);
  private:
  const ::payment::v1alpha1::Suscription& _internal_suscription() const;
  ::payment::v1alpha1::Suscription* _internal_mutable_suscription();
  public:
  void unsafe_arena_set_allocated_suscription(
      ::payment::v1alpha1::Suscription* suscription);
  ::payment::v1alpha1::Suscription* unsafe_arena_release_suscription();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateSuscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Suscription* suscription_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateProjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateProjectRequest) */ {
 public:
  inline CreateProjectRequest() : CreateProjectRequest(nullptr) {}
  ~CreateProjectRequest() override;
  explicit constexpr CreateProjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateProjectRequest(const CreateProjectRequest& from);
  CreateProjectRequest(CreateProjectRequest&& from) noexcept
    : CreateProjectRequest() {
    *this = ::std::move(from);
  }

  inline CreateProjectRequest& operator=(const CreateProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateProjectRequest& operator=(CreateProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateProjectRequest* internal_default_instance() {
    return reinterpret_cast<const CreateProjectRequest*>(
               &_CreateProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CreateProjectRequest& a, CreateProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateProjectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateProjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateProjectRequest* New() const final {
    return new CreateProjectRequest();
  }

  CreateProjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateProjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateProjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateProjectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateProjectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateProjectRequest";
  }
  protected:
  explicit CreateProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectListFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // .payment.v1alpha1.ProjectList project_list = 2 [json_name = "projectList"];
  bool has_project_list() const;
  private:
  bool _internal_has_project_list() const;
  public:
  void clear_project_list();
  const ::payment::v1alpha1::ProjectList& project_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::ProjectList* release_project_list();
  ::payment::v1alpha1::ProjectList* mutable_project_list();
  void set_allocated_project_list(::payment::v1alpha1::ProjectList* project_list);
  private:
  const ::payment::v1alpha1::ProjectList& _internal_project_list() const;
  ::payment::v1alpha1::ProjectList* _internal_mutable_project_list();
  public:
  void unsafe_arena_set_allocated_project_list(
      ::payment::v1alpha1::ProjectList* project_list);
  ::payment::v1alpha1::ProjectList* unsafe_arena_release_project_list();

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateProjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::payment::v1alpha1::ProjectList* project_list_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateProjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateProjectResponse) */ {
 public:
  inline CreateProjectResponse() : CreateProjectResponse(nullptr) {}
  ~CreateProjectResponse() override;
  explicit constexpr CreateProjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateProjectResponse(const CreateProjectResponse& from);
  CreateProjectResponse(CreateProjectResponse&& from) noexcept
    : CreateProjectResponse() {
    *this = ::std::move(from);
  }

  inline CreateProjectResponse& operator=(const CreateProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateProjectResponse& operator=(CreateProjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateProjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateProjectResponse* internal_default_instance() {
    return reinterpret_cast<const CreateProjectResponse*>(
               &_CreateProjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CreateProjectResponse& a, CreateProjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateProjectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateProjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateProjectResponse* New() const final {
    return new CreateProjectResponse();
  }

  CreateProjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateProjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateProjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateProjectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateProjectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateProjectResponse";
  }
  protected:
  explicit CreateProjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateProjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateInvoiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateInvoiceRequest) */ {
 public:
  inline CreateInvoiceRequest() : CreateInvoiceRequest(nullptr) {}
  ~CreateInvoiceRequest() override;
  explicit constexpr CreateInvoiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateInvoiceRequest(const CreateInvoiceRequest& from);
  CreateInvoiceRequest(CreateInvoiceRequest&& from) noexcept
    : CreateInvoiceRequest() {
    *this = ::std::move(from);
  }

  inline CreateInvoiceRequest& operator=(const CreateInvoiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInvoiceRequest& operator=(CreateInvoiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInvoiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateInvoiceRequest* internal_default_instance() {
    return reinterpret_cast<const CreateInvoiceRequest*>(
               &_CreateInvoiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CreateInvoiceRequest& a, CreateInvoiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInvoiceRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInvoiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateInvoiceRequest* New() const final {
    return new CreateInvoiceRequest();
  }

  CreateInvoiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateInvoiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateInvoiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateInvoiceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateInvoiceRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateInvoiceRequest";
  }
  protected:
  explicit CreateInvoiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvoiceIdFieldNumber = 2,
    kStatusFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // string invoice_id = 2 [json_name = "invoiceId"];
  void clear_invoice_id();
  const std::string& invoice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invoice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invoice_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_invoice_id();
  void set_allocated_invoice_id(std::string* invoice_id);
  private:
  const std::string& _internal_invoice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invoice_id(const std::string& value);
  std::string* _internal_mutable_invoice_id();
  public:

  // string status = 3 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateInvoiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invoice_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateInvoiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateInvoiceResponse) */ {
 public:
  inline CreateInvoiceResponse() : CreateInvoiceResponse(nullptr) {}
  ~CreateInvoiceResponse() override;
  explicit constexpr CreateInvoiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateInvoiceResponse(const CreateInvoiceResponse& from);
  CreateInvoiceResponse(CreateInvoiceResponse&& from) noexcept
    : CreateInvoiceResponse() {
    *this = ::std::move(from);
  }

  inline CreateInvoiceResponse& operator=(const CreateInvoiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInvoiceResponse& operator=(CreateInvoiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInvoiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateInvoiceResponse* internal_default_instance() {
    return reinterpret_cast<const CreateInvoiceResponse*>(
               &_CreateInvoiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CreateInvoiceResponse& a, CreateInvoiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInvoiceResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInvoiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateInvoiceResponse* New() const final {
    return new CreateInvoiceResponse();
  }

  CreateInvoiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateInvoiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateInvoiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateInvoiceResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateInvoiceResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateInvoiceResponse";
  }
  protected:
  explicit CreateInvoiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kCustomerFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateInvoiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateCardRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateCardRequest) */ {
 public:
  inline CreateCardRequest() : CreateCardRequest(nullptr) {}
  ~CreateCardRequest() override;
  explicit constexpr CreateCardRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCardRequest(const CreateCardRequest& from);
  CreateCardRequest(CreateCardRequest&& from) noexcept
    : CreateCardRequest() {
    *this = ::std::move(from);
  }

  inline CreateCardRequest& operator=(const CreateCardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCardRequest& operator=(CreateCardRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCardRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCardRequest* internal_default_instance() {
    return reinterpret_cast<const CreateCardRequest*>(
               &_CreateCardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CreateCardRequest& a, CreateCardRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCardRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCardRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateCardRequest* New() const final {
    return new CreateCardRequest();
  }

  CreateCardRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateCardRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCardRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCardRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCardRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateCardRequest";
  }
  protected:
  explicit CreateCardRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kCardFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // .payment.v1alpha1.Card card = 3 [json_name = "card"];
  bool has_card() const;
  private:
  bool _internal_has_card() const;
  public:
  void clear_card();
  const ::payment::v1alpha1::Card& card() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Card* release_card();
  ::payment::v1alpha1::Card* mutable_card();
  void set_allocated_card(::payment::v1alpha1::Card* card);
  private:
  const ::payment::v1alpha1::Card& _internal_card() const;
  ::payment::v1alpha1::Card* _internal_mutable_card();
  public:
  void unsafe_arena_set_allocated_card(
      ::payment::v1alpha1::Card* card);
  ::payment::v1alpha1::Card* unsafe_arena_release_card();

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateCardRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::payment::v1alpha1::Card* card_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateCardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateCardResponse) */ {
 public:
  inline CreateCardResponse() : CreateCardResponse(nullptr) {}
  ~CreateCardResponse() override;
  explicit constexpr CreateCardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCardResponse(const CreateCardResponse& from);
  CreateCardResponse(CreateCardResponse&& from) noexcept
    : CreateCardResponse() {
    *this = ::std::move(from);
  }

  inline CreateCardResponse& operator=(const CreateCardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCardResponse& operator=(CreateCardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCardResponse* internal_default_instance() {
    return reinterpret_cast<const CreateCardResponse*>(
               &_CreateCardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CreateCardResponse& a, CreateCardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCardResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateCardResponse* New() const final {
    return new CreateCardResponse();
  }

  CreateCardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateCardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCardResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCardResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCardResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateCardResponse";
  }
  protected:
  explicit CreateCardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string token_id = 1 [json_name = "tokenId"];
  void clear_token_id();
  const std::string& token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_token_id();
  void set_allocated_token_id(std::string* token_id);
  private:
  const std::string& _internal_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_id(const std::string& value);
  std::string* _internal_mutable_token_id();
  public:

  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateCardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CancelSuscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CancelSuscriptionRequest) */ {
 public:
  inline CancelSuscriptionRequest() : CancelSuscriptionRequest(nullptr) {}
  ~CancelSuscriptionRequest() override;
  explicit constexpr CancelSuscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelSuscriptionRequest(const CancelSuscriptionRequest& from);
  CancelSuscriptionRequest(CancelSuscriptionRequest&& from) noexcept
    : CancelSuscriptionRequest() {
    *this = ::std::move(from);
  }

  inline CancelSuscriptionRequest& operator=(const CancelSuscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelSuscriptionRequest& operator=(CancelSuscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelSuscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelSuscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const CancelSuscriptionRequest*>(
               &_CancelSuscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CancelSuscriptionRequest& a, CancelSuscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelSuscriptionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelSuscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelSuscriptionRequest* New() const final {
    return new CancelSuscriptionRequest();
  }

  CancelSuscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelSuscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelSuscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CancelSuscriptionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelSuscriptionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CancelSuscriptionRequest";
  }
  protected:
  explicit CancelSuscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kSuscriptionIdFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // string suscription_id = 3 [json_name = "suscriptionId"];
  void clear_suscription_id();
  const std::string& suscription_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_suscription_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_suscription_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_suscription_id();
  void set_allocated_suscription_id(std::string* suscription_id);
  private:
  const std::string& _internal_suscription_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suscription_id(const std::string& value);
  std::string* _internal_mutable_suscription_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CancelSuscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr suscription_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CancelSuscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CancelSuscriptionResponse) */ {
 public:
  inline CancelSuscriptionResponse() : CancelSuscriptionResponse(nullptr) {}
  ~CancelSuscriptionResponse() override;
  explicit constexpr CancelSuscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelSuscriptionResponse(const CancelSuscriptionResponse& from);
  CancelSuscriptionResponse(CancelSuscriptionResponse&& from) noexcept
    : CancelSuscriptionResponse() {
    *this = ::std::move(from);
  }

  inline CancelSuscriptionResponse& operator=(const CancelSuscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelSuscriptionResponse& operator=(CancelSuscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelSuscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelSuscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const CancelSuscriptionResponse*>(
               &_CancelSuscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CancelSuscriptionResponse& a, CancelSuscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelSuscriptionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelSuscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelSuscriptionResponse* New() const final {
    return new CancelSuscriptionResponse();
  }

  CancelSuscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelSuscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelSuscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CancelSuscriptionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelSuscriptionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CancelSuscriptionResponse";
  }
  protected:
  explicit CancelSuscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CancelSuscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateCustomerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateCustomerRequest) */ {
 public:
  inline CreateCustomerRequest() : CreateCustomerRequest(nullptr) {}
  ~CreateCustomerRequest() override;
  explicit constexpr CreateCustomerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCustomerRequest(const CreateCustomerRequest& from);
  CreateCustomerRequest(CreateCustomerRequest&& from) noexcept
    : CreateCustomerRequest() {
    *this = ::std::move(from);
  }

  inline CreateCustomerRequest& operator=(const CreateCustomerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCustomerRequest& operator=(CreateCustomerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCustomerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCustomerRequest* internal_default_instance() {
    return reinterpret_cast<const CreateCustomerRequest*>(
               &_CreateCustomerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CreateCustomerRequest& a, CreateCustomerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCustomerRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCustomerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateCustomerRequest* New() const final {
    return new CreateCustomerRequest();
  }

  CreateCustomerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateCustomerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCustomerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCustomerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCustomerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateCustomerRequest";
  }
  protected:
  explicit CreateCustomerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerFieldNumber = 1,
  };
  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateCustomerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateCustomerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateCustomerResponse) */ {
 public:
  inline CreateCustomerResponse() : CreateCustomerResponse(nullptr) {}
  ~CreateCustomerResponse() override;
  explicit constexpr CreateCustomerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCustomerResponse(const CreateCustomerResponse& from);
  CreateCustomerResponse(CreateCustomerResponse&& from) noexcept
    : CreateCustomerResponse() {
    *this = ::std::move(from);
  }

  inline CreateCustomerResponse& operator=(const CreateCustomerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCustomerResponse& operator=(CreateCustomerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCustomerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCustomerResponse* internal_default_instance() {
    return reinterpret_cast<const CreateCustomerResponse*>(
               &_CreateCustomerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CreateCustomerResponse& a, CreateCustomerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCustomerResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCustomerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateCustomerResponse* New() const final {
    return new CreateCustomerResponse();
  }

  CreateCustomerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateCustomerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCustomerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCustomerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCustomerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateCustomerResponse";
  }
  protected:
  explicit CreateCustomerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string customer_id = 1 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateCustomerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreatePaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreatePaymentRequest) */ {
 public:
  inline CreatePaymentRequest() : CreatePaymentRequest(nullptr) {}
  ~CreatePaymentRequest() override;
  explicit constexpr CreatePaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatePaymentRequest(const CreatePaymentRequest& from);
  CreatePaymentRequest(CreatePaymentRequest&& from) noexcept
    : CreatePaymentRequest() {
    *this = ::std::move(from);
  }

  inline CreatePaymentRequest& operator=(const CreatePaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePaymentRequest& operator=(CreatePaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePaymentRequest* internal_default_instance() {
    return reinterpret_cast<const CreatePaymentRequest*>(
               &_CreatePaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CreatePaymentRequest& a, CreatePaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatePaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreatePaymentRequest* New() const final {
    return new CreatePaymentRequest();
  }

  CreatePaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreatePaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatePaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreatePaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreatePaymentRequest";
  }
  protected:
  explicit CreatePaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kPaymentFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // .payment.v1alpha1.Payment payment = 3 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::Payment& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Payment* release_payment();
  ::payment::v1alpha1::Payment* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::Payment* payment);
  private:
  const ::payment::v1alpha1::Payment& _internal_payment() const;
  ::payment::v1alpha1::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::Payment* payment);
  ::payment::v1alpha1::Payment* unsafe_arena_release_payment();

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreatePaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::payment::v1alpha1::Payment* payment_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreatePaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreatePaymentResponse) */ {
 public:
  inline CreatePaymentResponse() : CreatePaymentResponse(nullptr) {}
  ~CreatePaymentResponse() override;
  explicit constexpr CreatePaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatePaymentResponse(const CreatePaymentResponse& from);
  CreatePaymentResponse(CreatePaymentResponse&& from) noexcept
    : CreatePaymentResponse() {
    *this = ::std::move(from);
  }

  inline CreatePaymentResponse& operator=(const CreatePaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePaymentResponse& operator=(CreatePaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePaymentResponse* internal_default_instance() {
    return reinterpret_cast<const CreatePaymentResponse*>(
               &_CreatePaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CreatePaymentResponse& a, CreatePaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatePaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreatePaymentResponse* New() const final {
    return new CreatePaymentResponse();
  }

  CreatePaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreatePaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatePaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreatePaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreatePaymentResponse";
  }
  protected:
  explicit CreatePaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string card_id = 1 [json_name = "cardId"];
  void clear_card_id();
  const std::string& card_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_id();
  void set_allocated_card_id(std::string* card_id);
  private:
  const std::string& _internal_card_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_id(const std::string& value);
  std::string* _internal_mutable_card_id();
  public:

  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreatePaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeletePaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeletePaymentRequest) */ {
 public:
  inline DeletePaymentRequest() : DeletePaymentRequest(nullptr) {}
  ~DeletePaymentRequest() override;
  explicit constexpr DeletePaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePaymentRequest(const DeletePaymentRequest& from);
  DeletePaymentRequest(DeletePaymentRequest&& from) noexcept
    : DeletePaymentRequest() {
    *this = ::std::move(from);
  }

  inline DeletePaymentRequest& operator=(const DeletePaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePaymentRequest& operator=(DeletePaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePaymentRequest* internal_default_instance() {
    return reinterpret_cast<const DeletePaymentRequest*>(
               &_DeletePaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(DeletePaymentRequest& a, DeletePaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeletePaymentRequest* New() const final {
    return new DeletePaymentRequest();
  }

  DeletePaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeletePaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeletePaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeletePaymentRequest";
  }
  protected:
  explicit DeletePaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kCardIdFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // string card_id = 3 [json_name = "cardId"];
  void clear_card_id();
  const std::string& card_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_id();
  void set_allocated_card_id(std::string* card_id);
  private:
  const std::string& _internal_card_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_id(const std::string& value);
  std::string* _internal_mutable_card_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeletePaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeletePaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeletePaymentResponse) */ {
 public:
  inline DeletePaymentResponse() : DeletePaymentResponse(nullptr) {}
  ~DeletePaymentResponse() override;
  explicit constexpr DeletePaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePaymentResponse(const DeletePaymentResponse& from);
  DeletePaymentResponse(DeletePaymentResponse&& from) noexcept
    : DeletePaymentResponse() {
    *this = ::std::move(from);
  }

  inline DeletePaymentResponse& operator=(const DeletePaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePaymentResponse& operator=(DeletePaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePaymentResponse* internal_default_instance() {
    return reinterpret_cast<const DeletePaymentResponse*>(
               &_DeletePaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(DeletePaymentResponse& a, DeletePaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeletePaymentResponse* New() const final {
    return new DeletePaymentResponse();
  }

  DeletePaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeletePaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeletePaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeletePaymentResponse";
  }
  protected:
  explicit DeletePaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeletePaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetPaymentRequest) */ {
 public:
  inline GetPaymentRequest() : GetPaymentRequest(nullptr) {}
  ~GetPaymentRequest() override;
  explicit constexpr GetPaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaymentRequest(const GetPaymentRequest& from);
  GetPaymentRequest(GetPaymentRequest&& from) noexcept
    : GetPaymentRequest() {
    *this = ::std::move(from);
  }

  inline GetPaymentRequest& operator=(const GetPaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaymentRequest& operator=(GetPaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaymentRequest* internal_default_instance() {
    return reinterpret_cast<const GetPaymentRequest*>(
               &_GetPaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetPaymentRequest& a, GetPaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPaymentRequest* New() const final {
    return new GetPaymentRequest();
  }

  GetPaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetPaymentRequest";
  }
  protected:
  explicit GetPaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kCardIdFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // string card_id = 3 [json_name = "cardId"];
  void clear_card_id();
  const std::string& card_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_id();
  void set_allocated_card_id(std::string* card_id);
  private:
  const std::string& _internal_card_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_id(const std::string& value);
  std::string* _internal_mutable_card_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetPaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetPaymentResponse) */ {
 public:
  inline GetPaymentResponse() : GetPaymentResponse(nullptr) {}
  ~GetPaymentResponse() override;
  explicit constexpr GetPaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaymentResponse(const GetPaymentResponse& from);
  GetPaymentResponse(GetPaymentResponse&& from) noexcept
    : GetPaymentResponse() {
    *this = ::std::move(from);
  }

  inline GetPaymentResponse& operator=(const GetPaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaymentResponse& operator=(GetPaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaymentResponse* internal_default_instance() {
    return reinterpret_cast<const GetPaymentResponse*>(
               &_GetPaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GetPaymentResponse& a, GetPaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPaymentResponse* New() const final {
    return new GetPaymentResponse();
  }

  GetPaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetPaymentResponse";
  }
  protected:
  explicit GetPaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPaymentFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::Payment& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Payment* release_payment();
  ::payment::v1alpha1::Payment* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::Payment* payment);
  private:
  const ::payment::v1alpha1::Payment& _internal_payment() const;
  ::payment::v1alpha1::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::Payment* payment);
  ::payment::v1alpha1::Payment* unsafe_arena_release_payment();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetPaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Payment* payment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListPaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ListPaymentRequest) */ {
 public:
  inline ListPaymentRequest() : ListPaymentRequest(nullptr) {}
  ~ListPaymentRequest() override;
  explicit constexpr ListPaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPaymentRequest(const ListPaymentRequest& from);
  ListPaymentRequest(ListPaymentRequest&& from) noexcept
    : ListPaymentRequest() {
    *this = ::std::move(from);
  }

  inline ListPaymentRequest& operator=(const ListPaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPaymentRequest& operator=(ListPaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPaymentRequest* internal_default_instance() {
    return reinterpret_cast<const ListPaymentRequest*>(
               &_ListPaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ListPaymentRequest& a, ListPaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPaymentRequest* New() const final {
    return new ListPaymentRequest();
  }

  ListPaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ListPaymentRequest";
  }
  protected:
  explicit ListPaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ListPaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListPaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ListPaymentResponse) */ {
 public:
  inline ListPaymentResponse() : ListPaymentResponse(nullptr) {}
  ~ListPaymentResponse() override;
  explicit constexpr ListPaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPaymentResponse(const ListPaymentResponse& from);
  ListPaymentResponse(ListPaymentResponse&& from) noexcept
    : ListPaymentResponse() {
    *this = ::std::move(from);
  }

  inline ListPaymentResponse& operator=(const ListPaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPaymentResponse& operator=(ListPaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPaymentResponse* internal_default_instance() {
    return reinterpret_cast<const ListPaymentResponse*>(
               &_ListPaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ListPaymentResponse& a, ListPaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPaymentResponse* New() const final {
    return new ListPaymentResponse();
  }

  ListPaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ListPaymentResponse";
  }
  protected:
  explicit ListPaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPaymentListFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.PaymentList payment_list = 1 [json_name = "paymentList"];
  bool has_payment_list() const;
  private:
  bool _internal_has_payment_list() const;
  public:
  void clear_payment_list();
  const ::payment::v1alpha1::PaymentList& payment_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::PaymentList* release_payment_list();
  ::payment::v1alpha1::PaymentList* mutable_payment_list();
  void set_allocated_payment_list(::payment::v1alpha1::PaymentList* payment_list);
  private:
  const ::payment::v1alpha1::PaymentList& _internal_payment_list() const;
  ::payment::v1alpha1::PaymentList* _internal_mutable_payment_list();
  public:
  void unsafe_arena_set_allocated_payment_list(
      ::payment::v1alpha1::PaymentList* payment_list);
  ::payment::v1alpha1::PaymentList* unsafe_arena_release_payment_list();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ListPaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::PaymentList* payment_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListProjectsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ListProjectsRequest) */ {
 public:
  inline ListProjectsRequest() : ListProjectsRequest(nullptr) {}
  ~ListProjectsRequest() override;
  explicit constexpr ListProjectsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListProjectsRequest(const ListProjectsRequest& from);
  ListProjectsRequest(ListProjectsRequest&& from) noexcept
    : ListProjectsRequest() {
    *this = ::std::move(from);
  }

  inline ListProjectsRequest& operator=(const ListProjectsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListProjectsRequest& operator=(ListProjectsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListProjectsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListProjectsRequest* internal_default_instance() {
    return reinterpret_cast<const ListProjectsRequest*>(
               &_ListProjectsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ListProjectsRequest& a, ListProjectsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListProjectsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListProjectsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListProjectsRequest* New() const final {
    return new ListProjectsRequest();
  }

  ListProjectsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListProjectsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListProjectsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListProjectsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListProjectsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ListProjectsRequest";
  }
  protected:
  explicit ListProjectsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ListProjectsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListProjectsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ListProjectsResponse) */ {
 public:
  inline ListProjectsResponse() : ListProjectsResponse(nullptr) {}
  ~ListProjectsResponse() override;
  explicit constexpr ListProjectsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListProjectsResponse(const ListProjectsResponse& from);
  ListProjectsResponse(ListProjectsResponse&& from) noexcept
    : ListProjectsResponse() {
    *this = ::std::move(from);
  }

  inline ListProjectsResponse& operator=(const ListProjectsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListProjectsResponse& operator=(ListProjectsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListProjectsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListProjectsResponse* internal_default_instance() {
    return reinterpret_cast<const ListProjectsResponse*>(
               &_ListProjectsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ListProjectsResponse& a, ListProjectsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListProjectsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListProjectsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListProjectsResponse* New() const final {
    return new ListProjectsResponse();
  }

  ListProjectsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListProjectsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListProjectsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListProjectsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListProjectsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ListProjectsResponse";
  }
  protected:
  explicit ListProjectsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kProjectListFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.ProjectList project_list = 1 [json_name = "projectList"];
  bool has_project_list() const;
  private:
  bool _internal_has_project_list() const;
  public:
  void clear_project_list();
  const ::payment::v1alpha1::ProjectList& project_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::ProjectList* release_project_list();
  ::payment::v1alpha1::ProjectList* mutable_project_list();
  void set_allocated_project_list(::payment::v1alpha1::ProjectList* project_list);
  private:
  const ::payment::v1alpha1::ProjectList& _internal_project_list() const;
  ::payment::v1alpha1::ProjectList* _internal_mutable_project_list();
  public:
  void unsafe_arena_set_allocated_project_list(
      ::payment::v1alpha1::ProjectList* project_list);
  ::payment::v1alpha1::ProjectList* unsafe_arena_release_project_list();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ListProjectsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::ProjectList* project_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetProjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetProjectRequest) */ {
 public:
  inline GetProjectRequest() : GetProjectRequest(nullptr) {}
  ~GetProjectRequest() override;
  explicit constexpr GetProjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProjectRequest(const GetProjectRequest& from);
  GetProjectRequest(GetProjectRequest&& from) noexcept
    : GetProjectRequest() {
    *this = ::std::move(from);
  }

  inline GetProjectRequest& operator=(const GetProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProjectRequest& operator=(GetProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProjectRequest* internal_default_instance() {
    return reinterpret_cast<const GetProjectRequest*>(
               &_GetProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GetProjectRequest& a, GetProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProjectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProjectRequest* New() const final {
    return new GetProjectRequest();
  }

  GetProjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetProjectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProjectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetProjectRequest";
  }
  protected:
  explicit GetProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kProjectIdFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string project_id = 2 [json_name = "projectId"];
  void clear_project_id();
  const std::string& project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_project_id();
  void set_allocated_project_id(std::string* project_id);
  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(const std::string& value);
  std::string* _internal_mutable_project_id();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetProjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetProjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetProjectResponse) */ {
 public:
  inline GetProjectResponse() : GetProjectResponse(nullptr) {}
  ~GetProjectResponse() override;
  explicit constexpr GetProjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProjectResponse(const GetProjectResponse& from);
  GetProjectResponse(GetProjectResponse&& from) noexcept
    : GetProjectResponse() {
    *this = ::std::move(from);
  }

  inline GetProjectResponse& operator=(const GetProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProjectResponse& operator=(GetProjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProjectResponse* internal_default_instance() {
    return reinterpret_cast<const GetProjectResponse*>(
               &_GetProjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GetProjectResponse& a, GetProjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProjectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProjectResponse* New() const final {
    return new GetProjectResponse();
  }

  GetProjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetProjectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProjectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetProjectResponse";
  }
  protected:
  explicit GetProjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kProjectFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Project project = 1 [json_name = "project"];
  bool has_project() const;
  private:
  bool _internal_has_project() const;
  public:
  void clear_project();
  const ::payment::v1alpha1::Project& project() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Project* release_project();
  ::payment::v1alpha1::Project* mutable_project();
  void set_allocated_project(::payment::v1alpha1::Project* project);
  private:
  const ::payment::v1alpha1::Project& _internal_project() const;
  ::payment::v1alpha1::Project* _internal_mutable_project();
  public:
  void unsafe_arena_set_allocated_project(
      ::payment::v1alpha1::Project* project);
  ::payment::v1alpha1::Project* unsafe_arena_release_project();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetProjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Project* project_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteProjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeleteProjectRequest) */ {
 public:
  inline DeleteProjectRequest() : DeleteProjectRequest(nullptr) {}
  ~DeleteProjectRequest() override;
  explicit constexpr DeleteProjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteProjectRequest(const DeleteProjectRequest& from);
  DeleteProjectRequest(DeleteProjectRequest&& from) noexcept
    : DeleteProjectRequest() {
    *this = ::std::move(from);
  }

  inline DeleteProjectRequest& operator=(const DeleteProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteProjectRequest& operator=(DeleteProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteProjectRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteProjectRequest*>(
               &_DeleteProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(DeleteProjectRequest& a, DeleteProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteProjectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteProjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteProjectRequest* New() const final {
    return new DeleteProjectRequest();
  }

  DeleteProjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteProjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteProjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteProjectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteProjectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeleteProjectRequest";
  }
  protected:
  explicit DeleteProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string project_id = 2 [json_name = "projectId"];
  void clear_project_id();
  const std::string& project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_project_id();
  void set_allocated_project_id(std::string* project_id);
  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(const std::string& value);
  std::string* _internal_mutable_project_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeleteProjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteProjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeleteProjectResponse) */ {
 public:
  inline DeleteProjectResponse() : DeleteProjectResponse(nullptr) {}
  ~DeleteProjectResponse() override;
  explicit constexpr DeleteProjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteProjectResponse(const DeleteProjectResponse& from);
  DeleteProjectResponse(DeleteProjectResponse&& from) noexcept
    : DeleteProjectResponse() {
    *this = ::std::move(from);
  }

  inline DeleteProjectResponse& operator=(const DeleteProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteProjectResponse& operator=(DeleteProjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteProjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteProjectResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteProjectResponse*>(
               &_DeleteProjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(DeleteProjectResponse& a, DeleteProjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteProjectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteProjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteProjectResponse* New() const final {
    return new DeleteProjectResponse();
  }

  DeleteProjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteProjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteProjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteProjectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteProjectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeleteProjectResponse";
  }
  protected:
  explicit DeleteProjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeleteProjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InvoiceFilterRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void InvoiceFilterRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InvoiceFilterRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InvoiceFilterRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.organization_id)
  return _internal_organization_id();
}
inline void InvoiceFilterRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void InvoiceFilterRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.organization_id)
}

// string invoice_id = 2 [json_name = "invoiceId"];
inline void InvoiceFilterRequest::clear_invoice_id() {
  invoice_id_.ClearToEmpty();
}
inline const std::string& InvoiceFilterRequest::invoice_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.invoice_id)
  return _internal_invoice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceFilterRequest::set_invoice_id(ArgT0&& arg0, ArgT... args) {
 
 invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.invoice_id)
}
inline std::string* InvoiceFilterRequest::mutable_invoice_id() {
  std::string* _s = _internal_mutable_invoice_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterRequest.invoice_id)
  return _s;
}
inline const std::string& InvoiceFilterRequest::_internal_invoice_id() const {
  return invoice_id_.Get();
}
inline void InvoiceFilterRequest::_internal_set_invoice_id(const std::string& value) {
  
  invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::_internal_mutable_invoice_id() {
  
  return invoice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::release_invoice_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterRequest.invoice_id)
  return invoice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvoiceFilterRequest::set_allocated_invoice_id(std::string* invoice_id) {
  if (invoice_id != nullptr) {
    
  } else {
    
  }
  invoice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invoice_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterRequest.invoice_id)
}

// string year = 3 [json_name = "year"];
inline void InvoiceFilterRequest::clear_year() {
  year_.ClearToEmpty();
}
inline const std::string& InvoiceFilterRequest::year() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.year)
  return _internal_year();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceFilterRequest::set_year(ArgT0&& arg0, ArgT... args) {
 
 year_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.year)
}
inline std::string* InvoiceFilterRequest::mutable_year() {
  std::string* _s = _internal_mutable_year();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterRequest.year)
  return _s;
}
inline const std::string& InvoiceFilterRequest::_internal_year() const {
  return year_.Get();
}
inline void InvoiceFilterRequest::_internal_set_year(const std::string& value) {
  
  year_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::_internal_mutable_year() {
  
  return year_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::release_year() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterRequest.year)
  return year_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvoiceFilterRequest::set_allocated_year(std::string* year) {
  if (year != nullptr) {
    
  } else {
    
  }
  year_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), year,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterRequest.year)
}

// string month = 4 [json_name = "month"];
inline void InvoiceFilterRequest::clear_month() {
  month_.ClearToEmpty();
}
inline const std::string& InvoiceFilterRequest::month() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.month)
  return _internal_month();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceFilterRequest::set_month(ArgT0&& arg0, ArgT... args) {
 
 month_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.month)
}
inline std::string* InvoiceFilterRequest::mutable_month() {
  std::string* _s = _internal_mutable_month();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterRequest.month)
  return _s;
}
inline const std::string& InvoiceFilterRequest::_internal_month() const {
  return month_.Get();
}
inline void InvoiceFilterRequest::_internal_set_month(const std::string& value) {
  
  month_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::_internal_mutable_month() {
  
  return month_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::release_month() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterRequest.month)
  return month_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvoiceFilterRequest::set_allocated_month(std::string* month) {
  if (month != nullptr) {
    
  } else {
    
  }
  month_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), month,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterRequest.month)
}

// .payment.v1alpha1.CustomerList customer_list = 5 [json_name = "customerList"];
inline bool InvoiceFilterRequest::_internal_has_customer_list() const {
  return this != internal_default_instance() && customer_list_ != nullptr;
}
inline bool InvoiceFilterRequest::has_customer_list() const {
  return _internal_has_customer_list();
}
inline const ::payment::v1alpha1::CustomerList& InvoiceFilterRequest::_internal_customer_list() const {
  const ::payment::v1alpha1::CustomerList* p = customer_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::CustomerList&>(
      ::payment::v1alpha1::_CustomerList_default_instance_);
}
inline const ::payment::v1alpha1::CustomerList& InvoiceFilterRequest::customer_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.customer_list)
  return _internal_customer_list();
}
inline void InvoiceFilterRequest::unsafe_arena_set_allocated_customer_list(
    ::payment::v1alpha1::CustomerList* customer_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_list_);
  }
  customer_list_ = customer_list;
  if (customer_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.InvoiceFilterRequest.customer_list)
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterRequest::release_customer_list() {
  
  ::payment::v1alpha1::CustomerList* temp = customer_list_;
  customer_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterRequest::unsafe_arena_release_customer_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterRequest.customer_list)
  
  ::payment::v1alpha1::CustomerList* temp = customer_list_;
  customer_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterRequest::_internal_mutable_customer_list() {
  
  if (customer_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::CustomerList>(GetArenaForAllocation());
    customer_list_ = p;
  }
  return customer_list_;
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterRequest::mutable_customer_list() {
  ::payment::v1alpha1::CustomerList* _msg = _internal_mutable_customer_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterRequest.customer_list)
  return _msg;
}
inline void InvoiceFilterRequest::set_allocated_customer_list(::payment::v1alpha1::CustomerList* customer_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_list_);
  }
  if (customer_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_list));
    if (message_arena != submessage_arena) {
      customer_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer_list, submessage_arena);
    }
    
  } else {
    
  }
  customer_list_ = customer_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterRequest.customer_list)
}

// -------------------------------------------------------------------

// InvoiceFilterResponse

// .payment.v1alpha1.CustomerList customer_list = 1 [json_name = "customerList"];
inline bool InvoiceFilterResponse::_internal_has_customer_list() const {
  return this != internal_default_instance() && customer_list_ != nullptr;
}
inline bool InvoiceFilterResponse::has_customer_list() const {
  return _internal_has_customer_list();
}
inline const ::payment::v1alpha1::CustomerList& InvoiceFilterResponse::_internal_customer_list() const {
  const ::payment::v1alpha1::CustomerList* p = customer_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::CustomerList&>(
      ::payment::v1alpha1::_CustomerList_default_instance_);
}
inline const ::payment::v1alpha1::CustomerList& InvoiceFilterResponse::customer_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterResponse.customer_list)
  return _internal_customer_list();
}
inline void InvoiceFilterResponse::unsafe_arena_set_allocated_customer_list(
    ::payment::v1alpha1::CustomerList* customer_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_list_);
  }
  customer_list_ = customer_list;
  if (customer_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.InvoiceFilterResponse.customer_list)
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterResponse::release_customer_list() {
  
  ::payment::v1alpha1::CustomerList* temp = customer_list_;
  customer_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterResponse::unsafe_arena_release_customer_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterResponse.customer_list)
  
  ::payment::v1alpha1::CustomerList* temp = customer_list_;
  customer_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterResponse::_internal_mutable_customer_list() {
  
  if (customer_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::CustomerList>(GetArenaForAllocation());
    customer_list_ = p;
  }
  return customer_list_;
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterResponse::mutable_customer_list() {
  ::payment::v1alpha1::CustomerList* _msg = _internal_mutable_customer_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterResponse.customer_list)
  return _msg;
}
inline void InvoiceFilterResponse::set_allocated_customer_list(::payment::v1alpha1::CustomerList* customer_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_list_);
  }
  if (customer_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_list));
    if (message_arena != submessage_arena) {
      customer_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer_list, submessage_arena);
    }
    
  } else {
    
  }
  customer_list_ = customer_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterResponse.customer_list)
}

// .payment.v1alpha1.InvoiceList invoice_list = 2 [json_name = "invoiceList"];
inline bool InvoiceFilterResponse::_internal_has_invoice_list() const {
  return this != internal_default_instance() && invoice_list_ != nullptr;
}
inline bool InvoiceFilterResponse::has_invoice_list() const {
  return _internal_has_invoice_list();
}
inline const ::payment::v1alpha1::InvoiceList& InvoiceFilterResponse::_internal_invoice_list() const {
  const ::payment::v1alpha1::InvoiceList* p = invoice_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::InvoiceList&>(
      ::payment::v1alpha1::_InvoiceList_default_instance_);
}
inline const ::payment::v1alpha1::InvoiceList& InvoiceFilterResponse::invoice_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterResponse.invoice_list)
  return _internal_invoice_list();
}
inline void InvoiceFilterResponse::unsafe_arena_set_allocated_invoice_list(
    ::payment::v1alpha1::InvoiceList* invoice_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invoice_list_);
  }
  invoice_list_ = invoice_list;
  if (invoice_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.InvoiceFilterResponse.invoice_list)
}
inline ::payment::v1alpha1::InvoiceList* InvoiceFilterResponse::release_invoice_list() {
  
  ::payment::v1alpha1::InvoiceList* temp = invoice_list_;
  invoice_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::InvoiceList* InvoiceFilterResponse::unsafe_arena_release_invoice_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterResponse.invoice_list)
  
  ::payment::v1alpha1::InvoiceList* temp = invoice_list_;
  invoice_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::InvoiceList* InvoiceFilterResponse::_internal_mutable_invoice_list() {
  
  if (invoice_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::InvoiceList>(GetArenaForAllocation());
    invoice_list_ = p;
  }
  return invoice_list_;
}
inline ::payment::v1alpha1::InvoiceList* InvoiceFilterResponse::mutable_invoice_list() {
  ::payment::v1alpha1::InvoiceList* _msg = _internal_mutable_invoice_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterResponse.invoice_list)
  return _msg;
}
inline void InvoiceFilterResponse::set_allocated_invoice_list(::payment::v1alpha1::InvoiceList* invoice_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(invoice_list_);
  }
  if (invoice_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invoice_list));
    if (message_arena != submessage_arena) {
      invoice_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invoice_list, submessage_arena);
    }
    
  } else {
    
  }
  invoice_list_ = invoice_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterResponse.invoice_list)
}

// .payment.v1alpha1.BilingList biling_list = 3 [json_name = "bilingList"];
inline bool InvoiceFilterResponse::_internal_has_biling_list() const {
  return this != internal_default_instance() && biling_list_ != nullptr;
}
inline bool InvoiceFilterResponse::has_biling_list() const {
  return _internal_has_biling_list();
}
inline const ::payment::v1alpha1::BilingList& InvoiceFilterResponse::_internal_biling_list() const {
  const ::payment::v1alpha1::BilingList* p = biling_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::BilingList&>(
      ::payment::v1alpha1::_BilingList_default_instance_);
}
inline const ::payment::v1alpha1::BilingList& InvoiceFilterResponse::biling_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterResponse.biling_list)
  return _internal_biling_list();
}
inline void InvoiceFilterResponse::unsafe_arena_set_allocated_biling_list(
    ::payment::v1alpha1::BilingList* biling_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling_list_);
  }
  biling_list_ = biling_list;
  if (biling_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.InvoiceFilterResponse.biling_list)
}
inline ::payment::v1alpha1::BilingList* InvoiceFilterResponse::release_biling_list() {
  
  ::payment::v1alpha1::BilingList* temp = biling_list_;
  biling_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::BilingList* InvoiceFilterResponse::unsafe_arena_release_biling_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterResponse.biling_list)
  
  ::payment::v1alpha1::BilingList* temp = biling_list_;
  biling_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::BilingList* InvoiceFilterResponse::_internal_mutable_biling_list() {
  
  if (biling_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::BilingList>(GetArenaForAllocation());
    biling_list_ = p;
  }
  return biling_list_;
}
inline ::payment::v1alpha1::BilingList* InvoiceFilterResponse::mutable_biling_list() {
  ::payment::v1alpha1::BilingList* _msg = _internal_mutable_biling_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterResponse.biling_list)
  return _msg;
}
inline void InvoiceFilterResponse::set_allocated_biling_list(::payment::v1alpha1::BilingList* biling_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling_list_);
  }
  if (biling_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling_list));
    if (message_arena != submessage_arena) {
      biling_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, biling_list, submessage_arena);
    }
    
  } else {
    
  }
  biling_list_ = biling_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterResponse.biling_list)
}

// .payment.v1alpha1.SuscriptionList suscription_list = 4 [json_name = "suscriptionList"];
inline bool InvoiceFilterResponse::_internal_has_suscription_list() const {
  return this != internal_default_instance() && suscription_list_ != nullptr;
}
inline bool InvoiceFilterResponse::has_suscription_list() const {
  return _internal_has_suscription_list();
}
inline const ::payment::v1alpha1::SuscriptionList& InvoiceFilterResponse::_internal_suscription_list() const {
  const ::payment::v1alpha1::SuscriptionList* p = suscription_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::SuscriptionList&>(
      ::payment::v1alpha1::_SuscriptionList_default_instance_);
}
inline const ::payment::v1alpha1::SuscriptionList& InvoiceFilterResponse::suscription_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterResponse.suscription_list)
  return _internal_suscription_list();
}
inline void InvoiceFilterResponse::unsafe_arena_set_allocated_suscription_list(
    ::payment::v1alpha1::SuscriptionList* suscription_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_list_);
  }
  suscription_list_ = suscription_list;
  if (suscription_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.InvoiceFilterResponse.suscription_list)
}
inline ::payment::v1alpha1::SuscriptionList* InvoiceFilterResponse::release_suscription_list() {
  
  ::payment::v1alpha1::SuscriptionList* temp = suscription_list_;
  suscription_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::SuscriptionList* InvoiceFilterResponse::unsafe_arena_release_suscription_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterResponse.suscription_list)
  
  ::payment::v1alpha1::SuscriptionList* temp = suscription_list_;
  suscription_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::SuscriptionList* InvoiceFilterResponse::_internal_mutable_suscription_list() {
  
  if (suscription_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::SuscriptionList>(GetArenaForAllocation());
    suscription_list_ = p;
  }
  return suscription_list_;
}
inline ::payment::v1alpha1::SuscriptionList* InvoiceFilterResponse::mutable_suscription_list() {
  ::payment::v1alpha1::SuscriptionList* _msg = _internal_mutable_suscription_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterResponse.suscription_list)
  return _msg;
}
inline void InvoiceFilterResponse::set_allocated_suscription_list(::payment::v1alpha1::SuscriptionList* suscription_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_list_);
  }
  if (suscription_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_list));
    if (message_arena != submessage_arena) {
      suscription_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, suscription_list, submessage_arena);
    }
    
  } else {
    
  }
  suscription_list_ = suscription_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterResponse.suscription_list)
}

// string status = 5 [json_name = "status"];
inline void InvoiceFilterResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& InvoiceFilterResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceFilterResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterResponse.status)
}
inline std::string* InvoiceFilterResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterResponse.status)
  return _s;
}
inline const std::string& InvoiceFilterResponse::_internal_status() const {
  return status_.Get();
}
inline void InvoiceFilterResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvoiceFilterResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvoiceFilterResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvoiceFilterResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterResponse.status)
}

// -------------------------------------------------------------------

// DeleteCustomerRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void DeleteCustomerRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteCustomerRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteCustomerRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteCustomerRequest.organization_id)
  return _internal_organization_id();
}
inline void DeleteCustomerRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void DeleteCustomerRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeleteCustomerRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void DeleteCustomerRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& DeleteCustomerRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteCustomerRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteCustomerRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeleteCustomerRequest.customer_id)
}
inline std::string* DeleteCustomerRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeleteCustomerRequest.customer_id)
  return _s;
}
inline const std::string& DeleteCustomerRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void DeleteCustomerRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteCustomerRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteCustomerRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeleteCustomerRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteCustomerRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeleteCustomerRequest.customer_id)
}

// -------------------------------------------------------------------

// DeleteCustomerResponse

// string status = 1 [json_name = "status"];
inline void DeleteCustomerResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& DeleteCustomerResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteCustomerResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteCustomerResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeleteCustomerResponse.status)
}
inline std::string* DeleteCustomerResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeleteCustomerResponse.status)
  return _s;
}
inline const std::string& DeleteCustomerResponse::_internal_status() const {
  return status_.Get();
}
inline void DeleteCustomerResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteCustomerResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteCustomerResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeleteCustomerResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteCustomerResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeleteCustomerResponse.status)
}

// -------------------------------------------------------------------

// GetSuscriptionRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void GetSuscriptionRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetSuscriptionRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetSuscriptionRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetSuscriptionRequest.organization_id)
  return _internal_organization_id();
}
inline void GetSuscriptionRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void GetSuscriptionRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetSuscriptionRequest.organization_id)
}

// string suscription_id = 2 [json_name = "suscriptionId"];
inline void GetSuscriptionRequest::clear_suscription_id() {
  suscription_id_.ClearToEmpty();
}
inline const std::string& GetSuscriptionRequest::suscription_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetSuscriptionRequest.suscription_id)
  return _internal_suscription_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSuscriptionRequest::set_suscription_id(ArgT0&& arg0, ArgT... args) {
 
 suscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetSuscriptionRequest.suscription_id)
}
inline std::string* GetSuscriptionRequest::mutable_suscription_id() {
  std::string* _s = _internal_mutable_suscription_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetSuscriptionRequest.suscription_id)
  return _s;
}
inline const std::string& GetSuscriptionRequest::_internal_suscription_id() const {
  return suscription_id_.Get();
}
inline void GetSuscriptionRequest::_internal_set_suscription_id(const std::string& value) {
  
  suscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetSuscriptionRequest::_internal_mutable_suscription_id() {
  
  return suscription_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetSuscriptionRequest::release_suscription_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetSuscriptionRequest.suscription_id)
  return suscription_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetSuscriptionRequest::set_allocated_suscription_id(std::string* suscription_id) {
  if (suscription_id != nullptr) {
    
  } else {
    
  }
  suscription_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), suscription_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetSuscriptionRequest.suscription_id)
}

// -------------------------------------------------------------------

// GetSuscriptionResponse

// .payment.v1alpha1.Suscription suscription = 1 [json_name = "suscription"];
inline bool GetSuscriptionResponse::_internal_has_suscription() const {
  return this != internal_default_instance() && suscription_ != nullptr;
}
inline bool GetSuscriptionResponse::has_suscription() const {
  return _internal_has_suscription();
}
inline const ::payment::v1alpha1::Suscription& GetSuscriptionResponse::_internal_suscription() const {
  const ::payment::v1alpha1::Suscription* p = suscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Suscription&>(
      ::payment::v1alpha1::_Suscription_default_instance_);
}
inline const ::payment::v1alpha1::Suscription& GetSuscriptionResponse::suscription() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetSuscriptionResponse.suscription)
  return _internal_suscription();
}
inline void GetSuscriptionResponse::unsafe_arena_set_allocated_suscription(
    ::payment::v1alpha1::Suscription* suscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_);
  }
  suscription_ = suscription;
  if (suscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetSuscriptionResponse.suscription)
}
inline ::payment::v1alpha1::Suscription* GetSuscriptionResponse::release_suscription() {
  
  ::payment::v1alpha1::Suscription* temp = suscription_;
  suscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Suscription* GetSuscriptionResponse::unsafe_arena_release_suscription() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetSuscriptionResponse.suscription)
  
  ::payment::v1alpha1::Suscription* temp = suscription_;
  suscription_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Suscription* GetSuscriptionResponse::_internal_mutable_suscription() {
  
  if (suscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Suscription>(GetArenaForAllocation());
    suscription_ = p;
  }
  return suscription_;
}
inline ::payment::v1alpha1::Suscription* GetSuscriptionResponse::mutable_suscription() {
  ::payment::v1alpha1::Suscription* _msg = _internal_mutable_suscription();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetSuscriptionResponse.suscription)
  return _msg;
}
inline void GetSuscriptionResponse::set_allocated_suscription(::payment::v1alpha1::Suscription* suscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_);
  }
  if (suscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription));
    if (message_arena != submessage_arena) {
      suscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, suscription, submessage_arena);
    }
    
  } else {
    
  }
  suscription_ = suscription;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetSuscriptionResponse.suscription)
}

// string status = 2 [json_name = "status"];
inline void GetSuscriptionResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetSuscriptionResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetSuscriptionResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSuscriptionResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetSuscriptionResponse.status)
}
inline std::string* GetSuscriptionResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetSuscriptionResponse.status)
  return _s;
}
inline const std::string& GetSuscriptionResponse::_internal_status() const {
  return status_.Get();
}
inline void GetSuscriptionResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetSuscriptionResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetSuscriptionResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetSuscriptionResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetSuscriptionResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetSuscriptionResponse.status)
}

// -------------------------------------------------------------------

// GetOrganizationRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void GetOrganizationRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOrganizationRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOrganizationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetOrganizationRequest.organization_id)
  return _internal_organization_id();
}
inline void GetOrganizationRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void GetOrganizationRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetOrganizationRequest.organization_id)
}

// -------------------------------------------------------------------

// GetOrganizationResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool GetOrganizationResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool GetOrganizationResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& GetOrganizationResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& GetOrganizationResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetOrganizationResponse.customer)
  return _internal_customer();
}
inline void GetOrganizationResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetOrganizationResponse.customer)
}
inline ::payment::v1alpha1::Customer* GetOrganizationResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* GetOrganizationResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetOrganizationResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* GetOrganizationResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* GetOrganizationResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetOrganizationResponse.customer)
  return _msg;
}
inline void GetOrganizationResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetOrganizationResponse.customer)
}

// string status = 2 [json_name = "status"];
inline void GetOrganizationResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetOrganizationResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetOrganizationResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOrganizationResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetOrganizationResponse.status)
}
inline std::string* GetOrganizationResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetOrganizationResponse.status)
  return _s;
}
inline const std::string& GetOrganizationResponse::_internal_status() const {
  return status_.Get();
}
inline void GetOrganizationResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOrganizationResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOrganizationResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetOrganizationResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOrganizationResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetOrganizationResponse.status)
}

// -------------------------------------------------------------------

// GetCustomerRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void GetCustomerRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetCustomerRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetCustomerRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetCustomerRequest.organization_id)
  return _internal_organization_id();
}
inline void GetCustomerRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void GetCustomerRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetCustomerRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void GetCustomerRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& GetCustomerRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetCustomerRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCustomerRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetCustomerRequest.customer_id)
}
inline std::string* GetCustomerRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetCustomerRequest.customer_id)
  return _s;
}
inline const std::string& GetCustomerRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void GetCustomerRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetCustomerRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetCustomerRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetCustomerRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetCustomerRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetCustomerRequest.customer_id)
}

// -------------------------------------------------------------------

// GetCustomerResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool GetCustomerResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool GetCustomerResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& GetCustomerResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& GetCustomerResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetCustomerResponse.customer)
  return _internal_customer();
}
inline void GetCustomerResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetCustomerResponse.customer)
}
inline ::payment::v1alpha1::Customer* GetCustomerResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* GetCustomerResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetCustomerResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* GetCustomerResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* GetCustomerResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetCustomerResponse.customer)
  return _msg;
}
inline void GetCustomerResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetCustomerResponse.customer)
}

// string status = 2 [json_name = "status"];
inline void GetCustomerResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetCustomerResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetCustomerResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCustomerResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetCustomerResponse.status)
}
inline std::string* GetCustomerResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetCustomerResponse.status)
  return _s;
}
inline const std::string& GetCustomerResponse::_internal_status() const {
  return status_.Get();
}
inline void GetCustomerResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetCustomerResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetCustomerResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetCustomerResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetCustomerResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetCustomerResponse.status)
}

// -------------------------------------------------------------------

// GetBilingMonthRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void GetBilingMonthRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetBilingMonthRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetBilingMonthRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetBilingMonthRequest.organization_id)
  return _internal_organization_id();
}
inline void GetBilingMonthRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void GetBilingMonthRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetBilingMonthRequest.organization_id)
}

// string invoice_id = 2 [json_name = "invoiceId"];
inline void GetBilingMonthRequest::clear_invoice_id() {
  invoice_id_.ClearToEmpty();
}
inline const std::string& GetBilingMonthRequest::invoice_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetBilingMonthRequest.invoice_id)
  return _internal_invoice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBilingMonthRequest::set_invoice_id(ArgT0&& arg0, ArgT... args) {
 
 invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetBilingMonthRequest.invoice_id)
}
inline std::string* GetBilingMonthRequest::mutable_invoice_id() {
  std::string* _s = _internal_mutable_invoice_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetBilingMonthRequest.invoice_id)
  return _s;
}
inline const std::string& GetBilingMonthRequest::_internal_invoice_id() const {
  return invoice_id_.Get();
}
inline void GetBilingMonthRequest::_internal_set_invoice_id(const std::string& value) {
  
  invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBilingMonthRequest::_internal_mutable_invoice_id() {
  
  return invoice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBilingMonthRequest::release_invoice_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetBilingMonthRequest.invoice_id)
  return invoice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetBilingMonthRequest::set_allocated_invoice_id(std::string* invoice_id) {
  if (invoice_id != nullptr) {
    
  } else {
    
  }
  invoice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invoice_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetBilingMonthRequest.invoice_id)
}

// -------------------------------------------------------------------

// GetBilingMonthResponse

// .payment.v1alpha1.Biling biling = 1 [json_name = "biling"];
inline bool GetBilingMonthResponse::_internal_has_biling() const {
  return this != internal_default_instance() && biling_ != nullptr;
}
inline bool GetBilingMonthResponse::has_biling() const {
  return _internal_has_biling();
}
inline const ::payment::v1alpha1::Biling& GetBilingMonthResponse::_internal_biling() const {
  const ::payment::v1alpha1::Biling* p = biling_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Biling&>(
      ::payment::v1alpha1::_Biling_default_instance_);
}
inline const ::payment::v1alpha1::Biling& GetBilingMonthResponse::biling() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetBilingMonthResponse.biling)
  return _internal_biling();
}
inline void GetBilingMonthResponse::unsafe_arena_set_allocated_biling(
    ::payment::v1alpha1::Biling* biling) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling_);
  }
  biling_ = biling;
  if (biling) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetBilingMonthResponse.biling)
}
inline ::payment::v1alpha1::Biling* GetBilingMonthResponse::release_biling() {
  
  ::payment::v1alpha1::Biling* temp = biling_;
  biling_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Biling* GetBilingMonthResponse::unsafe_arena_release_biling() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetBilingMonthResponse.biling)
  
  ::payment::v1alpha1::Biling* temp = biling_;
  biling_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Biling* GetBilingMonthResponse::_internal_mutable_biling() {
  
  if (biling_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Biling>(GetArenaForAllocation());
    biling_ = p;
  }
  return biling_;
}
inline ::payment::v1alpha1::Biling* GetBilingMonthResponse::mutable_biling() {
  ::payment::v1alpha1::Biling* _msg = _internal_mutable_biling();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetBilingMonthResponse.biling)
  return _msg;
}
inline void GetBilingMonthResponse::set_allocated_biling(::payment::v1alpha1::Biling* biling) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling_);
  }
  if (biling) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling));
    if (message_arena != submessage_arena) {
      biling = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, biling, submessage_arena);
    }
    
  } else {
    
  }
  biling_ = biling;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetBilingMonthResponse.biling)
}

// string status = 2 [json_name = "status"];
inline void GetBilingMonthResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetBilingMonthResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetBilingMonthResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBilingMonthResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetBilingMonthResponse.status)
}
inline std::string* GetBilingMonthResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetBilingMonthResponse.status)
  return _s;
}
inline const std::string& GetBilingMonthResponse::_internal_status() const {
  return status_.Get();
}
inline void GetBilingMonthResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBilingMonthResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBilingMonthResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetBilingMonthResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetBilingMonthResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetBilingMonthResponse.status)
}

// -------------------------------------------------------------------

// GetPaymentsRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void GetPaymentsRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetPaymentsRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetPaymentsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentsRequest.organization_id)
  return _internal_organization_id();
}
inline void GetPaymentsRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void GetPaymentsRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentsRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void GetPaymentsRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& GetPaymentsRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentsRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentsRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentsRequest.customer_id)
}
inline std::string* GetPaymentsRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentsRequest.customer_id)
  return _s;
}
inline const std::string& GetPaymentsRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void GetPaymentsRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentsRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentsRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentsRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentsRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentsRequest.customer_id)
}

// -------------------------------------------------------------------

// GetPaymentsResponse

// .payment.v1alpha1.PaymentList payment = 1 [json_name = "payment"];
inline bool GetPaymentsResponse::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool GetPaymentsResponse::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::PaymentList& GetPaymentsResponse::_internal_payment() const {
  const ::payment::v1alpha1::PaymentList* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::PaymentList&>(
      ::payment::v1alpha1::_PaymentList_default_instance_);
}
inline const ::payment::v1alpha1::PaymentList& GetPaymentsResponse::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentsResponse.payment)
  return _internal_payment();
}
inline void GetPaymentsResponse::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::PaymentList* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetPaymentsResponse.payment)
}
inline ::payment::v1alpha1::PaymentList* GetPaymentsResponse::release_payment() {
  
  ::payment::v1alpha1::PaymentList* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::PaymentList* GetPaymentsResponse::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentsResponse.payment)
  
  ::payment::v1alpha1::PaymentList* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::PaymentList* GetPaymentsResponse::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::PaymentList>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::PaymentList* GetPaymentsResponse::mutable_payment() {
  ::payment::v1alpha1::PaymentList* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentsResponse.payment)
  return _msg;
}
inline void GetPaymentsResponse::set_allocated_payment(::payment::v1alpha1::PaymentList* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentsResponse.payment)
}

// string status = 2 [json_name = "status"];
inline void GetPaymentsResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetPaymentsResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentsResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentsResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentsResponse.status)
}
inline std::string* GetPaymentsResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentsResponse.status)
  return _s;
}
inline const std::string& GetPaymentsResponse::_internal_status() const {
  return status_.Get();
}
inline void GetPaymentsResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentsResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentsResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentsResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentsResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentsResponse.status)
}

// -------------------------------------------------------------------

// CreateSuscriptionRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void CreateSuscriptionRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateSuscriptionRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateSuscriptionRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateSuscriptionRequest.organization_id)
  return _internal_organization_id();
}
inline void CreateSuscriptionRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CreateSuscriptionRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateSuscriptionRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void CreateSuscriptionRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& CreateSuscriptionRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateSuscriptionRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSuscriptionRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateSuscriptionRequest.customer_id)
}
inline std::string* CreateSuscriptionRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateSuscriptionRequest.customer_id)
  return _s;
}
inline const std::string& CreateSuscriptionRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void CreateSuscriptionRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSuscriptionRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSuscriptionRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateSuscriptionRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSuscriptionRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateSuscriptionRequest.customer_id)
}

// .payment.v1alpha1.Suscription suscription = 3 [json_name = "suscription"];
inline bool CreateSuscriptionRequest::_internal_has_suscription() const {
  return this != internal_default_instance() && suscription_ != nullptr;
}
inline bool CreateSuscriptionRequest::has_suscription() const {
  return _internal_has_suscription();
}
inline const ::payment::v1alpha1::Suscription& CreateSuscriptionRequest::_internal_suscription() const {
  const ::payment::v1alpha1::Suscription* p = suscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Suscription&>(
      ::payment::v1alpha1::_Suscription_default_instance_);
}
inline const ::payment::v1alpha1::Suscription& CreateSuscriptionRequest::suscription() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateSuscriptionRequest.suscription)
  return _internal_suscription();
}
inline void CreateSuscriptionRequest::unsafe_arena_set_allocated_suscription(
    ::payment::v1alpha1::Suscription* suscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_);
  }
  suscription_ = suscription;
  if (suscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateSuscriptionRequest.suscription)
}
inline ::payment::v1alpha1::Suscription* CreateSuscriptionRequest::release_suscription() {
  
  ::payment::v1alpha1::Suscription* temp = suscription_;
  suscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Suscription* CreateSuscriptionRequest::unsafe_arena_release_suscription() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateSuscriptionRequest.suscription)
  
  ::payment::v1alpha1::Suscription* temp = suscription_;
  suscription_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Suscription* CreateSuscriptionRequest::_internal_mutable_suscription() {
  
  if (suscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Suscription>(GetArenaForAllocation());
    suscription_ = p;
  }
  return suscription_;
}
inline ::payment::v1alpha1::Suscription* CreateSuscriptionRequest::mutable_suscription() {
  ::payment::v1alpha1::Suscription* _msg = _internal_mutable_suscription();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateSuscriptionRequest.suscription)
  return _msg;
}
inline void CreateSuscriptionRequest::set_allocated_suscription(::payment::v1alpha1::Suscription* suscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_);
  }
  if (suscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription));
    if (message_arena != submessage_arena) {
      suscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, suscription, submessage_arena);
    }
    
  } else {
    
  }
  suscription_ = suscription;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateSuscriptionRequest.suscription)
}

// -------------------------------------------------------------------

// CreateSuscriptionResponse

// .payment.v1alpha1.Suscription suscription = 1 [json_name = "suscription"];
inline bool CreateSuscriptionResponse::_internal_has_suscription() const {
  return this != internal_default_instance() && suscription_ != nullptr;
}
inline bool CreateSuscriptionResponse::has_suscription() const {
  return _internal_has_suscription();
}
inline const ::payment::v1alpha1::Suscription& CreateSuscriptionResponse::_internal_suscription() const {
  const ::payment::v1alpha1::Suscription* p = suscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Suscription&>(
      ::payment::v1alpha1::_Suscription_default_instance_);
}
inline const ::payment::v1alpha1::Suscription& CreateSuscriptionResponse::suscription() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateSuscriptionResponse.suscription)
  return _internal_suscription();
}
inline void CreateSuscriptionResponse::unsafe_arena_set_allocated_suscription(
    ::payment::v1alpha1::Suscription* suscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_);
  }
  suscription_ = suscription;
  if (suscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateSuscriptionResponse.suscription)
}
inline ::payment::v1alpha1::Suscription* CreateSuscriptionResponse::release_suscription() {
  
  ::payment::v1alpha1::Suscription* temp = suscription_;
  suscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Suscription* CreateSuscriptionResponse::unsafe_arena_release_suscription() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateSuscriptionResponse.suscription)
  
  ::payment::v1alpha1::Suscription* temp = suscription_;
  suscription_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Suscription* CreateSuscriptionResponse::_internal_mutable_suscription() {
  
  if (suscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Suscription>(GetArenaForAllocation());
    suscription_ = p;
  }
  return suscription_;
}
inline ::payment::v1alpha1::Suscription* CreateSuscriptionResponse::mutable_suscription() {
  ::payment::v1alpha1::Suscription* _msg = _internal_mutable_suscription();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateSuscriptionResponse.suscription)
  return _msg;
}
inline void CreateSuscriptionResponse::set_allocated_suscription(::payment::v1alpha1::Suscription* suscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_);
  }
  if (suscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription));
    if (message_arena != submessage_arena) {
      suscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, suscription, submessage_arena);
    }
    
  } else {
    
  }
  suscription_ = suscription;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateSuscriptionResponse.suscription)
}

// string status = 2 [json_name = "status"];
inline void CreateSuscriptionResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateSuscriptionResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateSuscriptionResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSuscriptionResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateSuscriptionResponse.status)
}
inline std::string* CreateSuscriptionResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateSuscriptionResponse.status)
  return _s;
}
inline const std::string& CreateSuscriptionResponse::_internal_status() const {
  return status_.Get();
}
inline void CreateSuscriptionResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSuscriptionResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSuscriptionResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateSuscriptionResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSuscriptionResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateSuscriptionResponse.status)
}

// -------------------------------------------------------------------

// CreateProjectRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void CreateProjectRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateProjectRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateProjectRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateProjectRequest.organization_id)
  return _internal_organization_id();
}
inline void CreateProjectRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CreateProjectRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateProjectRequest.organization_id)
}

// .payment.v1alpha1.ProjectList project_list = 2 [json_name = "projectList"];
inline bool CreateProjectRequest::_internal_has_project_list() const {
  return this != internal_default_instance() && project_list_ != nullptr;
}
inline bool CreateProjectRequest::has_project_list() const {
  return _internal_has_project_list();
}
inline const ::payment::v1alpha1::ProjectList& CreateProjectRequest::_internal_project_list() const {
  const ::payment::v1alpha1::ProjectList* p = project_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::ProjectList&>(
      ::payment::v1alpha1::_ProjectList_default_instance_);
}
inline const ::payment::v1alpha1::ProjectList& CreateProjectRequest::project_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateProjectRequest.project_list)
  return _internal_project_list();
}
inline void CreateProjectRequest::unsafe_arena_set_allocated_project_list(
    ::payment::v1alpha1::ProjectList* project_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_list_);
  }
  project_list_ = project_list;
  if (project_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateProjectRequest.project_list)
}
inline ::payment::v1alpha1::ProjectList* CreateProjectRequest::release_project_list() {
  
  ::payment::v1alpha1::ProjectList* temp = project_list_;
  project_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::ProjectList* CreateProjectRequest::unsafe_arena_release_project_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateProjectRequest.project_list)
  
  ::payment::v1alpha1::ProjectList* temp = project_list_;
  project_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::ProjectList* CreateProjectRequest::_internal_mutable_project_list() {
  
  if (project_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::ProjectList>(GetArenaForAllocation());
    project_list_ = p;
  }
  return project_list_;
}
inline ::payment::v1alpha1::ProjectList* CreateProjectRequest::mutable_project_list() {
  ::payment::v1alpha1::ProjectList* _msg = _internal_mutable_project_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateProjectRequest.project_list)
  return _msg;
}
inline void CreateProjectRequest::set_allocated_project_list(::payment::v1alpha1::ProjectList* project_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_list_);
  }
  if (project_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_list));
    if (message_arena != submessage_arena) {
      project_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, project_list, submessage_arena);
    }
    
  } else {
    
  }
  project_list_ = project_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateProjectRequest.project_list)
}

// -------------------------------------------------------------------

// CreateProjectResponse

// string status = 1 [json_name = "status"];
inline void CreateProjectResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateProjectResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateProjectResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateProjectResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateProjectResponse.status)
}
inline std::string* CreateProjectResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateProjectResponse.status)
  return _s;
}
inline const std::string& CreateProjectResponse::_internal_status() const {
  return status_.Get();
}
inline void CreateProjectResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateProjectResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateProjectResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateProjectResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateProjectResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateProjectResponse.status)
}

// -------------------------------------------------------------------

// CreateInvoiceRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void CreateInvoiceRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateInvoiceRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateInvoiceRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceRequest.organization_id)
  return _internal_organization_id();
}
inline void CreateInvoiceRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CreateInvoiceRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateInvoiceRequest.organization_id)
}

// string invoice_id = 2 [json_name = "invoiceId"];
inline void CreateInvoiceRequest::clear_invoice_id() {
  invoice_id_.ClearToEmpty();
}
inline const std::string& CreateInvoiceRequest::invoice_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceRequest.invoice_id)
  return _internal_invoice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInvoiceRequest::set_invoice_id(ArgT0&& arg0, ArgT... args) {
 
 invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateInvoiceRequest.invoice_id)
}
inline std::string* CreateInvoiceRequest::mutable_invoice_id() {
  std::string* _s = _internal_mutable_invoice_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceRequest.invoice_id)
  return _s;
}
inline const std::string& CreateInvoiceRequest::_internal_invoice_id() const {
  return invoice_id_.Get();
}
inline void CreateInvoiceRequest::_internal_set_invoice_id(const std::string& value) {
  
  invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::_internal_mutable_invoice_id() {
  
  return invoice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::release_invoice_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceRequest.invoice_id)
  return invoice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateInvoiceRequest::set_allocated_invoice_id(std::string* invoice_id) {
  if (invoice_id != nullptr) {
    
  } else {
    
  }
  invoice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invoice_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceRequest.invoice_id)
}

// string status = 3 [json_name = "status"];
inline void CreateInvoiceRequest::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateInvoiceRequest::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceRequest.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInvoiceRequest::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateInvoiceRequest.status)
}
inline std::string* CreateInvoiceRequest::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceRequest.status)
  return _s;
}
inline const std::string& CreateInvoiceRequest::_internal_status() const {
  return status_.Get();
}
inline void CreateInvoiceRequest::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceRequest.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateInvoiceRequest::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceRequest.status)
}

// -------------------------------------------------------------------

// CreateInvoiceResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool CreateInvoiceResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool CreateInvoiceResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& CreateInvoiceResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& CreateInvoiceResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceResponse.customer)
  return _internal_customer();
}
inline void CreateInvoiceResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateInvoiceResponse.customer)
}
inline ::payment::v1alpha1::Customer* CreateInvoiceResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* CreateInvoiceResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* CreateInvoiceResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* CreateInvoiceResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceResponse.customer)
  return _msg;
}
inline void CreateInvoiceResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceResponse.customer)
}

// string status = 2 [json_name = "status"];
inline void CreateInvoiceResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateInvoiceResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInvoiceResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateInvoiceResponse.status)
}
inline std::string* CreateInvoiceResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceResponse.status)
  return _s;
}
inline const std::string& CreateInvoiceResponse::_internal_status() const {
  return status_.Get();
}
inline void CreateInvoiceResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateInvoiceResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateInvoiceResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateInvoiceResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceResponse.status)
}

// -------------------------------------------------------------------

// CreateCardRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void CreateCardRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateCardRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateCardRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCardRequest.organization_id)
  return _internal_organization_id();
}
inline void CreateCardRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CreateCardRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCardRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void CreateCardRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& CreateCardRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCardRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCardRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCardRequest.customer_id)
}
inline std::string* CreateCardRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCardRequest.customer_id)
  return _s;
}
inline const std::string& CreateCardRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void CreateCardRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCardRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCardRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCardRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCardRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCardRequest.customer_id)
}

// .payment.v1alpha1.Card card = 3 [json_name = "card"];
inline bool CreateCardRequest::_internal_has_card() const {
  return this != internal_default_instance() && card_ != nullptr;
}
inline bool CreateCardRequest::has_card() const {
  return _internal_has_card();
}
inline const ::payment::v1alpha1::Card& CreateCardRequest::_internal_card() const {
  const ::payment::v1alpha1::Card* p = card_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Card&>(
      ::payment::v1alpha1::_Card_default_instance_);
}
inline const ::payment::v1alpha1::Card& CreateCardRequest::card() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCardRequest.card)
  return _internal_card();
}
inline void CreateCardRequest::unsafe_arena_set_allocated_card(
    ::payment::v1alpha1::Card* card) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(card_);
  }
  card_ = card;
  if (card) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateCardRequest.card)
}
inline ::payment::v1alpha1::Card* CreateCardRequest::release_card() {
  
  ::payment::v1alpha1::Card* temp = card_;
  card_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Card* CreateCardRequest::unsafe_arena_release_card() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCardRequest.card)
  
  ::payment::v1alpha1::Card* temp = card_;
  card_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Card* CreateCardRequest::_internal_mutable_card() {
  
  if (card_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Card>(GetArenaForAllocation());
    card_ = p;
  }
  return card_;
}
inline ::payment::v1alpha1::Card* CreateCardRequest::mutable_card() {
  ::payment::v1alpha1::Card* _msg = _internal_mutable_card();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCardRequest.card)
  return _msg;
}
inline void CreateCardRequest::set_allocated_card(::payment::v1alpha1::Card* card) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(card_);
  }
  if (card) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(card));
    if (message_arena != submessage_arena) {
      card = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, card, submessage_arena);
    }
    
  } else {
    
  }
  card_ = card;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCardRequest.card)
}

// -------------------------------------------------------------------

// CreateCardResponse

// string token_id = 1 [json_name = "tokenId"];
inline void CreateCardResponse::clear_token_id() {
  token_id_.ClearToEmpty();
}
inline const std::string& CreateCardResponse::token_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCardResponse.token_id)
  return _internal_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCardResponse::set_token_id(ArgT0&& arg0, ArgT... args) {
 
 token_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCardResponse.token_id)
}
inline std::string* CreateCardResponse::mutable_token_id() {
  std::string* _s = _internal_mutable_token_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCardResponse.token_id)
  return _s;
}
inline const std::string& CreateCardResponse::_internal_token_id() const {
  return token_id_.Get();
}
inline void CreateCardResponse::_internal_set_token_id(const std::string& value) {
  
  token_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCardResponse::_internal_mutable_token_id() {
  
  return token_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCardResponse::release_token_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCardResponse.token_id)
  return token_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCardResponse::set_allocated_token_id(std::string* token_id) {
  if (token_id != nullptr) {
    
  } else {
    
  }
  token_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCardResponse.token_id)
}

// string status = 2 [json_name = "status"];
inline void CreateCardResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateCardResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCardResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCardResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCardResponse.status)
}
inline std::string* CreateCardResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCardResponse.status)
  return _s;
}
inline const std::string& CreateCardResponse::_internal_status() const {
  return status_.Get();
}
inline void CreateCardResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCardResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCardResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCardResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCardResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCardResponse.status)
}

// -------------------------------------------------------------------

// CancelSuscriptionRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void CancelSuscriptionRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CancelSuscriptionRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CancelSuscriptionRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CancelSuscriptionRequest.organization_id)
  return _internal_organization_id();
}
inline void CancelSuscriptionRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CancelSuscriptionRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CancelSuscriptionRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void CancelSuscriptionRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& CancelSuscriptionRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CancelSuscriptionRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelSuscriptionRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CancelSuscriptionRequest.customer_id)
}
inline std::string* CancelSuscriptionRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CancelSuscriptionRequest.customer_id)
  return _s;
}
inline const std::string& CancelSuscriptionRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void CancelSuscriptionRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelSuscriptionRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelSuscriptionRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CancelSuscriptionRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelSuscriptionRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CancelSuscriptionRequest.customer_id)
}

// string suscription_id = 3 [json_name = "suscriptionId"];
inline void CancelSuscriptionRequest::clear_suscription_id() {
  suscription_id_.ClearToEmpty();
}
inline const std::string& CancelSuscriptionRequest::suscription_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CancelSuscriptionRequest.suscription_id)
  return _internal_suscription_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelSuscriptionRequest::set_suscription_id(ArgT0&& arg0, ArgT... args) {
 
 suscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CancelSuscriptionRequest.suscription_id)
}
inline std::string* CancelSuscriptionRequest::mutable_suscription_id() {
  std::string* _s = _internal_mutable_suscription_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CancelSuscriptionRequest.suscription_id)
  return _s;
}
inline const std::string& CancelSuscriptionRequest::_internal_suscription_id() const {
  return suscription_id_.Get();
}
inline void CancelSuscriptionRequest::_internal_set_suscription_id(const std::string& value) {
  
  suscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelSuscriptionRequest::_internal_mutable_suscription_id() {
  
  return suscription_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelSuscriptionRequest::release_suscription_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CancelSuscriptionRequest.suscription_id)
  return suscription_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelSuscriptionRequest::set_allocated_suscription_id(std::string* suscription_id) {
  if (suscription_id != nullptr) {
    
  } else {
    
  }
  suscription_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), suscription_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CancelSuscriptionRequest.suscription_id)
}

// -------------------------------------------------------------------

// CancelSuscriptionResponse

// string status = 1 [json_name = "status"];
inline void CancelSuscriptionResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CancelSuscriptionResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CancelSuscriptionResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelSuscriptionResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CancelSuscriptionResponse.status)
}
inline std::string* CancelSuscriptionResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CancelSuscriptionResponse.status)
  return _s;
}
inline const std::string& CancelSuscriptionResponse::_internal_status() const {
  return status_.Get();
}
inline void CancelSuscriptionResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelSuscriptionResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelSuscriptionResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CancelSuscriptionResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelSuscriptionResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CancelSuscriptionResponse.status)
}

// -------------------------------------------------------------------

// CreateCustomerRequest

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool CreateCustomerRequest::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool CreateCustomerRequest::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& CreateCustomerRequest::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& CreateCustomerRequest::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCustomerRequest.customer)
  return _internal_customer();
}
inline void CreateCustomerRequest::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateCustomerRequest.customer)
}
inline ::payment::v1alpha1::Customer* CreateCustomerRequest::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* CreateCustomerRequest::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCustomerRequest.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* CreateCustomerRequest::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* CreateCustomerRequest::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCustomerRequest.customer)
  return _msg;
}
inline void CreateCustomerRequest::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCustomerRequest.customer)
}

// -------------------------------------------------------------------

// CreateCustomerResponse

// string customer_id = 1 [json_name = "customerId"];
inline void CreateCustomerResponse::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& CreateCustomerResponse::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCustomerResponse.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCustomerResponse::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCustomerResponse.customer_id)
}
inline std::string* CreateCustomerResponse::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCustomerResponse.customer_id)
  return _s;
}
inline const std::string& CreateCustomerResponse::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void CreateCustomerResponse::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCustomerResponse::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCustomerResponse::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCustomerResponse.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCustomerResponse::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCustomerResponse.customer_id)
}

// string status = 2 [json_name = "status"];
inline void CreateCustomerResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateCustomerResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCustomerResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCustomerResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCustomerResponse.status)
}
inline std::string* CreateCustomerResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCustomerResponse.status)
  return _s;
}
inline const std::string& CreateCustomerResponse::_internal_status() const {
  return status_.Get();
}
inline void CreateCustomerResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCustomerResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCustomerResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCustomerResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCustomerResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCustomerResponse.status)
}

// -------------------------------------------------------------------

// CreatePaymentRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void CreatePaymentRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreatePaymentRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreatePaymentRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentRequest.organization_id)
  return _internal_organization_id();
}
inline void CreatePaymentRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CreatePaymentRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreatePaymentRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void CreatePaymentRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& CreatePaymentRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePaymentRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreatePaymentRequest.customer_id)
}
inline std::string* CreatePaymentRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentRequest.customer_id)
  return _s;
}
inline const std::string& CreatePaymentRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void CreatePaymentRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePaymentRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePaymentRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePaymentRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentRequest.customer_id)
}

// .payment.v1alpha1.Payment payment = 3 [json_name = "payment"];
inline bool CreatePaymentRequest::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool CreatePaymentRequest::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::Payment& CreatePaymentRequest::_internal_payment() const {
  const ::payment::v1alpha1::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Payment&>(
      ::payment::v1alpha1::_Payment_default_instance_);
}
inline const ::payment::v1alpha1::Payment& CreatePaymentRequest::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentRequest.payment)
  return _internal_payment();
}
inline void CreatePaymentRequest::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreatePaymentRequest.payment)
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::release_payment() {
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentRequest.payment)
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::mutable_payment() {
  ::payment::v1alpha1::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentRequest.payment)
  return _msg;
}
inline void CreatePaymentRequest::set_allocated_payment(::payment::v1alpha1::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentRequest.payment)
}

// -------------------------------------------------------------------

// CreatePaymentResponse

// string card_id = 1 [json_name = "cardId"];
inline void CreatePaymentResponse::clear_card_id() {
  card_id_.ClearToEmpty();
}
inline const std::string& CreatePaymentResponse::card_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentResponse.card_id)
  return _internal_card_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePaymentResponse::set_card_id(ArgT0&& arg0, ArgT... args) {
 
 card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreatePaymentResponse.card_id)
}
inline std::string* CreatePaymentResponse::mutable_card_id() {
  std::string* _s = _internal_mutable_card_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentResponse.card_id)
  return _s;
}
inline const std::string& CreatePaymentResponse::_internal_card_id() const {
  return card_id_.Get();
}
inline void CreatePaymentResponse::_internal_set_card_id(const std::string& value) {
  
  card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePaymentResponse::_internal_mutable_card_id() {
  
  return card_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePaymentResponse::release_card_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentResponse.card_id)
  return card_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePaymentResponse::set_allocated_card_id(std::string* card_id) {
  if (card_id != nullptr) {
    
  } else {
    
  }
  card_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentResponse.card_id)
}

// string status = 2 [json_name = "status"];
inline void CreatePaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreatePaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreatePaymentResponse.status)
}
inline std::string* CreatePaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentResponse.status)
  return _s;
}
inline const std::string& CreatePaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void CreatePaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentResponse.status)
}

// -------------------------------------------------------------------

// DeletePaymentRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void DeletePaymentRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeletePaymentRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeletePaymentRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentRequest.organization_id)
  return _internal_organization_id();
}
inline void DeletePaymentRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void DeletePaymentRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void DeletePaymentRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& DeletePaymentRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePaymentRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentRequest.customer_id)
}
inline std::string* DeletePaymentRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeletePaymentRequest.customer_id)
  return _s;
}
inline const std::string& DeletePaymentRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void DeletePaymentRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeletePaymentRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePaymentRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeletePaymentRequest.customer_id)
}

// string card_id = 3 [json_name = "cardId"];
inline void DeletePaymentRequest::clear_card_id() {
  card_id_.ClearToEmpty();
}
inline const std::string& DeletePaymentRequest::card_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentRequest.card_id)
  return _internal_card_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePaymentRequest::set_card_id(ArgT0&& arg0, ArgT... args) {
 
 card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentRequest.card_id)
}
inline std::string* DeletePaymentRequest::mutable_card_id() {
  std::string* _s = _internal_mutable_card_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeletePaymentRequest.card_id)
  return _s;
}
inline const std::string& DeletePaymentRequest::_internal_card_id() const {
  return card_id_.Get();
}
inline void DeletePaymentRequest::_internal_set_card_id(const std::string& value) {
  
  card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::_internal_mutable_card_id() {
  
  return card_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::release_card_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeletePaymentRequest.card_id)
  return card_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePaymentRequest::set_allocated_card_id(std::string* card_id) {
  if (card_id != nullptr) {
    
  } else {
    
  }
  card_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeletePaymentRequest.card_id)
}

// -------------------------------------------------------------------

// DeletePaymentResponse

// string status = 1 [json_name = "status"];
inline void DeletePaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& DeletePaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentResponse.status)
}
inline std::string* DeletePaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeletePaymentResponse.status)
  return _s;
}
inline const std::string& DeletePaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void DeletePaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeletePaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeletePaymentResponse.status)
}

// -------------------------------------------------------------------

// GetPaymentRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void GetPaymentRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetPaymentRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetPaymentRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentRequest.organization_id)
  return _internal_organization_id();
}
inline void GetPaymentRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void GetPaymentRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void GetPaymentRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& GetPaymentRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentRequest.customer_id)
}
inline std::string* GetPaymentRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentRequest.customer_id)
  return _s;
}
inline const std::string& GetPaymentRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void GetPaymentRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentRequest.customer_id)
}

// string card_id = 3 [json_name = "cardId"];
inline void GetPaymentRequest::clear_card_id() {
  card_id_.ClearToEmpty();
}
inline const std::string& GetPaymentRequest::card_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentRequest.card_id)
  return _internal_card_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentRequest::set_card_id(ArgT0&& arg0, ArgT... args) {
 
 card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentRequest.card_id)
}
inline std::string* GetPaymentRequest::mutable_card_id() {
  std::string* _s = _internal_mutable_card_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentRequest.card_id)
  return _s;
}
inline const std::string& GetPaymentRequest::_internal_card_id() const {
  return card_id_.Get();
}
inline void GetPaymentRequest::_internal_set_card_id(const std::string& value) {
  
  card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentRequest::_internal_mutable_card_id() {
  
  return card_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentRequest::release_card_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentRequest.card_id)
  return card_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentRequest::set_allocated_card_id(std::string* card_id) {
  if (card_id != nullptr) {
    
  } else {
    
  }
  card_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentRequest.card_id)
}

// -------------------------------------------------------------------

// GetPaymentResponse

// .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
inline bool GetPaymentResponse::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool GetPaymentResponse::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::Payment& GetPaymentResponse::_internal_payment() const {
  const ::payment::v1alpha1::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Payment&>(
      ::payment::v1alpha1::_Payment_default_instance_);
}
inline const ::payment::v1alpha1::Payment& GetPaymentResponse::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentResponse.payment)
  return _internal_payment();
}
inline void GetPaymentResponse::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetPaymentResponse.payment)
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::release_payment() {
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentResponse.payment)
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::mutable_payment() {
  ::payment::v1alpha1::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentResponse.payment)
  return _msg;
}
inline void GetPaymentResponse::set_allocated_payment(::payment::v1alpha1::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentResponse.payment)
}

// string status = 2 [json_name = "status"];
inline void GetPaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetPaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentResponse.status)
}
inline std::string* GetPaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentResponse.status)
  return _s;
}
inline const std::string& GetPaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void GetPaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentResponse.status)
}

// -------------------------------------------------------------------

// ListPaymentRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void ListPaymentRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListPaymentRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListPaymentRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentRequest.organization_id)
  return _internal_organization_id();
}
inline void ListPaymentRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void ListPaymentRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListPaymentRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void ListPaymentRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& ListPaymentRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPaymentRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListPaymentRequest.customer_id)
}
inline std::string* ListPaymentRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListPaymentRequest.customer_id)
  return _s;
}
inline const std::string& ListPaymentRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void ListPaymentRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPaymentRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPaymentRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListPaymentRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPaymentRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListPaymentRequest.customer_id)
}

// -------------------------------------------------------------------

// ListPaymentResponse

// .payment.v1alpha1.PaymentList payment_list = 1 [json_name = "paymentList"];
inline bool ListPaymentResponse::_internal_has_payment_list() const {
  return this != internal_default_instance() && payment_list_ != nullptr;
}
inline bool ListPaymentResponse::has_payment_list() const {
  return _internal_has_payment_list();
}
inline const ::payment::v1alpha1::PaymentList& ListPaymentResponse::_internal_payment_list() const {
  const ::payment::v1alpha1::PaymentList* p = payment_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::PaymentList&>(
      ::payment::v1alpha1::_PaymentList_default_instance_);
}
inline const ::payment::v1alpha1::PaymentList& ListPaymentResponse::payment_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentResponse.payment_list)
  return _internal_payment_list();
}
inline void ListPaymentResponse::unsafe_arena_set_allocated_payment_list(
    ::payment::v1alpha1::PaymentList* payment_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_list_);
  }
  payment_list_ = payment_list;
  if (payment_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.ListPaymentResponse.payment_list)
}
inline ::payment::v1alpha1::PaymentList* ListPaymentResponse::release_payment_list() {
  
  ::payment::v1alpha1::PaymentList* temp = payment_list_;
  payment_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::PaymentList* ListPaymentResponse::unsafe_arena_release_payment_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListPaymentResponse.payment_list)
  
  ::payment::v1alpha1::PaymentList* temp = payment_list_;
  payment_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::PaymentList* ListPaymentResponse::_internal_mutable_payment_list() {
  
  if (payment_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::PaymentList>(GetArenaForAllocation());
    payment_list_ = p;
  }
  return payment_list_;
}
inline ::payment::v1alpha1::PaymentList* ListPaymentResponse::mutable_payment_list() {
  ::payment::v1alpha1::PaymentList* _msg = _internal_mutable_payment_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListPaymentResponse.payment_list)
  return _msg;
}
inline void ListPaymentResponse::set_allocated_payment_list(::payment::v1alpha1::PaymentList* payment_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_list_);
  }
  if (payment_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_list));
    if (message_arena != submessage_arena) {
      payment_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment_list, submessage_arena);
    }
    
  } else {
    
  }
  payment_list_ = payment_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListPaymentResponse.payment_list)
}

// string status = 2 [json_name = "status"];
inline void ListPaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& ListPaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListPaymentResponse.status)
}
inline std::string* ListPaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListPaymentResponse.status)
  return _s;
}
inline const std::string& ListPaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void ListPaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListPaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListPaymentResponse.status)
}

// -------------------------------------------------------------------

// ListProjectsRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void ListProjectsRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListProjectsRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListProjectsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListProjectsRequest.organization_id)
  return _internal_organization_id();
}
inline void ListProjectsRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void ListProjectsRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListProjectsRequest.organization_id)
}

// -------------------------------------------------------------------

// ListProjectsResponse

// .payment.v1alpha1.ProjectList project_list = 1 [json_name = "projectList"];
inline bool ListProjectsResponse::_internal_has_project_list() const {
  return this != internal_default_instance() && project_list_ != nullptr;
}
inline bool ListProjectsResponse::has_project_list() const {
  return _internal_has_project_list();
}
inline const ::payment::v1alpha1::ProjectList& ListProjectsResponse::_internal_project_list() const {
  const ::payment::v1alpha1::ProjectList* p = project_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::ProjectList&>(
      ::payment::v1alpha1::_ProjectList_default_instance_);
}
inline const ::payment::v1alpha1::ProjectList& ListProjectsResponse::project_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListProjectsResponse.project_list)
  return _internal_project_list();
}
inline void ListProjectsResponse::unsafe_arena_set_allocated_project_list(
    ::payment::v1alpha1::ProjectList* project_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_list_);
  }
  project_list_ = project_list;
  if (project_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.ListProjectsResponse.project_list)
}
inline ::payment::v1alpha1::ProjectList* ListProjectsResponse::release_project_list() {
  
  ::payment::v1alpha1::ProjectList* temp = project_list_;
  project_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::ProjectList* ListProjectsResponse::unsafe_arena_release_project_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListProjectsResponse.project_list)
  
  ::payment::v1alpha1::ProjectList* temp = project_list_;
  project_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::ProjectList* ListProjectsResponse::_internal_mutable_project_list() {
  
  if (project_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::ProjectList>(GetArenaForAllocation());
    project_list_ = p;
  }
  return project_list_;
}
inline ::payment::v1alpha1::ProjectList* ListProjectsResponse::mutable_project_list() {
  ::payment::v1alpha1::ProjectList* _msg = _internal_mutable_project_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListProjectsResponse.project_list)
  return _msg;
}
inline void ListProjectsResponse::set_allocated_project_list(::payment::v1alpha1::ProjectList* project_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_list_);
  }
  if (project_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_list));
    if (message_arena != submessage_arena) {
      project_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, project_list, submessage_arena);
    }
    
  } else {
    
  }
  project_list_ = project_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListProjectsResponse.project_list)
}

// string status = 2 [json_name = "status"];
inline void ListProjectsResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& ListProjectsResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListProjectsResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListProjectsResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListProjectsResponse.status)
}
inline std::string* ListProjectsResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListProjectsResponse.status)
  return _s;
}
inline const std::string& ListProjectsResponse::_internal_status() const {
  return status_.Get();
}
inline void ListProjectsResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListProjectsResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListProjectsResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListProjectsResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListProjectsResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListProjectsResponse.status)
}

// -------------------------------------------------------------------

// GetProjectRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void GetProjectRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& GetProjectRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetProjectRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProjectRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetProjectRequest.organization_id)
}
inline std::string* GetProjectRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetProjectRequest.organization_id)
  return _s;
}
inline const std::string& GetProjectRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void GetProjectRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetProjectRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetProjectRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetProjectRequest.organization_id)
  return organization_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetProjectRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), organization_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetProjectRequest.organization_id)
}

// string project_id = 2 [json_name = "projectId"];
inline void GetProjectRequest::clear_project_id() {
  project_id_.ClearToEmpty();
}
inline const std::string& GetProjectRequest::project_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetProjectRequest.project_id)
  return _internal_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProjectRequest::set_project_id(ArgT0&& arg0, ArgT... args) {
 
 project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetProjectRequest.project_id)
}
inline std::string* GetProjectRequest::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetProjectRequest.project_id)
  return _s;
}
inline const std::string& GetProjectRequest::_internal_project_id() const {
  return project_id_.Get();
}
inline void GetProjectRequest::_internal_set_project_id(const std::string& value) {
  
  project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetProjectRequest::_internal_mutable_project_id() {
  
  return project_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetProjectRequest::release_project_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetProjectRequest.project_id)
  return project_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetProjectRequest::set_allocated_project_id(std::string* project_id) {
  if (project_id != nullptr) {
    
  } else {
    
  }
  project_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetProjectRequest.project_id)
}

// -------------------------------------------------------------------

// GetProjectResponse

// .payment.v1alpha1.Project project = 1 [json_name = "project"];
inline bool GetProjectResponse::_internal_has_project() const {
  return this != internal_default_instance() && project_ != nullptr;
}
inline bool GetProjectResponse::has_project() const {
  return _internal_has_project();
}
inline const ::payment::v1alpha1::Project& GetProjectResponse::_internal_project() const {
  const ::payment::v1alpha1::Project* p = project_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Project&>(
      ::payment::v1alpha1::_Project_default_instance_);
}
inline const ::payment::v1alpha1::Project& GetProjectResponse::project() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetProjectResponse.project)
  return _internal_project();
}
inline void GetProjectResponse::unsafe_arena_set_allocated_project(
    ::payment::v1alpha1::Project* project) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_);
  }
  project_ = project;
  if (project) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetProjectResponse.project)
}
inline ::payment::v1alpha1::Project* GetProjectResponse::release_project() {
  
  ::payment::v1alpha1::Project* temp = project_;
  project_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Project* GetProjectResponse::unsafe_arena_release_project() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetProjectResponse.project)
  
  ::payment::v1alpha1::Project* temp = project_;
  project_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Project* GetProjectResponse::_internal_mutable_project() {
  
  if (project_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Project>(GetArenaForAllocation());
    project_ = p;
  }
  return project_;
}
inline ::payment::v1alpha1::Project* GetProjectResponse::mutable_project() {
  ::payment::v1alpha1::Project* _msg = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetProjectResponse.project)
  return _msg;
}
inline void GetProjectResponse::set_allocated_project(::payment::v1alpha1::Project* project) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_);
  }
  if (project) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project));
    if (message_arena != submessage_arena) {
      project = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, project, submessage_arena);
    }
    
  } else {
    
  }
  project_ = project;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetProjectResponse.project)
}

// string status = 2 [json_name = "status"];
inline void GetProjectResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetProjectResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetProjectResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProjectResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetProjectResponse.status)
}
inline std::string* GetProjectResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetProjectResponse.status)
  return _s;
}
inline const std::string& GetProjectResponse::_internal_status() const {
  return status_.Get();
}
inline void GetProjectResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetProjectResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetProjectResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetProjectResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetProjectResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetProjectResponse.status)
}

// -------------------------------------------------------------------

// DeleteProjectRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void DeleteProjectRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteProjectRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteProjectRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteProjectRequest.organization_id)
  return _internal_organization_id();
}
inline void DeleteProjectRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void DeleteProjectRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeleteProjectRequest.organization_id)
}

// string project_id = 2 [json_name = "projectId"];
inline void DeleteProjectRequest::clear_project_id() {
  project_id_.ClearToEmpty();
}
inline const std::string& DeleteProjectRequest::project_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteProjectRequest.project_id)
  return _internal_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteProjectRequest::set_project_id(ArgT0&& arg0, ArgT... args) {
 
 project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeleteProjectRequest.project_id)
}
inline std::string* DeleteProjectRequest::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeleteProjectRequest.project_id)
  return _s;
}
inline const std::string& DeleteProjectRequest::_internal_project_id() const {
  return project_id_.Get();
}
inline void DeleteProjectRequest::_internal_set_project_id(const std::string& value) {
  
  project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteProjectRequest::_internal_mutable_project_id() {
  
  return project_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteProjectRequest::release_project_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeleteProjectRequest.project_id)
  return project_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteProjectRequest::set_allocated_project_id(std::string* project_id) {
  if (project_id != nullptr) {
    
  } else {
    
  }
  project_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeleteProjectRequest.project_id)
}

// -------------------------------------------------------------------

// DeleteProjectResponse

// string status = 1 [json_name = "status"];
inline void DeleteProjectResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& DeleteProjectResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteProjectResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteProjectResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeleteProjectResponse.status)
}
inline std::string* DeleteProjectResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeleteProjectResponse.status)
  return _s;
}
inline const std::string& DeleteProjectResponse::_internal_status() const {
  return status_.Get();
}
inline void DeleteProjectResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteProjectResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteProjectResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeleteProjectResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteProjectResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeleteProjectResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace payment

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_payment_2fv1alpha1_2fpayment_5fapi_2eproto
