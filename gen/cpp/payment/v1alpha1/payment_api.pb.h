// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: payment/v1alpha1/payment_api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_payment_2fv1alpha1_2fpayment_5fapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_payment_2fv1alpha1_2fpayment_5fapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "payment/v1alpha1/payment.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_payment_2fv1alpha1_2fpayment_5fapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[48]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
namespace payment {
namespace v1alpha1 {
class CancelSubscriptionRequest;
struct CancelSubscriptionRequestDefaultTypeInternal;
extern CancelSubscriptionRequestDefaultTypeInternal _CancelSubscriptionRequest_default_instance_;
class CancelSubscriptionResponse;
struct CancelSubscriptionResponseDefaultTypeInternal;
extern CancelSubscriptionResponseDefaultTypeInternal _CancelSubscriptionResponse_default_instance_;
class CreateCardRequest;
struct CreateCardRequestDefaultTypeInternal;
extern CreateCardRequestDefaultTypeInternal _CreateCardRequest_default_instance_;
class CreateCardResponse;
struct CreateCardResponseDefaultTypeInternal;
extern CreateCardResponseDefaultTypeInternal _CreateCardResponse_default_instance_;
class CreateCustomerRequest;
struct CreateCustomerRequestDefaultTypeInternal;
extern CreateCustomerRequestDefaultTypeInternal _CreateCustomerRequest_default_instance_;
class CreateCustomerResponse;
struct CreateCustomerResponseDefaultTypeInternal;
extern CreateCustomerResponseDefaultTypeInternal _CreateCustomerResponse_default_instance_;
class CreateInvoiceRequest;
struct CreateInvoiceRequestDefaultTypeInternal;
extern CreateInvoiceRequestDefaultTypeInternal _CreateInvoiceRequest_default_instance_;
class CreateInvoiceResponse;
struct CreateInvoiceResponseDefaultTypeInternal;
extern CreateInvoiceResponseDefaultTypeInternal _CreateInvoiceResponse_default_instance_;
class CreatePaymentRequest;
struct CreatePaymentRequestDefaultTypeInternal;
extern CreatePaymentRequestDefaultTypeInternal _CreatePaymentRequest_default_instance_;
class CreatePaymentResponse;
struct CreatePaymentResponseDefaultTypeInternal;
extern CreatePaymentResponseDefaultTypeInternal _CreatePaymentResponse_default_instance_;
class CreateProjectRequest;
struct CreateProjectRequestDefaultTypeInternal;
extern CreateProjectRequestDefaultTypeInternal _CreateProjectRequest_default_instance_;
class CreateProjectResponse;
struct CreateProjectResponseDefaultTypeInternal;
extern CreateProjectResponseDefaultTypeInternal _CreateProjectResponse_default_instance_;
class CreateSubscriptionRequest;
struct CreateSubscriptionRequestDefaultTypeInternal;
extern CreateSubscriptionRequestDefaultTypeInternal _CreateSubscriptionRequest_default_instance_;
class CreateSubscriptionResponse;
struct CreateSubscriptionResponseDefaultTypeInternal;
extern CreateSubscriptionResponseDefaultTypeInternal _CreateSubscriptionResponse_default_instance_;
class DeleteCustomerRequest;
struct DeleteCustomerRequestDefaultTypeInternal;
extern DeleteCustomerRequestDefaultTypeInternal _DeleteCustomerRequest_default_instance_;
class DeleteCustomerResponse;
struct DeleteCustomerResponseDefaultTypeInternal;
extern DeleteCustomerResponseDefaultTypeInternal _DeleteCustomerResponse_default_instance_;
class DeletePaymentRequest;
struct DeletePaymentRequestDefaultTypeInternal;
extern DeletePaymentRequestDefaultTypeInternal _DeletePaymentRequest_default_instance_;
class DeletePaymentResponse;
struct DeletePaymentResponseDefaultTypeInternal;
extern DeletePaymentResponseDefaultTypeInternal _DeletePaymentResponse_default_instance_;
class DeleteProjectRequest;
struct DeleteProjectRequestDefaultTypeInternal;
extern DeleteProjectRequestDefaultTypeInternal _DeleteProjectRequest_default_instance_;
class DeleteProjectResponse;
struct DeleteProjectResponseDefaultTypeInternal;
extern DeleteProjectResponseDefaultTypeInternal _DeleteProjectResponse_default_instance_;
class GetBilingMonthRequest;
struct GetBilingMonthRequestDefaultTypeInternal;
extern GetBilingMonthRequestDefaultTypeInternal _GetBilingMonthRequest_default_instance_;
class GetBilingMonthResponse;
struct GetBilingMonthResponseDefaultTypeInternal;
extern GetBilingMonthResponseDefaultTypeInternal _GetBilingMonthResponse_default_instance_;
class GetCustomerRequest;
struct GetCustomerRequestDefaultTypeInternal;
extern GetCustomerRequestDefaultTypeInternal _GetCustomerRequest_default_instance_;
class GetCustomerResponse;
struct GetCustomerResponseDefaultTypeInternal;
extern GetCustomerResponseDefaultTypeInternal _GetCustomerResponse_default_instance_;
class GetOrganizationRequest;
struct GetOrganizationRequestDefaultTypeInternal;
extern GetOrganizationRequestDefaultTypeInternal _GetOrganizationRequest_default_instance_;
class GetOrganizationResponse;
struct GetOrganizationResponseDefaultTypeInternal;
extern GetOrganizationResponseDefaultTypeInternal _GetOrganizationResponse_default_instance_;
class GetPaymentRequest;
struct GetPaymentRequestDefaultTypeInternal;
extern GetPaymentRequestDefaultTypeInternal _GetPaymentRequest_default_instance_;
class GetPaymentResponse;
struct GetPaymentResponseDefaultTypeInternal;
extern GetPaymentResponseDefaultTypeInternal _GetPaymentResponse_default_instance_;
class GetPaymentsRequest;
struct GetPaymentsRequestDefaultTypeInternal;
extern GetPaymentsRequestDefaultTypeInternal _GetPaymentsRequest_default_instance_;
class GetPaymentsResponse;
struct GetPaymentsResponseDefaultTypeInternal;
extern GetPaymentsResponseDefaultTypeInternal _GetPaymentsResponse_default_instance_;
class GetProjectRequest;
struct GetProjectRequestDefaultTypeInternal;
extern GetProjectRequestDefaultTypeInternal _GetProjectRequest_default_instance_;
class GetProjectResponse;
struct GetProjectResponseDefaultTypeInternal;
extern GetProjectResponseDefaultTypeInternal _GetProjectResponse_default_instance_;
class GetSubscriptionRequest;
struct GetSubscriptionRequestDefaultTypeInternal;
extern GetSubscriptionRequestDefaultTypeInternal _GetSubscriptionRequest_default_instance_;
class GetSubscriptionResponse;
struct GetSubscriptionResponseDefaultTypeInternal;
extern GetSubscriptionResponseDefaultTypeInternal _GetSubscriptionResponse_default_instance_;
class InvoiceFilterRequest;
struct InvoiceFilterRequestDefaultTypeInternal;
extern InvoiceFilterRequestDefaultTypeInternal _InvoiceFilterRequest_default_instance_;
class InvoiceFilterResponse;
struct InvoiceFilterResponseDefaultTypeInternal;
extern InvoiceFilterResponseDefaultTypeInternal _InvoiceFilterResponse_default_instance_;
class ListPaymentRequest;
struct ListPaymentRequestDefaultTypeInternal;
extern ListPaymentRequestDefaultTypeInternal _ListPaymentRequest_default_instance_;
class ListPaymentResponse;
struct ListPaymentResponseDefaultTypeInternal;
extern ListPaymentResponseDefaultTypeInternal _ListPaymentResponse_default_instance_;
class ListProjectsRequest;
struct ListProjectsRequestDefaultTypeInternal;
extern ListProjectsRequestDefaultTypeInternal _ListProjectsRequest_default_instance_;
class ListProjectsResponse;
struct ListProjectsResponseDefaultTypeInternal;
extern ListProjectsResponseDefaultTypeInternal _ListProjectsResponse_default_instance_;
class ListSubscriptionItemsRequest;
struct ListSubscriptionItemsRequestDefaultTypeInternal;
extern ListSubscriptionItemsRequestDefaultTypeInternal _ListSubscriptionItemsRequest_default_instance_;
class ListSubscriptionItemsResponse;
struct ListSubscriptionItemsResponseDefaultTypeInternal;
extern ListSubscriptionItemsResponseDefaultTypeInternal _ListSubscriptionItemsResponse_default_instance_;
class SetDefaultPaymentMethodRequest;
struct SetDefaultPaymentMethodRequestDefaultTypeInternal;
extern SetDefaultPaymentMethodRequestDefaultTypeInternal _SetDefaultPaymentMethodRequest_default_instance_;
class SetDefaultPaymentMethodResponse;
struct SetDefaultPaymentMethodResponseDefaultTypeInternal;
extern SetDefaultPaymentMethodResponseDefaultTypeInternal _SetDefaultPaymentMethodResponse_default_instance_;
class StopProjectRequest;
struct StopProjectRequestDefaultTypeInternal;
extern StopProjectRequestDefaultTypeInternal _StopProjectRequest_default_instance_;
class StopProjectResponse;
struct StopProjectResponseDefaultTypeInternal;
extern StopProjectResponseDefaultTypeInternal _StopProjectResponse_default_instance_;
class UpdateSubscriptionRequest;
struct UpdateSubscriptionRequestDefaultTypeInternal;
extern UpdateSubscriptionRequestDefaultTypeInternal _UpdateSubscriptionRequest_default_instance_;
class UpdateSubscriptionResponse;
struct UpdateSubscriptionResponseDefaultTypeInternal;
extern UpdateSubscriptionResponseDefaultTypeInternal _UpdateSubscriptionResponse_default_instance_;
}  // namespace v1alpha1
}  // namespace payment
PROTOBUF_NAMESPACE_OPEN
template<> ::payment::v1alpha1::CancelSubscriptionRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CancelSubscriptionRequest>(Arena*);
template<> ::payment::v1alpha1::CancelSubscriptionResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CancelSubscriptionResponse>(Arena*);
template<> ::payment::v1alpha1::CreateCardRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateCardRequest>(Arena*);
template<> ::payment::v1alpha1::CreateCardResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateCardResponse>(Arena*);
template<> ::payment::v1alpha1::CreateCustomerRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateCustomerRequest>(Arena*);
template<> ::payment::v1alpha1::CreateCustomerResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateCustomerResponse>(Arena*);
template<> ::payment::v1alpha1::CreateInvoiceRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateInvoiceRequest>(Arena*);
template<> ::payment::v1alpha1::CreateInvoiceResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateInvoiceResponse>(Arena*);
template<> ::payment::v1alpha1::CreatePaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreatePaymentRequest>(Arena*);
template<> ::payment::v1alpha1::CreatePaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreatePaymentResponse>(Arena*);
template<> ::payment::v1alpha1::CreateProjectRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateProjectRequest>(Arena*);
template<> ::payment::v1alpha1::CreateProjectResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateProjectResponse>(Arena*);
template<> ::payment::v1alpha1::CreateSubscriptionRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateSubscriptionRequest>(Arena*);
template<> ::payment::v1alpha1::CreateSubscriptionResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateSubscriptionResponse>(Arena*);
template<> ::payment::v1alpha1::DeleteCustomerRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::DeleteCustomerRequest>(Arena*);
template<> ::payment::v1alpha1::DeleteCustomerResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::DeleteCustomerResponse>(Arena*);
template<> ::payment::v1alpha1::DeletePaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::DeletePaymentRequest>(Arena*);
template<> ::payment::v1alpha1::DeletePaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::DeletePaymentResponse>(Arena*);
template<> ::payment::v1alpha1::DeleteProjectRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::DeleteProjectRequest>(Arena*);
template<> ::payment::v1alpha1::DeleteProjectResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::DeleteProjectResponse>(Arena*);
template<> ::payment::v1alpha1::GetBilingMonthRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetBilingMonthRequest>(Arena*);
template<> ::payment::v1alpha1::GetBilingMonthResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetBilingMonthResponse>(Arena*);
template<> ::payment::v1alpha1::GetCustomerRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetCustomerRequest>(Arena*);
template<> ::payment::v1alpha1::GetCustomerResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetCustomerResponse>(Arena*);
template<> ::payment::v1alpha1::GetOrganizationRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetOrganizationRequest>(Arena*);
template<> ::payment::v1alpha1::GetOrganizationResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetOrganizationResponse>(Arena*);
template<> ::payment::v1alpha1::GetPaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetPaymentRequest>(Arena*);
template<> ::payment::v1alpha1::GetPaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetPaymentResponse>(Arena*);
template<> ::payment::v1alpha1::GetPaymentsRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetPaymentsRequest>(Arena*);
template<> ::payment::v1alpha1::GetPaymentsResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetPaymentsResponse>(Arena*);
template<> ::payment::v1alpha1::GetProjectRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetProjectRequest>(Arena*);
template<> ::payment::v1alpha1::GetProjectResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetProjectResponse>(Arena*);
template<> ::payment::v1alpha1::GetSubscriptionRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetSubscriptionRequest>(Arena*);
template<> ::payment::v1alpha1::GetSubscriptionResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetSubscriptionResponse>(Arena*);
template<> ::payment::v1alpha1::InvoiceFilterRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::InvoiceFilterRequest>(Arena*);
template<> ::payment::v1alpha1::InvoiceFilterResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::InvoiceFilterResponse>(Arena*);
template<> ::payment::v1alpha1::ListPaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::ListPaymentRequest>(Arena*);
template<> ::payment::v1alpha1::ListPaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::ListPaymentResponse>(Arena*);
template<> ::payment::v1alpha1::ListProjectsRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::ListProjectsRequest>(Arena*);
template<> ::payment::v1alpha1::ListProjectsResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::ListProjectsResponse>(Arena*);
template<> ::payment::v1alpha1::ListSubscriptionItemsRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::ListSubscriptionItemsRequest>(Arena*);
template<> ::payment::v1alpha1::ListSubscriptionItemsResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::ListSubscriptionItemsResponse>(Arena*);
template<> ::payment::v1alpha1::SetDefaultPaymentMethodRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::SetDefaultPaymentMethodRequest>(Arena*);
template<> ::payment::v1alpha1::SetDefaultPaymentMethodResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::SetDefaultPaymentMethodResponse>(Arena*);
template<> ::payment::v1alpha1::StopProjectRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::StopProjectRequest>(Arena*);
template<> ::payment::v1alpha1::StopProjectResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::StopProjectResponse>(Arena*);
template<> ::payment::v1alpha1::UpdateSubscriptionRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::UpdateSubscriptionRequest>(Arena*);
template<> ::payment::v1alpha1::UpdateSubscriptionResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::UpdateSubscriptionResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace payment {
namespace v1alpha1 {

// ===================================================================

class StopProjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.StopProjectRequest) */ {
 public:
  inline StopProjectRequest() : StopProjectRequest(nullptr) {}
  ~StopProjectRequest() override;
  explicit constexpr StopProjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopProjectRequest(const StopProjectRequest& from);
  StopProjectRequest(StopProjectRequest&& from) noexcept
    : StopProjectRequest() {
    *this = ::std::move(from);
  }

  inline StopProjectRequest& operator=(const StopProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopProjectRequest& operator=(StopProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopProjectRequest* internal_default_instance() {
    return reinterpret_cast<const StopProjectRequest*>(
               &_StopProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StopProjectRequest& a, StopProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopProjectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopProjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopProjectRequest* New() const final {
    return new StopProjectRequest();
  }

  StopProjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopProjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopProjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StopProjectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopProjectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.StopProjectRequest";
  }
  protected:
  explicit StopProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kProjectIdFieldNumber = 2,
  };
  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 project_id = 2 [json_name = "projectId"];
  void clear_project_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id() const;
  void set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_project_id() const;
  void _internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.StopProjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class StopProjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.StopProjectResponse) */ {
 public:
  inline StopProjectResponse() : StopProjectResponse(nullptr) {}
  ~StopProjectResponse() override;
  explicit constexpr StopProjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopProjectResponse(const StopProjectResponse& from);
  StopProjectResponse(StopProjectResponse&& from) noexcept
    : StopProjectResponse() {
    *this = ::std::move(from);
  }

  inline StopProjectResponse& operator=(const StopProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopProjectResponse& operator=(StopProjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopProjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopProjectResponse* internal_default_instance() {
    return reinterpret_cast<const StopProjectResponse*>(
               &_StopProjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StopProjectResponse& a, StopProjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopProjectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopProjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopProjectResponse* New() const final {
    return new StopProjectResponse();
  }

  StopProjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopProjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopProjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StopProjectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopProjectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.StopProjectResponse";
  }
  protected:
  explicit StopProjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.StopProjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class InvoiceFilterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.InvoiceFilterRequest) */ {
 public:
  inline InvoiceFilterRequest() : InvoiceFilterRequest(nullptr) {}
  ~InvoiceFilterRequest() override;
  explicit constexpr InvoiceFilterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvoiceFilterRequest(const InvoiceFilterRequest& from);
  InvoiceFilterRequest(InvoiceFilterRequest&& from) noexcept
    : InvoiceFilterRequest() {
    *this = ::std::move(from);
  }

  inline InvoiceFilterRequest& operator=(const InvoiceFilterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvoiceFilterRequest& operator=(InvoiceFilterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvoiceFilterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvoiceFilterRequest* internal_default_instance() {
    return reinterpret_cast<const InvoiceFilterRequest*>(
               &_InvoiceFilterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InvoiceFilterRequest& a, InvoiceFilterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InvoiceFilterRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvoiceFilterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InvoiceFilterRequest* New() const final {
    return new InvoiceFilterRequest();
  }

  InvoiceFilterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InvoiceFilterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvoiceFilterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvoiceFilterRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvoiceFilterRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.InvoiceFilterRequest";
  }
  protected:
  explicit InvoiceFilterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvoiceIdFieldNumber = 2,
    kYearFieldNumber = 3,
    kMonthFieldNumber = 4,
    kCustomerIdFieldNumber = 5,
    kProjectIdFieldNumber = 6,
    kCustomerListFieldNumber = 10,
    kCpuFieldNumber = 7,
    kRamFieldNumber = 8,
    kPipelineFieldNumber = 9,
    kOrganizationIdFieldNumber = 1,
  };
  // string invoice_id = 2 [json_name = "invoiceId"];
  void clear_invoice_id();
  const std::string& invoice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invoice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invoice_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_invoice_id();
  void set_allocated_invoice_id(std::string* invoice_id);
  private:
  const std::string& _internal_invoice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invoice_id(const std::string& value);
  std::string* _internal_mutable_invoice_id();
  public:

  // string year = 3 [json_name = "year"];
  void clear_year();
  const std::string& year() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_year(ArgT0&& arg0, ArgT... args);
  std::string* mutable_year();
  PROTOBUF_MUST_USE_RESULT std::string* release_year();
  void set_allocated_year(std::string* year);
  private:
  const std::string& _internal_year() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_year(const std::string& value);
  std::string* _internal_mutable_year();
  public:

  // string month = 4 [json_name = "month"];
  void clear_month();
  const std::string& month() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_month(ArgT0&& arg0, ArgT... args);
  std::string* mutable_month();
  PROTOBUF_MUST_USE_RESULT std::string* release_month();
  void set_allocated_month(std::string* month);
  private:
  const std::string& _internal_month() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_month(const std::string& value);
  std::string* _internal_mutable_month();
  public:

  // string customer_id = 5 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // string project_id = 6 [json_name = "projectId"];
  void clear_project_id();
  const std::string& project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_project_id();
  void set_allocated_project_id(std::string* project_id);
  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(const std::string& value);
  std::string* _internal_mutable_project_id();
  public:

  // .payment.v1alpha1.CustomerList customer_list = 10 [json_name = "customerList"];
  bool has_customer_list() const;
  private:
  bool _internal_has_customer_list() const;
  public:
  void clear_customer_list();
  const ::payment::v1alpha1::CustomerList& customer_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::CustomerList* release_customer_list();
  ::payment::v1alpha1::CustomerList* mutable_customer_list();
  void set_allocated_customer_list(::payment::v1alpha1::CustomerList* customer_list);
  private:
  const ::payment::v1alpha1::CustomerList& _internal_customer_list() const;
  ::payment::v1alpha1::CustomerList* _internal_mutable_customer_list();
  public:
  void unsafe_arena_set_allocated_customer_list(
      ::payment::v1alpha1::CustomerList* customer_list);
  ::payment::v1alpha1::CustomerList* unsafe_arena_release_customer_list();

  // double cpu = 7 [json_name = "cpu"];
  void clear_cpu();
  double cpu() const;
  void set_cpu(double value);
  private:
  double _internal_cpu() const;
  void _internal_set_cpu(double value);
  public:

  // double ram = 8 [json_name = "ram"];
  void clear_ram();
  double ram() const;
  void set_ram(double value);
  private:
  double _internal_ram() const;
  void _internal_set_ram(double value);
  public:

  // double pipeline = 9 [json_name = "pipeline"];
  void clear_pipeline();
  double pipeline() const;
  void set_pipeline(double value);
  private:
  double _internal_pipeline() const;
  void _internal_set_pipeline(double value);
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.InvoiceFilterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invoice_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr year_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr month_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_id_;
  ::payment::v1alpha1::CustomerList* customer_list_;
  double cpu_;
  double ram_;
  double pipeline_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class InvoiceFilterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.InvoiceFilterResponse) */ {
 public:
  inline InvoiceFilterResponse() : InvoiceFilterResponse(nullptr) {}
  ~InvoiceFilterResponse() override;
  explicit constexpr InvoiceFilterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvoiceFilterResponse(const InvoiceFilterResponse& from);
  InvoiceFilterResponse(InvoiceFilterResponse&& from) noexcept
    : InvoiceFilterResponse() {
    *this = ::std::move(from);
  }

  inline InvoiceFilterResponse& operator=(const InvoiceFilterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvoiceFilterResponse& operator=(InvoiceFilterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvoiceFilterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvoiceFilterResponse* internal_default_instance() {
    return reinterpret_cast<const InvoiceFilterResponse*>(
               &_InvoiceFilterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InvoiceFilterResponse& a, InvoiceFilterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InvoiceFilterResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvoiceFilterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InvoiceFilterResponse* New() const final {
    return new InvoiceFilterResponse();
  }

  InvoiceFilterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InvoiceFilterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvoiceFilterResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvoiceFilterResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvoiceFilterResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.InvoiceFilterResponse";
  }
  protected:
  explicit InvoiceFilterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 3,
    kCustomerFieldNumber = 1,
    kBilingListFieldNumber = 2,
  };
  // string status = 3 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // .payment.v1alpha1.BilingList biling_list = 2 [json_name = "bilingList"];
  bool has_biling_list() const;
  private:
  bool _internal_has_biling_list() const;
  public:
  void clear_biling_list();
  const ::payment::v1alpha1::BilingList& biling_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::BilingList* release_biling_list();
  ::payment::v1alpha1::BilingList* mutable_biling_list();
  void set_allocated_biling_list(::payment::v1alpha1::BilingList* biling_list);
  private:
  const ::payment::v1alpha1::BilingList& _internal_biling_list() const;
  ::payment::v1alpha1::BilingList* _internal_mutable_biling_list();
  public:
  void unsafe_arena_set_allocated_biling_list(
      ::payment::v1alpha1::BilingList* biling_list);
  ::payment::v1alpha1::BilingList* unsafe_arena_release_biling_list();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.InvoiceFilterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  ::payment::v1alpha1::BilingList* biling_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteCustomerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeleteCustomerRequest) */ {
 public:
  inline DeleteCustomerRequest() : DeleteCustomerRequest(nullptr) {}
  ~DeleteCustomerRequest() override;
  explicit constexpr DeleteCustomerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteCustomerRequest(const DeleteCustomerRequest& from);
  DeleteCustomerRequest(DeleteCustomerRequest&& from) noexcept
    : DeleteCustomerRequest() {
    *this = ::std::move(from);
  }

  inline DeleteCustomerRequest& operator=(const DeleteCustomerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteCustomerRequest& operator=(DeleteCustomerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteCustomerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteCustomerRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteCustomerRequest*>(
               &_DeleteCustomerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeleteCustomerRequest& a, DeleteCustomerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteCustomerRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteCustomerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteCustomerRequest* New() const final {
    return new DeleteCustomerRequest();
  }

  DeleteCustomerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteCustomerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteCustomerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteCustomerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteCustomerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeleteCustomerRequest";
  }
  protected:
  explicit DeleteCustomerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeleteCustomerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteCustomerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeleteCustomerResponse) */ {
 public:
  inline DeleteCustomerResponse() : DeleteCustomerResponse(nullptr) {}
  ~DeleteCustomerResponse() override;
  explicit constexpr DeleteCustomerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteCustomerResponse(const DeleteCustomerResponse& from);
  DeleteCustomerResponse(DeleteCustomerResponse&& from) noexcept
    : DeleteCustomerResponse() {
    *this = ::std::move(from);
  }

  inline DeleteCustomerResponse& operator=(const DeleteCustomerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteCustomerResponse& operator=(DeleteCustomerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteCustomerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteCustomerResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteCustomerResponse*>(
               &_DeleteCustomerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeleteCustomerResponse& a, DeleteCustomerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteCustomerResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteCustomerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteCustomerResponse* New() const final {
    return new DeleteCustomerResponse();
  }

  DeleteCustomerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteCustomerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteCustomerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteCustomerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteCustomerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeleteCustomerResponse";
  }
  protected:
  explicit DeleteCustomerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kCustomerFieldNumber = 2,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 2 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeleteCustomerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetSubscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetSubscriptionRequest) */ {
 public:
  inline GetSubscriptionRequest() : GetSubscriptionRequest(nullptr) {}
  ~GetSubscriptionRequest() override;
  explicit constexpr GetSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSubscriptionRequest(const GetSubscriptionRequest& from);
  GetSubscriptionRequest(GetSubscriptionRequest&& from) noexcept
    : GetSubscriptionRequest() {
    *this = ::std::move(from);
  }

  inline GetSubscriptionRequest& operator=(const GetSubscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSubscriptionRequest& operator=(GetSubscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSubscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSubscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const GetSubscriptionRequest*>(
               &_GetSubscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetSubscriptionRequest& a, GetSubscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSubscriptionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSubscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetSubscriptionRequest* New() const final {
    return new GetSubscriptionRequest();
  }

  GetSubscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetSubscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSubscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSubscriptionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubscriptionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetSubscriptionRequest";
  }
  protected:
  explicit GetSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string subscription_id = 2 [json_name = "subscriptionId"];
  void clear_subscription_id();
  const std::string& subscription_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscription_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscription_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_subscription_id();
  void set_allocated_subscription_id(std::string* subscription_id);
  private:
  const std::string& _internal_subscription_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscription_id(const std::string& value);
  std::string* _internal_mutable_subscription_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetSubscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscription_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetSubscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetSubscriptionResponse) */ {
 public:
  inline GetSubscriptionResponse() : GetSubscriptionResponse(nullptr) {}
  ~GetSubscriptionResponse() override;
  explicit constexpr GetSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSubscriptionResponse(const GetSubscriptionResponse& from);
  GetSubscriptionResponse(GetSubscriptionResponse&& from) noexcept
    : GetSubscriptionResponse() {
    *this = ::std::move(from);
  }

  inline GetSubscriptionResponse& operator=(const GetSubscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSubscriptionResponse& operator=(GetSubscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSubscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSubscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const GetSubscriptionResponse*>(
               &_GetSubscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetSubscriptionResponse& a, GetSubscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSubscriptionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSubscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetSubscriptionResponse* New() const final {
    return new GetSubscriptionResponse();
  }

  GetSubscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetSubscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSubscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSubscriptionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubscriptionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetSubscriptionResponse";
  }
  protected:
  explicit GetSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kSubscriptionFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Subscription subscription = 1 [json_name = "subscription"];
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::payment::v1alpha1::Subscription& subscription() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Subscription* release_subscription();
  ::payment::v1alpha1::Subscription* mutable_subscription();
  void set_allocated_subscription(::payment::v1alpha1::Subscription* subscription);
  private:
  const ::payment::v1alpha1::Subscription& _internal_subscription() const;
  ::payment::v1alpha1::Subscription* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::payment::v1alpha1::Subscription* subscription);
  ::payment::v1alpha1::Subscription* unsafe_arena_release_subscription();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetSubscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Subscription* subscription_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetOrganizationRequest) */ {
 public:
  inline GetOrganizationRequest() : GetOrganizationRequest(nullptr) {}
  ~GetOrganizationRequest() override;
  explicit constexpr GetOrganizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationRequest(const GetOrganizationRequest& from);
  GetOrganizationRequest(GetOrganizationRequest&& from) noexcept
    : GetOrganizationRequest() {
    *this = ::std::move(from);
  }

  inline GetOrganizationRequest& operator=(const GetOrganizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationRequest& operator=(GetOrganizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationRequest* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationRequest*>(
               &_GetOrganizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetOrganizationRequest& a, GetOrganizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetOrganizationRequest* New() const final {
    return new GetOrganizationRequest();
  }

  GetOrganizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOrganizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetOrganizationRequest";
  }
  protected:
  explicit GetOrganizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetOrganizationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetOrganizationResponse) */ {
 public:
  inline GetOrganizationResponse() : GetOrganizationResponse(nullptr) {}
  ~GetOrganizationResponse() override;
  explicit constexpr GetOrganizationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationResponse(const GetOrganizationResponse& from);
  GetOrganizationResponse(GetOrganizationResponse&& from) noexcept
    : GetOrganizationResponse() {
    *this = ::std::move(from);
  }

  inline GetOrganizationResponse& operator=(const GetOrganizationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationResponse& operator=(GetOrganizationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationResponse* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationResponse*>(
               &_GetOrganizationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetOrganizationResponse& a, GetOrganizationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetOrganizationResponse* New() const final {
    return new GetOrganizationResponse();
  }

  GetOrganizationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOrganizationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetOrganizationResponse";
  }
  protected:
  explicit GetOrganizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kCustomerFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetOrganizationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetCustomerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetCustomerRequest) */ {
 public:
  inline GetCustomerRequest() : GetCustomerRequest(nullptr) {}
  ~GetCustomerRequest() override;
  explicit constexpr GetCustomerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCustomerRequest(const GetCustomerRequest& from);
  GetCustomerRequest(GetCustomerRequest&& from) noexcept
    : GetCustomerRequest() {
    *this = ::std::move(from);
  }

  inline GetCustomerRequest& operator=(const GetCustomerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCustomerRequest& operator=(GetCustomerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCustomerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCustomerRequest* internal_default_instance() {
    return reinterpret_cast<const GetCustomerRequest*>(
               &_GetCustomerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetCustomerRequest& a, GetCustomerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCustomerRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCustomerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetCustomerRequest* New() const final {
    return new GetCustomerRequest();
  }

  GetCustomerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetCustomerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCustomerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetCustomerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCustomerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetCustomerRequest";
  }
  protected:
  explicit GetCustomerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetCustomerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetCustomerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetCustomerResponse) */ {
 public:
  inline GetCustomerResponse() : GetCustomerResponse(nullptr) {}
  ~GetCustomerResponse() override;
  explicit constexpr GetCustomerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCustomerResponse(const GetCustomerResponse& from);
  GetCustomerResponse(GetCustomerResponse&& from) noexcept
    : GetCustomerResponse() {
    *this = ::std::move(from);
  }

  inline GetCustomerResponse& operator=(const GetCustomerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCustomerResponse& operator=(GetCustomerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCustomerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCustomerResponse* internal_default_instance() {
    return reinterpret_cast<const GetCustomerResponse*>(
               &_GetCustomerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetCustomerResponse& a, GetCustomerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCustomerResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCustomerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetCustomerResponse* New() const final {
    return new GetCustomerResponse();
  }

  GetCustomerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetCustomerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCustomerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetCustomerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCustomerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetCustomerResponse";
  }
  protected:
  explicit GetCustomerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kCustomerFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetCustomerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetBilingMonthRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetBilingMonthRequest) */ {
 public:
  inline GetBilingMonthRequest() : GetBilingMonthRequest(nullptr) {}
  ~GetBilingMonthRequest() override;
  explicit constexpr GetBilingMonthRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBilingMonthRequest(const GetBilingMonthRequest& from);
  GetBilingMonthRequest(GetBilingMonthRequest&& from) noexcept
    : GetBilingMonthRequest() {
    *this = ::std::move(from);
  }

  inline GetBilingMonthRequest& operator=(const GetBilingMonthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBilingMonthRequest& operator=(GetBilingMonthRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBilingMonthRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBilingMonthRequest* internal_default_instance() {
    return reinterpret_cast<const GetBilingMonthRequest*>(
               &_GetBilingMonthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetBilingMonthRequest& a, GetBilingMonthRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBilingMonthRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBilingMonthRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBilingMonthRequest* New() const final {
    return new GetBilingMonthRequest();
  }

  GetBilingMonthRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBilingMonthRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBilingMonthRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBilingMonthRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBilingMonthRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetBilingMonthRequest";
  }
  protected:
  explicit GetBilingMonthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvoiceIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string invoice_id = 2 [json_name = "invoiceId"];
  void clear_invoice_id();
  const std::string& invoice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invoice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invoice_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_invoice_id();
  void set_allocated_invoice_id(std::string* invoice_id);
  private:
  const std::string& _internal_invoice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invoice_id(const std::string& value);
  std::string* _internal_mutable_invoice_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetBilingMonthRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invoice_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetBilingMonthResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetBilingMonthResponse) */ {
 public:
  inline GetBilingMonthResponse() : GetBilingMonthResponse(nullptr) {}
  ~GetBilingMonthResponse() override;
  explicit constexpr GetBilingMonthResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBilingMonthResponse(const GetBilingMonthResponse& from);
  GetBilingMonthResponse(GetBilingMonthResponse&& from) noexcept
    : GetBilingMonthResponse() {
    *this = ::std::move(from);
  }

  inline GetBilingMonthResponse& operator=(const GetBilingMonthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBilingMonthResponse& operator=(GetBilingMonthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBilingMonthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBilingMonthResponse* internal_default_instance() {
    return reinterpret_cast<const GetBilingMonthResponse*>(
               &_GetBilingMonthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetBilingMonthResponse& a, GetBilingMonthResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBilingMonthResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBilingMonthResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBilingMonthResponse* New() const final {
    return new GetBilingMonthResponse();
  }

  GetBilingMonthResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBilingMonthResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBilingMonthResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBilingMonthResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBilingMonthResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetBilingMonthResponse";
  }
  protected:
  explicit GetBilingMonthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kBilingFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Biling biling = 1 [json_name = "biling"];
  bool has_biling() const;
  private:
  bool _internal_has_biling() const;
  public:
  void clear_biling();
  const ::payment::v1alpha1::Biling& biling() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Biling* release_biling();
  ::payment::v1alpha1::Biling* mutable_biling();
  void set_allocated_biling(::payment::v1alpha1::Biling* biling);
  private:
  const ::payment::v1alpha1::Biling& _internal_biling() const;
  ::payment::v1alpha1::Biling* _internal_mutable_biling();
  public:
  void unsafe_arena_set_allocated_biling(
      ::payment::v1alpha1::Biling* biling);
  ::payment::v1alpha1::Biling* unsafe_arena_release_biling();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetBilingMonthResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Biling* biling_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPaymentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetPaymentsRequest) */ {
 public:
  inline GetPaymentsRequest() : GetPaymentsRequest(nullptr) {}
  ~GetPaymentsRequest() override;
  explicit constexpr GetPaymentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaymentsRequest(const GetPaymentsRequest& from);
  GetPaymentsRequest(GetPaymentsRequest&& from) noexcept
    : GetPaymentsRequest() {
    *this = ::std::move(from);
  }

  inline GetPaymentsRequest& operator=(const GetPaymentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaymentsRequest& operator=(GetPaymentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaymentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaymentsRequest* internal_default_instance() {
    return reinterpret_cast<const GetPaymentsRequest*>(
               &_GetPaymentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetPaymentsRequest& a, GetPaymentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaymentsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaymentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPaymentsRequest* New() const final {
    return new GetPaymentsRequest();
  }

  GetPaymentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPaymentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPaymentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPaymentsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPaymentsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetPaymentsRequest";
  }
  protected:
  explicit GetPaymentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetPaymentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPaymentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetPaymentsResponse) */ {
 public:
  inline GetPaymentsResponse() : GetPaymentsResponse(nullptr) {}
  ~GetPaymentsResponse() override;
  explicit constexpr GetPaymentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaymentsResponse(const GetPaymentsResponse& from);
  GetPaymentsResponse(GetPaymentsResponse&& from) noexcept
    : GetPaymentsResponse() {
    *this = ::std::move(from);
  }

  inline GetPaymentsResponse& operator=(const GetPaymentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaymentsResponse& operator=(GetPaymentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaymentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaymentsResponse* internal_default_instance() {
    return reinterpret_cast<const GetPaymentsResponse*>(
               &_GetPaymentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetPaymentsResponse& a, GetPaymentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaymentsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaymentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPaymentsResponse* New() const final {
    return new GetPaymentsResponse();
  }

  GetPaymentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPaymentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPaymentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPaymentsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPaymentsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetPaymentsResponse";
  }
  protected:
  explicit GetPaymentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kCardFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.CardList card = 1 [json_name = "card"];
  bool has_card() const;
  private:
  bool _internal_has_card() const;
  public:
  void clear_card();
  const ::payment::v1alpha1::CardList& card() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::CardList* release_card();
  ::payment::v1alpha1::CardList* mutable_card();
  void set_allocated_card(::payment::v1alpha1::CardList* card);
  private:
  const ::payment::v1alpha1::CardList& _internal_card() const;
  ::payment::v1alpha1::CardList* _internal_mutable_card();
  public:
  void unsafe_arena_set_allocated_card(
      ::payment::v1alpha1::CardList* card);
  ::payment::v1alpha1::CardList* unsafe_arena_release_card();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetPaymentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::CardList* card_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateSubscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateSubscriptionRequest) */ {
 public:
  inline CreateSubscriptionRequest() : CreateSubscriptionRequest(nullptr) {}
  ~CreateSubscriptionRequest() override;
  explicit constexpr CreateSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSubscriptionRequest(const CreateSubscriptionRequest& from);
  CreateSubscriptionRequest(CreateSubscriptionRequest&& from) noexcept
    : CreateSubscriptionRequest() {
    *this = ::std::move(from);
  }

  inline CreateSubscriptionRequest& operator=(const CreateSubscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSubscriptionRequest& operator=(CreateSubscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSubscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSubscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSubscriptionRequest*>(
               &_CreateSubscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CreateSubscriptionRequest& a, CreateSubscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSubscriptionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSubscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateSubscriptionRequest* New() const final {
    return new CreateSubscriptionRequest();
  }

  CreateSubscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateSubscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSubscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateSubscriptionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSubscriptionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateSubscriptionRequest";
  }
  protected:
  explicit CreateSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kSubscriptionFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // .payment.v1alpha1.Subscription subscription = 3 [json_name = "subscription"];
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::payment::v1alpha1::Subscription& subscription() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Subscription* release_subscription();
  ::payment::v1alpha1::Subscription* mutable_subscription();
  void set_allocated_subscription(::payment::v1alpha1::Subscription* subscription);
  private:
  const ::payment::v1alpha1::Subscription& _internal_subscription() const;
  ::payment::v1alpha1::Subscription* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::payment::v1alpha1::Subscription* subscription);
  ::payment::v1alpha1::Subscription* unsafe_arena_release_subscription();

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateSubscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::payment::v1alpha1::Subscription* subscription_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateSubscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateSubscriptionResponse) */ {
 public:
  inline CreateSubscriptionResponse() : CreateSubscriptionResponse(nullptr) {}
  ~CreateSubscriptionResponse() override;
  explicit constexpr CreateSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSubscriptionResponse(const CreateSubscriptionResponse& from);
  CreateSubscriptionResponse(CreateSubscriptionResponse&& from) noexcept
    : CreateSubscriptionResponse() {
    *this = ::std::move(from);
  }

  inline CreateSubscriptionResponse& operator=(const CreateSubscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSubscriptionResponse& operator=(CreateSubscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSubscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSubscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const CreateSubscriptionResponse*>(
               &_CreateSubscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CreateSubscriptionResponse& a, CreateSubscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSubscriptionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSubscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateSubscriptionResponse* New() const final {
    return new CreateSubscriptionResponse();
  }

  CreateSubscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateSubscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSubscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateSubscriptionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSubscriptionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateSubscriptionResponse";
  }
  protected:
  explicit CreateSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kSubscriptionFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Subscription subscription = 1 [json_name = "subscription"];
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::payment::v1alpha1::Subscription& subscription() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Subscription* release_subscription();
  ::payment::v1alpha1::Subscription* mutable_subscription();
  void set_allocated_subscription(::payment::v1alpha1::Subscription* subscription);
  private:
  const ::payment::v1alpha1::Subscription& _internal_subscription() const;
  ::payment::v1alpha1::Subscription* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::payment::v1alpha1::Subscription* subscription);
  ::payment::v1alpha1::Subscription* unsafe_arena_release_subscription();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateSubscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Subscription* subscription_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UpdateSubscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.UpdateSubscriptionRequest) */ {
 public:
  inline UpdateSubscriptionRequest() : UpdateSubscriptionRequest(nullptr) {}
  ~UpdateSubscriptionRequest() override;
  explicit constexpr UpdateSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSubscriptionRequest(const UpdateSubscriptionRequest& from);
  UpdateSubscriptionRequest(UpdateSubscriptionRequest&& from) noexcept
    : UpdateSubscriptionRequest() {
    *this = ::std::move(from);
  }

  inline UpdateSubscriptionRequest& operator=(const UpdateSubscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSubscriptionRequest& operator=(UpdateSubscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSubscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSubscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateSubscriptionRequest*>(
               &_UpdateSubscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UpdateSubscriptionRequest& a, UpdateSubscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSubscriptionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSubscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateSubscriptionRequest* New() const final {
    return new UpdateSubscriptionRequest();
  }

  UpdateSubscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateSubscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateSubscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateSubscriptionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSubscriptionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.UpdateSubscriptionRequest";
  }
  protected:
  explicit UpdateSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionIdFieldNumber = 1,
    kOrganizationIdFieldNumber = 2,
  };
  // string subscription_id = 1 [json_name = "subscriptionId"];
  void clear_subscription_id();
  const std::string& subscription_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscription_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscription_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_subscription_id();
  void set_allocated_subscription_id(std::string* subscription_id);
  private:
  const std::string& _internal_subscription_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscription_id(const std::string& value);
  std::string* _internal_mutable_subscription_id();
  public:

  // uint32 organization_id = 2 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.UpdateSubscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscription_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UpdateSubscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.UpdateSubscriptionResponse) */ {
 public:
  inline UpdateSubscriptionResponse() : UpdateSubscriptionResponse(nullptr) {}
  ~UpdateSubscriptionResponse() override;
  explicit constexpr UpdateSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSubscriptionResponse(const UpdateSubscriptionResponse& from);
  UpdateSubscriptionResponse(UpdateSubscriptionResponse&& from) noexcept
    : UpdateSubscriptionResponse() {
    *this = ::std::move(from);
  }

  inline UpdateSubscriptionResponse& operator=(const UpdateSubscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSubscriptionResponse& operator=(UpdateSubscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSubscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSubscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateSubscriptionResponse*>(
               &_UpdateSubscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateSubscriptionResponse& a, UpdateSubscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSubscriptionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSubscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateSubscriptionResponse* New() const final {
    return new UpdateSubscriptionResponse();
  }

  UpdateSubscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateSubscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateSubscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateSubscriptionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSubscriptionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.UpdateSubscriptionResponse";
  }
  protected:
  explicit UpdateSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kCustomerFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.UpdateSubscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateProjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateProjectRequest) */ {
 public:
  inline CreateProjectRequest() : CreateProjectRequest(nullptr) {}
  ~CreateProjectRequest() override;
  explicit constexpr CreateProjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateProjectRequest(const CreateProjectRequest& from);
  CreateProjectRequest(CreateProjectRequest&& from) noexcept
    : CreateProjectRequest() {
    *this = ::std::move(from);
  }

  inline CreateProjectRequest& operator=(const CreateProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateProjectRequest& operator=(CreateProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateProjectRequest* internal_default_instance() {
    return reinterpret_cast<const CreateProjectRequest*>(
               &_CreateProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CreateProjectRequest& a, CreateProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateProjectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateProjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateProjectRequest* New() const final {
    return new CreateProjectRequest();
  }

  CreateProjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateProjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateProjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateProjectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateProjectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateProjectRequest";
  }
  protected:
  explicit CreateProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // .payment.v1alpha1.Project project = 2 [json_name = "project"];
  bool has_project() const;
  private:
  bool _internal_has_project() const;
  public:
  void clear_project();
  const ::payment::v1alpha1::Project& project() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Project* release_project();
  ::payment::v1alpha1::Project* mutable_project();
  void set_allocated_project(::payment::v1alpha1::Project* project);
  private:
  const ::payment::v1alpha1::Project& _internal_project() const;
  ::payment::v1alpha1::Project* _internal_mutable_project();
  public:
  void unsafe_arena_set_allocated_project(
      ::payment::v1alpha1::Project* project);
  ::payment::v1alpha1::Project* unsafe_arena_release_project();

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateProjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::payment::v1alpha1::Project* project_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateProjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateProjectResponse) */ {
 public:
  inline CreateProjectResponse() : CreateProjectResponse(nullptr) {}
  ~CreateProjectResponse() override;
  explicit constexpr CreateProjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateProjectResponse(const CreateProjectResponse& from);
  CreateProjectResponse(CreateProjectResponse&& from) noexcept
    : CreateProjectResponse() {
    *this = ::std::move(from);
  }

  inline CreateProjectResponse& operator=(const CreateProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateProjectResponse& operator=(CreateProjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateProjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateProjectResponse* internal_default_instance() {
    return reinterpret_cast<const CreateProjectResponse*>(
               &_CreateProjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CreateProjectResponse& a, CreateProjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateProjectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateProjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateProjectResponse* New() const final {
    return new CreateProjectResponse();
  }

  CreateProjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateProjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateProjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateProjectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateProjectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateProjectResponse";
  }
  protected:
  explicit CreateProjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateProjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateInvoiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateInvoiceRequest) */ {
 public:
  inline CreateInvoiceRequest() : CreateInvoiceRequest(nullptr) {}
  ~CreateInvoiceRequest() override;
  explicit constexpr CreateInvoiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateInvoiceRequest(const CreateInvoiceRequest& from);
  CreateInvoiceRequest(CreateInvoiceRequest&& from) noexcept
    : CreateInvoiceRequest() {
    *this = ::std::move(from);
  }

  inline CreateInvoiceRequest& operator=(const CreateInvoiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInvoiceRequest& operator=(CreateInvoiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInvoiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateInvoiceRequest* internal_default_instance() {
    return reinterpret_cast<const CreateInvoiceRequest*>(
               &_CreateInvoiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CreateInvoiceRequest& a, CreateInvoiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInvoiceRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInvoiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateInvoiceRequest* New() const final {
    return new CreateInvoiceRequest();
  }

  CreateInvoiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateInvoiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateInvoiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateInvoiceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateInvoiceRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateInvoiceRequest";
  }
  protected:
  explicit CreateInvoiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvoiceIdFieldNumber = 2,
    kYearFieldNumber = 3,
    kMonthFieldNumber = 4,
    kCustomerIdFieldNumber = 5,
    kProjectIdFieldNumber = 6,
    kStatusFieldNumber = 7,
    kOrganizationIdFieldNumber = 1,
  };
  // string invoice_id = 2 [json_name = "invoiceId"];
  void clear_invoice_id();
  const std::string& invoice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invoice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invoice_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_invoice_id();
  void set_allocated_invoice_id(std::string* invoice_id);
  private:
  const std::string& _internal_invoice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invoice_id(const std::string& value);
  std::string* _internal_mutable_invoice_id();
  public:

  // string year = 3 [json_name = "year"];
  void clear_year();
  const std::string& year() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_year(ArgT0&& arg0, ArgT... args);
  std::string* mutable_year();
  PROTOBUF_MUST_USE_RESULT std::string* release_year();
  void set_allocated_year(std::string* year);
  private:
  const std::string& _internal_year() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_year(const std::string& value);
  std::string* _internal_mutable_year();
  public:

  // string month = 4 [json_name = "month"];
  void clear_month();
  const std::string& month() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_month(ArgT0&& arg0, ArgT... args);
  std::string* mutable_month();
  PROTOBUF_MUST_USE_RESULT std::string* release_month();
  void set_allocated_month(std::string* month);
  private:
  const std::string& _internal_month() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_month(const std::string& value);
  std::string* _internal_mutable_month();
  public:

  // string customer_id = 5 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // string project_id = 6 [json_name = "projectId"];
  void clear_project_id();
  const std::string& project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_project_id();
  void set_allocated_project_id(std::string* project_id);
  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(const std::string& value);
  std::string* _internal_mutable_project_id();
  public:

  // string status = 7 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateInvoiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invoice_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr year_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr month_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateInvoiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateInvoiceResponse) */ {
 public:
  inline CreateInvoiceResponse() : CreateInvoiceResponse(nullptr) {}
  ~CreateInvoiceResponse() override;
  explicit constexpr CreateInvoiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateInvoiceResponse(const CreateInvoiceResponse& from);
  CreateInvoiceResponse(CreateInvoiceResponse&& from) noexcept
    : CreateInvoiceResponse() {
    *this = ::std::move(from);
  }

  inline CreateInvoiceResponse& operator=(const CreateInvoiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInvoiceResponse& operator=(CreateInvoiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInvoiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateInvoiceResponse* internal_default_instance() {
    return reinterpret_cast<const CreateInvoiceResponse*>(
               &_CreateInvoiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CreateInvoiceResponse& a, CreateInvoiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInvoiceResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInvoiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateInvoiceResponse* New() const final {
    return new CreateInvoiceResponse();
  }

  CreateInvoiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateInvoiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateInvoiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateInvoiceResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateInvoiceResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateInvoiceResponse";
  }
  protected:
  explicit CreateInvoiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kCustomerFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateInvoiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateCardRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateCardRequest) */ {
 public:
  inline CreateCardRequest() : CreateCardRequest(nullptr) {}
  ~CreateCardRequest() override;
  explicit constexpr CreateCardRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCardRequest(const CreateCardRequest& from);
  CreateCardRequest(CreateCardRequest&& from) noexcept
    : CreateCardRequest() {
    *this = ::std::move(from);
  }

  inline CreateCardRequest& operator=(const CreateCardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCardRequest& operator=(CreateCardRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCardRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCardRequest* internal_default_instance() {
    return reinterpret_cast<const CreateCardRequest*>(
               &_CreateCardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CreateCardRequest& a, CreateCardRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCardRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCardRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateCardRequest* New() const final {
    return new CreateCardRequest();
  }

  CreateCardRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateCardRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCardRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCardRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCardRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateCardRequest";
  }
  protected:
  explicit CreateCardRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kCardFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // .payment.v1alpha1.Card card = 3 [json_name = "card"];
  bool has_card() const;
  private:
  bool _internal_has_card() const;
  public:
  void clear_card();
  const ::payment::v1alpha1::Card& card() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Card* release_card();
  ::payment::v1alpha1::Card* mutable_card();
  void set_allocated_card(::payment::v1alpha1::Card* card);
  private:
  const ::payment::v1alpha1::Card& _internal_card() const;
  ::payment::v1alpha1::Card* _internal_mutable_card();
  public:
  void unsafe_arena_set_allocated_card(
      ::payment::v1alpha1::Card* card);
  ::payment::v1alpha1::Card* unsafe_arena_release_card();

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateCardRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::payment::v1alpha1::Card* card_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateCardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateCardResponse) */ {
 public:
  inline CreateCardResponse() : CreateCardResponse(nullptr) {}
  ~CreateCardResponse() override;
  explicit constexpr CreateCardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCardResponse(const CreateCardResponse& from);
  CreateCardResponse(CreateCardResponse&& from) noexcept
    : CreateCardResponse() {
    *this = ::std::move(from);
  }

  inline CreateCardResponse& operator=(const CreateCardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCardResponse& operator=(CreateCardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCardResponse* internal_default_instance() {
    return reinterpret_cast<const CreateCardResponse*>(
               &_CreateCardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CreateCardResponse& a, CreateCardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCardResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateCardResponse* New() const final {
    return new CreateCardResponse();
  }

  CreateCardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateCardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCardResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCardResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCardResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateCardResponse";
  }
  protected:
  explicit CreateCardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string token_id = 1 [json_name = "tokenId"];
  void clear_token_id();
  const std::string& token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_token_id();
  void set_allocated_token_id(std::string* token_id);
  private:
  const std::string& _internal_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_id(const std::string& value);
  std::string* _internal_mutable_token_id();
  public:

  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateCardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CancelSubscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CancelSubscriptionRequest) */ {
 public:
  inline CancelSubscriptionRequest() : CancelSubscriptionRequest(nullptr) {}
  ~CancelSubscriptionRequest() override;
  explicit constexpr CancelSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelSubscriptionRequest(const CancelSubscriptionRequest& from);
  CancelSubscriptionRequest(CancelSubscriptionRequest&& from) noexcept
    : CancelSubscriptionRequest() {
    *this = ::std::move(from);
  }

  inline CancelSubscriptionRequest& operator=(const CancelSubscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelSubscriptionRequest& operator=(CancelSubscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelSubscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelSubscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const CancelSubscriptionRequest*>(
               &_CancelSubscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CancelSubscriptionRequest& a, CancelSubscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelSubscriptionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelSubscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelSubscriptionRequest* New() const final {
    return new CancelSubscriptionRequest();
  }

  CancelSubscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelSubscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelSubscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CancelSubscriptionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelSubscriptionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CancelSubscriptionRequest";
  }
  protected:
  explicit CancelSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kSubscriptionIdFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // string subscription_id = 3 [json_name = "subscriptionId"];
  void clear_subscription_id();
  const std::string& subscription_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscription_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscription_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_subscription_id();
  void set_allocated_subscription_id(std::string* subscription_id);
  private:
  const std::string& _internal_subscription_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscription_id(const std::string& value);
  std::string* _internal_mutable_subscription_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CancelSubscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscription_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CancelSubscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CancelSubscriptionResponse) */ {
 public:
  inline CancelSubscriptionResponse() : CancelSubscriptionResponse(nullptr) {}
  ~CancelSubscriptionResponse() override;
  explicit constexpr CancelSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelSubscriptionResponse(const CancelSubscriptionResponse& from);
  CancelSubscriptionResponse(CancelSubscriptionResponse&& from) noexcept
    : CancelSubscriptionResponse() {
    *this = ::std::move(from);
  }

  inline CancelSubscriptionResponse& operator=(const CancelSubscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelSubscriptionResponse& operator=(CancelSubscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelSubscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelSubscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const CancelSubscriptionResponse*>(
               &_CancelSubscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CancelSubscriptionResponse& a, CancelSubscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelSubscriptionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelSubscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelSubscriptionResponse* New() const final {
    return new CancelSubscriptionResponse();
  }

  CancelSubscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelSubscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelSubscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CancelSubscriptionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelSubscriptionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CancelSubscriptionResponse";
  }
  protected:
  explicit CancelSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CancelSubscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateCustomerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateCustomerRequest) */ {
 public:
  inline CreateCustomerRequest() : CreateCustomerRequest(nullptr) {}
  ~CreateCustomerRequest() override;
  explicit constexpr CreateCustomerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCustomerRequest(const CreateCustomerRequest& from);
  CreateCustomerRequest(CreateCustomerRequest&& from) noexcept
    : CreateCustomerRequest() {
    *this = ::std::move(from);
  }

  inline CreateCustomerRequest& operator=(const CreateCustomerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCustomerRequest& operator=(CreateCustomerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCustomerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCustomerRequest* internal_default_instance() {
    return reinterpret_cast<const CreateCustomerRequest*>(
               &_CreateCustomerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CreateCustomerRequest& a, CreateCustomerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCustomerRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCustomerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateCustomerRequest* New() const final {
    return new CreateCustomerRequest();
  }

  CreateCustomerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateCustomerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCustomerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCustomerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCustomerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateCustomerRequest";
  }
  protected:
  explicit CreateCustomerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerFieldNumber = 1,
  };
  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateCustomerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateCustomerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateCustomerResponse) */ {
 public:
  inline CreateCustomerResponse() : CreateCustomerResponse(nullptr) {}
  ~CreateCustomerResponse() override;
  explicit constexpr CreateCustomerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCustomerResponse(const CreateCustomerResponse& from);
  CreateCustomerResponse(CreateCustomerResponse&& from) noexcept
    : CreateCustomerResponse() {
    *this = ::std::move(from);
  }

  inline CreateCustomerResponse& operator=(const CreateCustomerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCustomerResponse& operator=(CreateCustomerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCustomerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCustomerResponse* internal_default_instance() {
    return reinterpret_cast<const CreateCustomerResponse*>(
               &_CreateCustomerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CreateCustomerResponse& a, CreateCustomerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCustomerResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCustomerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateCustomerResponse* New() const final {
    return new CreateCustomerResponse();
  }

  CreateCustomerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateCustomerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCustomerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCustomerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCustomerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateCustomerResponse";
  }
  protected:
  explicit CreateCustomerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string customer_id = 1 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateCustomerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreatePaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreatePaymentRequest) */ {
 public:
  inline CreatePaymentRequest() : CreatePaymentRequest(nullptr) {}
  ~CreatePaymentRequest() override;
  explicit constexpr CreatePaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatePaymentRequest(const CreatePaymentRequest& from);
  CreatePaymentRequest(CreatePaymentRequest&& from) noexcept
    : CreatePaymentRequest() {
    *this = ::std::move(from);
  }

  inline CreatePaymentRequest& operator=(const CreatePaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePaymentRequest& operator=(CreatePaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePaymentRequest* internal_default_instance() {
    return reinterpret_cast<const CreatePaymentRequest*>(
               &_CreatePaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CreatePaymentRequest& a, CreatePaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatePaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreatePaymentRequest* New() const final {
    return new CreatePaymentRequest();
  }

  CreatePaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreatePaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatePaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreatePaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreatePaymentRequest";
  }
  protected:
  explicit CreatePaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kPaymentFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // .payment.v1alpha1.Payment payment = 3 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::Payment& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Payment* release_payment();
  ::payment::v1alpha1::Payment* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::Payment* payment);
  private:
  const ::payment::v1alpha1::Payment& _internal_payment() const;
  ::payment::v1alpha1::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::Payment* payment);
  ::payment::v1alpha1::Payment* unsafe_arena_release_payment();

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreatePaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::payment::v1alpha1::Payment* payment_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreatePaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreatePaymentResponse) */ {
 public:
  inline CreatePaymentResponse() : CreatePaymentResponse(nullptr) {}
  ~CreatePaymentResponse() override;
  explicit constexpr CreatePaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatePaymentResponse(const CreatePaymentResponse& from);
  CreatePaymentResponse(CreatePaymentResponse&& from) noexcept
    : CreatePaymentResponse() {
    *this = ::std::move(from);
  }

  inline CreatePaymentResponse& operator=(const CreatePaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePaymentResponse& operator=(CreatePaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePaymentResponse* internal_default_instance() {
    return reinterpret_cast<const CreatePaymentResponse*>(
               &_CreatePaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CreatePaymentResponse& a, CreatePaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatePaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreatePaymentResponse* New() const final {
    return new CreatePaymentResponse();
  }

  CreatePaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreatePaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatePaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreatePaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreatePaymentResponse";
  }
  protected:
  explicit CreatePaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string card_id = 1 [json_name = "cardId"];
  void clear_card_id();
  const std::string& card_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_id();
  void set_allocated_card_id(std::string* card_id);
  private:
  const std::string& _internal_card_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_id(const std::string& value);
  std::string* _internal_mutable_card_id();
  public:

  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreatePaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeletePaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeletePaymentRequest) */ {
 public:
  inline DeletePaymentRequest() : DeletePaymentRequest(nullptr) {}
  ~DeletePaymentRequest() override;
  explicit constexpr DeletePaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePaymentRequest(const DeletePaymentRequest& from);
  DeletePaymentRequest(DeletePaymentRequest&& from) noexcept
    : DeletePaymentRequest() {
    *this = ::std::move(from);
  }

  inline DeletePaymentRequest& operator=(const DeletePaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePaymentRequest& operator=(DeletePaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePaymentRequest* internal_default_instance() {
    return reinterpret_cast<const DeletePaymentRequest*>(
               &_DeletePaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(DeletePaymentRequest& a, DeletePaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeletePaymentRequest* New() const final {
    return new DeletePaymentRequest();
  }

  DeletePaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeletePaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeletePaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeletePaymentRequest";
  }
  protected:
  explicit DeletePaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kCardIdFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // string card_id = 3 [json_name = "cardId"];
  void clear_card_id();
  const std::string& card_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_id();
  void set_allocated_card_id(std::string* card_id);
  private:
  const std::string& _internal_card_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_id(const std::string& value);
  std::string* _internal_mutable_card_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeletePaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeletePaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeletePaymentResponse) */ {
 public:
  inline DeletePaymentResponse() : DeletePaymentResponse(nullptr) {}
  ~DeletePaymentResponse() override;
  explicit constexpr DeletePaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePaymentResponse(const DeletePaymentResponse& from);
  DeletePaymentResponse(DeletePaymentResponse&& from) noexcept
    : DeletePaymentResponse() {
    *this = ::std::move(from);
  }

  inline DeletePaymentResponse& operator=(const DeletePaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePaymentResponse& operator=(DeletePaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePaymentResponse* internal_default_instance() {
    return reinterpret_cast<const DeletePaymentResponse*>(
               &_DeletePaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(DeletePaymentResponse& a, DeletePaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeletePaymentResponse* New() const final {
    return new DeletePaymentResponse();
  }

  DeletePaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeletePaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeletePaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeletePaymentResponse";
  }
  protected:
  explicit DeletePaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kMsgErrorFieldNumber = 2,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string msg_error = 2 [json_name = "msgError"];
  void clear_msg_error();
  const std::string& msg_error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg_error();
  void set_allocated_msg_error(std::string* msg_error);
  private:
  const std::string& _internal_msg_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_error(const std::string& value);
  std::string* _internal_mutable_msg_error();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeletePaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetPaymentRequest) */ {
 public:
  inline GetPaymentRequest() : GetPaymentRequest(nullptr) {}
  ~GetPaymentRequest() override;
  explicit constexpr GetPaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaymentRequest(const GetPaymentRequest& from);
  GetPaymentRequest(GetPaymentRequest&& from) noexcept
    : GetPaymentRequest() {
    *this = ::std::move(from);
  }

  inline GetPaymentRequest& operator=(const GetPaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaymentRequest& operator=(GetPaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaymentRequest* internal_default_instance() {
    return reinterpret_cast<const GetPaymentRequest*>(
               &_GetPaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(GetPaymentRequest& a, GetPaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPaymentRequest* New() const final {
    return new GetPaymentRequest();
  }

  GetPaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetPaymentRequest";
  }
  protected:
  explicit GetPaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kCardIdFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // string card_id = 3 [json_name = "cardId"];
  void clear_card_id();
  const std::string& card_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_id();
  void set_allocated_card_id(std::string* card_id);
  private:
  const std::string& _internal_card_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_id(const std::string& value);
  std::string* _internal_mutable_card_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetPaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetPaymentResponse) */ {
 public:
  inline GetPaymentResponse() : GetPaymentResponse(nullptr) {}
  ~GetPaymentResponse() override;
  explicit constexpr GetPaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaymentResponse(const GetPaymentResponse& from);
  GetPaymentResponse(GetPaymentResponse&& from) noexcept
    : GetPaymentResponse() {
    *this = ::std::move(from);
  }

  inline GetPaymentResponse& operator=(const GetPaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaymentResponse& operator=(GetPaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaymentResponse* internal_default_instance() {
    return reinterpret_cast<const GetPaymentResponse*>(
               &_GetPaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(GetPaymentResponse& a, GetPaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPaymentResponse* New() const final {
    return new GetPaymentResponse();
  }

  GetPaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetPaymentResponse";
  }
  protected:
  explicit GetPaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPaymentFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::Payment& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Payment* release_payment();
  ::payment::v1alpha1::Payment* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::Payment* payment);
  private:
  const ::payment::v1alpha1::Payment& _internal_payment() const;
  ::payment::v1alpha1::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::Payment* payment);
  ::payment::v1alpha1::Payment* unsafe_arena_release_payment();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetPaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Payment* payment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListPaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ListPaymentRequest) */ {
 public:
  inline ListPaymentRequest() : ListPaymentRequest(nullptr) {}
  ~ListPaymentRequest() override;
  explicit constexpr ListPaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPaymentRequest(const ListPaymentRequest& from);
  ListPaymentRequest(ListPaymentRequest&& from) noexcept
    : ListPaymentRequest() {
    *this = ::std::move(from);
  }

  inline ListPaymentRequest& operator=(const ListPaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPaymentRequest& operator=(ListPaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPaymentRequest* internal_default_instance() {
    return reinterpret_cast<const ListPaymentRequest*>(
               &_ListPaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ListPaymentRequest& a, ListPaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPaymentRequest* New() const final {
    return new ListPaymentRequest();
  }

  ListPaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ListPaymentRequest";
  }
  protected:
  explicit ListPaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ListPaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListPaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ListPaymentResponse) */ {
 public:
  inline ListPaymentResponse() : ListPaymentResponse(nullptr) {}
  ~ListPaymentResponse() override;
  explicit constexpr ListPaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPaymentResponse(const ListPaymentResponse& from);
  ListPaymentResponse(ListPaymentResponse&& from) noexcept
    : ListPaymentResponse() {
    *this = ::std::move(from);
  }

  inline ListPaymentResponse& operator=(const ListPaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPaymentResponse& operator=(ListPaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPaymentResponse* internal_default_instance() {
    return reinterpret_cast<const ListPaymentResponse*>(
               &_ListPaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ListPaymentResponse& a, ListPaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPaymentResponse* New() const final {
    return new ListPaymentResponse();
  }

  ListPaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ListPaymentResponse";
  }
  protected:
  explicit ListPaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kPaymentListFieldNumber = 1,
  };
  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .payment.v1alpha1.PaymentList payment_list = 1 [json_name = "paymentList"];
  bool has_payment_list() const;
  private:
  bool _internal_has_payment_list() const;
  public:
  void clear_payment_list();
  const ::payment::v1alpha1::PaymentList& payment_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::PaymentList* release_payment_list();
  ::payment::v1alpha1::PaymentList* mutable_payment_list();
  void set_allocated_payment_list(::payment::v1alpha1::PaymentList* payment_list);
  private:
  const ::payment::v1alpha1::PaymentList& _internal_payment_list() const;
  ::payment::v1alpha1::PaymentList* _internal_mutable_payment_list();
  public:
  void unsafe_arena_set_allocated_payment_list(
      ::payment::v1alpha1::PaymentList* payment_list);
  ::payment::v1alpha1::PaymentList* unsafe_arena_release_payment_list();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ListPaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  ::payment::v1alpha1::PaymentList* payment_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListSubscriptionItemsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ListSubscriptionItemsRequest) */ {
 public:
  inline ListSubscriptionItemsRequest() : ListSubscriptionItemsRequest(nullptr) {}
  ~ListSubscriptionItemsRequest() override;
  explicit constexpr ListSubscriptionItemsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListSubscriptionItemsRequest(const ListSubscriptionItemsRequest& from);
  ListSubscriptionItemsRequest(ListSubscriptionItemsRequest&& from) noexcept
    : ListSubscriptionItemsRequest() {
    *this = ::std::move(from);
  }

  inline ListSubscriptionItemsRequest& operator=(const ListSubscriptionItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSubscriptionItemsRequest& operator=(ListSubscriptionItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSubscriptionItemsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSubscriptionItemsRequest* internal_default_instance() {
    return reinterpret_cast<const ListSubscriptionItemsRequest*>(
               &_ListSubscriptionItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ListSubscriptionItemsRequest& a, ListSubscriptionItemsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSubscriptionItemsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSubscriptionItemsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListSubscriptionItemsRequest* New() const final {
    return new ListSubscriptionItemsRequest();
  }

  ListSubscriptionItemsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListSubscriptionItemsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListSubscriptionItemsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListSubscriptionItemsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListSubscriptionItemsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ListSubscriptionItemsRequest";
  }
  protected:
  explicit ListSubscriptionItemsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string subscription_id = 2 [json_name = "subscriptionId"];
  void clear_subscription_id();
  const std::string& subscription_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscription_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscription_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_subscription_id();
  void set_allocated_subscription_id(std::string* subscription_id);
  private:
  const std::string& _internal_subscription_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscription_id(const std::string& value);
  std::string* _internal_mutable_subscription_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ListSubscriptionItemsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscription_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListSubscriptionItemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ListSubscriptionItemsResponse) */ {
 public:
  inline ListSubscriptionItemsResponse() : ListSubscriptionItemsResponse(nullptr) {}
  ~ListSubscriptionItemsResponse() override;
  explicit constexpr ListSubscriptionItemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListSubscriptionItemsResponse(const ListSubscriptionItemsResponse& from);
  ListSubscriptionItemsResponse(ListSubscriptionItemsResponse&& from) noexcept
    : ListSubscriptionItemsResponse() {
    *this = ::std::move(from);
  }

  inline ListSubscriptionItemsResponse& operator=(const ListSubscriptionItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSubscriptionItemsResponse& operator=(ListSubscriptionItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSubscriptionItemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSubscriptionItemsResponse* internal_default_instance() {
    return reinterpret_cast<const ListSubscriptionItemsResponse*>(
               &_ListSubscriptionItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ListSubscriptionItemsResponse& a, ListSubscriptionItemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSubscriptionItemsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSubscriptionItemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListSubscriptionItemsResponse* New() const final {
    return new ListSubscriptionItemsResponse();
  }

  ListSubscriptionItemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListSubscriptionItemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListSubscriptionItemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListSubscriptionItemsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListSubscriptionItemsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ListSubscriptionItemsResponse";
  }
  protected:
  explicit ListSubscriptionItemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 3,
    kCustomerFieldNumber = 1,
    kSubscriptionItemsListFieldNumber = 2,
  };
  // string status = 3 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // .payment.v1alpha1.SubscriptionItemsList subscription_items_list = 2 [json_name = "subscriptionItemsList"];
  bool has_subscription_items_list() const;
  private:
  bool _internal_has_subscription_items_list() const;
  public:
  void clear_subscription_items_list();
  const ::payment::v1alpha1::SubscriptionItemsList& subscription_items_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::SubscriptionItemsList* release_subscription_items_list();
  ::payment::v1alpha1::SubscriptionItemsList* mutable_subscription_items_list();
  void set_allocated_subscription_items_list(::payment::v1alpha1::SubscriptionItemsList* subscription_items_list);
  private:
  const ::payment::v1alpha1::SubscriptionItemsList& _internal_subscription_items_list() const;
  ::payment::v1alpha1::SubscriptionItemsList* _internal_mutable_subscription_items_list();
  public:
  void unsafe_arena_set_allocated_subscription_items_list(
      ::payment::v1alpha1::SubscriptionItemsList* subscription_items_list);
  ::payment::v1alpha1::SubscriptionItemsList* unsafe_arena_release_subscription_items_list();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ListSubscriptionItemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  ::payment::v1alpha1::SubscriptionItemsList* subscription_items_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListProjectsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ListProjectsRequest) */ {
 public:
  inline ListProjectsRequest() : ListProjectsRequest(nullptr) {}
  ~ListProjectsRequest() override;
  explicit constexpr ListProjectsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListProjectsRequest(const ListProjectsRequest& from);
  ListProjectsRequest(ListProjectsRequest&& from) noexcept
    : ListProjectsRequest() {
    *this = ::std::move(from);
  }

  inline ListProjectsRequest& operator=(const ListProjectsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListProjectsRequest& operator=(ListProjectsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListProjectsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListProjectsRequest* internal_default_instance() {
    return reinterpret_cast<const ListProjectsRequest*>(
               &_ListProjectsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ListProjectsRequest& a, ListProjectsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListProjectsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListProjectsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListProjectsRequest* New() const final {
    return new ListProjectsRequest();
  }

  ListProjectsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListProjectsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListProjectsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListProjectsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListProjectsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ListProjectsRequest";
  }
  protected:
  explicit ListProjectsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ListProjectsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListProjectsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ListProjectsResponse) */ {
 public:
  inline ListProjectsResponse() : ListProjectsResponse(nullptr) {}
  ~ListProjectsResponse() override;
  explicit constexpr ListProjectsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListProjectsResponse(const ListProjectsResponse& from);
  ListProjectsResponse(ListProjectsResponse&& from) noexcept
    : ListProjectsResponse() {
    *this = ::std::move(from);
  }

  inline ListProjectsResponse& operator=(const ListProjectsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListProjectsResponse& operator=(ListProjectsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListProjectsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListProjectsResponse* internal_default_instance() {
    return reinterpret_cast<const ListProjectsResponse*>(
               &_ListProjectsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ListProjectsResponse& a, ListProjectsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListProjectsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListProjectsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListProjectsResponse* New() const final {
    return new ListProjectsResponse();
  }

  ListProjectsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListProjectsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListProjectsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListProjectsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListProjectsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ListProjectsResponse";
  }
  protected:
  explicit ListProjectsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kCustomerFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ListProjectsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetProjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetProjectRequest) */ {
 public:
  inline GetProjectRequest() : GetProjectRequest(nullptr) {}
  ~GetProjectRequest() override;
  explicit constexpr GetProjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProjectRequest(const GetProjectRequest& from);
  GetProjectRequest(GetProjectRequest&& from) noexcept
    : GetProjectRequest() {
    *this = ::std::move(from);
  }

  inline GetProjectRequest& operator=(const GetProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProjectRequest& operator=(GetProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProjectRequest* internal_default_instance() {
    return reinterpret_cast<const GetProjectRequest*>(
               &_GetProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(GetProjectRequest& a, GetProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProjectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProjectRequest* New() const final {
    return new GetProjectRequest();
  }

  GetProjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetProjectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProjectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetProjectRequest";
  }
  protected:
  explicit GetProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
    kProjectIdFieldNumber = 2,
  };
  // string organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string project_id = 2 [json_name = "projectId"];
  void clear_project_id();
  const std::string& project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_project_id();
  void set_allocated_project_id(std::string* project_id);
  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(const std::string& value);
  std::string* _internal_mutable_project_id();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetProjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetProjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetProjectResponse) */ {
 public:
  inline GetProjectResponse() : GetProjectResponse(nullptr) {}
  ~GetProjectResponse() override;
  explicit constexpr GetProjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProjectResponse(const GetProjectResponse& from);
  GetProjectResponse(GetProjectResponse&& from) noexcept
    : GetProjectResponse() {
    *this = ::std::move(from);
  }

  inline GetProjectResponse& operator=(const GetProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProjectResponse& operator=(GetProjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProjectResponse* internal_default_instance() {
    return reinterpret_cast<const GetProjectResponse*>(
               &_GetProjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(GetProjectResponse& a, GetProjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProjectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProjectResponse* New() const final {
    return new GetProjectResponse();
  }

  GetProjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetProjectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProjectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetProjectResponse";
  }
  protected:
  explicit GetProjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kCustomerFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetProjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteProjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeleteProjectRequest) */ {
 public:
  inline DeleteProjectRequest() : DeleteProjectRequest(nullptr) {}
  ~DeleteProjectRequest() override;
  explicit constexpr DeleteProjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteProjectRequest(const DeleteProjectRequest& from);
  DeleteProjectRequest(DeleteProjectRequest&& from) noexcept
    : DeleteProjectRequest() {
    *this = ::std::move(from);
  }

  inline DeleteProjectRequest& operator=(const DeleteProjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteProjectRequest& operator=(DeleteProjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteProjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteProjectRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteProjectRequest*>(
               &_DeleteProjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(DeleteProjectRequest& a, DeleteProjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteProjectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteProjectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteProjectRequest* New() const final {
    return new DeleteProjectRequest();
  }

  DeleteProjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteProjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteProjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteProjectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteProjectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeleteProjectRequest";
  }
  protected:
  explicit DeleteProjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectIdFieldNumber = 2,
    kProjectFieldNumber = 3,
    kOrganizationIdFieldNumber = 1,
  };
  // string project_id = 2 [json_name = "projectId"];
  void clear_project_id();
  const std::string& project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_project_id();
  void set_allocated_project_id(std::string* project_id);
  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(const std::string& value);
  std::string* _internal_mutable_project_id();
  public:

  // .payment.v1alpha1.Project project = 3 [json_name = "project"];
  bool has_project() const;
  private:
  bool _internal_has_project() const;
  public:
  void clear_project();
  const ::payment::v1alpha1::Project& project() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Project* release_project();
  ::payment::v1alpha1::Project* mutable_project();
  void set_allocated_project(::payment::v1alpha1::Project* project);
  private:
  const ::payment::v1alpha1::Project& _internal_project() const;
  ::payment::v1alpha1::Project* _internal_mutable_project();
  public:
  void unsafe_arena_set_allocated_project(
      ::payment::v1alpha1::Project* project);
  ::payment::v1alpha1::Project* unsafe_arena_release_project();

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeleteProjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_id_;
  ::payment::v1alpha1::Project* project_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteProjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeleteProjectResponse) */ {
 public:
  inline DeleteProjectResponse() : DeleteProjectResponse(nullptr) {}
  ~DeleteProjectResponse() override;
  explicit constexpr DeleteProjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteProjectResponse(const DeleteProjectResponse& from);
  DeleteProjectResponse(DeleteProjectResponse&& from) noexcept
    : DeleteProjectResponse() {
    *this = ::std::move(from);
  }

  inline DeleteProjectResponse& operator=(const DeleteProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteProjectResponse& operator=(DeleteProjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteProjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteProjectResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteProjectResponse*>(
               &_DeleteProjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(DeleteProjectResponse& a, DeleteProjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteProjectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteProjectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteProjectResponse* New() const final {
    return new DeleteProjectResponse();
  }

  DeleteProjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteProjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteProjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteProjectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteProjectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeleteProjectResponse";
  }
  protected:
  explicit DeleteProjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeleteProjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetDefaultPaymentMethodRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.SetDefaultPaymentMethodRequest) */ {
 public:
  inline SetDefaultPaymentMethodRequest() : SetDefaultPaymentMethodRequest(nullptr) {}
  ~SetDefaultPaymentMethodRequest() override;
  explicit constexpr SetDefaultPaymentMethodRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetDefaultPaymentMethodRequest(const SetDefaultPaymentMethodRequest& from);
  SetDefaultPaymentMethodRequest(SetDefaultPaymentMethodRequest&& from) noexcept
    : SetDefaultPaymentMethodRequest() {
    *this = ::std::move(from);
  }

  inline SetDefaultPaymentMethodRequest& operator=(const SetDefaultPaymentMethodRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetDefaultPaymentMethodRequest& operator=(SetDefaultPaymentMethodRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetDefaultPaymentMethodRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetDefaultPaymentMethodRequest* internal_default_instance() {
    return reinterpret_cast<const SetDefaultPaymentMethodRequest*>(
               &_SetDefaultPaymentMethodRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(SetDefaultPaymentMethodRequest& a, SetDefaultPaymentMethodRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetDefaultPaymentMethodRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetDefaultPaymentMethodRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetDefaultPaymentMethodRequest* New() const final {
    return new SetDefaultPaymentMethodRequest();
  }

  SetDefaultPaymentMethodRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetDefaultPaymentMethodRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetDefaultPaymentMethodRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetDefaultPaymentMethodRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetDefaultPaymentMethodRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.SetDefaultPaymentMethodRequest";
  }
  protected:
  explicit SetDefaultPaymentMethodRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string card_id = 2 [json_name = "cardId"];
  void clear_card_id();
  const std::string& card_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_id();
  void set_allocated_card_id(std::string* card_id);
  private:
  const std::string& _internal_card_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_id(const std::string& value);
  std::string* _internal_mutable_card_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.SetDefaultPaymentMethodRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SetDefaultPaymentMethodResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.SetDefaultPaymentMethodResponse) */ {
 public:
  inline SetDefaultPaymentMethodResponse() : SetDefaultPaymentMethodResponse(nullptr) {}
  ~SetDefaultPaymentMethodResponse() override;
  explicit constexpr SetDefaultPaymentMethodResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetDefaultPaymentMethodResponse(const SetDefaultPaymentMethodResponse& from);
  SetDefaultPaymentMethodResponse(SetDefaultPaymentMethodResponse&& from) noexcept
    : SetDefaultPaymentMethodResponse() {
    *this = ::std::move(from);
  }

  inline SetDefaultPaymentMethodResponse& operator=(const SetDefaultPaymentMethodResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetDefaultPaymentMethodResponse& operator=(SetDefaultPaymentMethodResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetDefaultPaymentMethodResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetDefaultPaymentMethodResponse* internal_default_instance() {
    return reinterpret_cast<const SetDefaultPaymentMethodResponse*>(
               &_SetDefaultPaymentMethodResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(SetDefaultPaymentMethodResponse& a, SetDefaultPaymentMethodResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetDefaultPaymentMethodResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetDefaultPaymentMethodResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetDefaultPaymentMethodResponse* New() const final {
    return new SetDefaultPaymentMethodResponse();
  }

  SetDefaultPaymentMethodResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetDefaultPaymentMethodResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetDefaultPaymentMethodResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetDefaultPaymentMethodResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetDefaultPaymentMethodResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.SetDefaultPaymentMethodResponse";
  }
  protected:
  explicit SetDefaultPaymentMethodResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.SetDefaultPaymentMethodResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StopProjectRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void StopProjectRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StopProjectRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StopProjectRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.StopProjectRequest.organization_id)
  return _internal_organization_id();
}
inline void StopProjectRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void StopProjectRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.StopProjectRequest.organization_id)
}

// uint32 project_id = 2 [json_name = "projectId"];
inline void StopProjectRequest::clear_project_id() {
  project_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StopProjectRequest::_internal_project_id() const {
  return project_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StopProjectRequest::project_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.StopProjectRequest.project_id)
  return _internal_project_id();
}
inline void StopProjectRequest::_internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  project_id_ = value;
}
inline void StopProjectRequest::set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_project_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.StopProjectRequest.project_id)
}

// -------------------------------------------------------------------

// StopProjectResponse

// string status = 1 [json_name = "status"];
inline void StopProjectResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& StopProjectResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.StopProjectResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopProjectResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.StopProjectResponse.status)
}
inline std::string* StopProjectResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.StopProjectResponse.status)
  return _s;
}
inline const std::string& StopProjectResponse::_internal_status() const {
  return status_.Get();
}
inline void StopProjectResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StopProjectResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StopProjectResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.StopProjectResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StopProjectResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.StopProjectResponse.status)
}

// -------------------------------------------------------------------

// InvoiceFilterRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void InvoiceFilterRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InvoiceFilterRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InvoiceFilterRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.organization_id)
  return _internal_organization_id();
}
inline void InvoiceFilterRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void InvoiceFilterRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.organization_id)
}

// string invoice_id = 2 [json_name = "invoiceId"];
inline void InvoiceFilterRequest::clear_invoice_id() {
  invoice_id_.ClearToEmpty();
}
inline const std::string& InvoiceFilterRequest::invoice_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.invoice_id)
  return _internal_invoice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceFilterRequest::set_invoice_id(ArgT0&& arg0, ArgT... args) {
 
 invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.invoice_id)
}
inline std::string* InvoiceFilterRequest::mutable_invoice_id() {
  std::string* _s = _internal_mutable_invoice_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterRequest.invoice_id)
  return _s;
}
inline const std::string& InvoiceFilterRequest::_internal_invoice_id() const {
  return invoice_id_.Get();
}
inline void InvoiceFilterRequest::_internal_set_invoice_id(const std::string& value) {
  
  invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::_internal_mutable_invoice_id() {
  
  return invoice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::release_invoice_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterRequest.invoice_id)
  return invoice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvoiceFilterRequest::set_allocated_invoice_id(std::string* invoice_id) {
  if (invoice_id != nullptr) {
    
  } else {
    
  }
  invoice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invoice_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterRequest.invoice_id)
}

// string year = 3 [json_name = "year"];
inline void InvoiceFilterRequest::clear_year() {
  year_.ClearToEmpty();
}
inline const std::string& InvoiceFilterRequest::year() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.year)
  return _internal_year();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceFilterRequest::set_year(ArgT0&& arg0, ArgT... args) {
 
 year_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.year)
}
inline std::string* InvoiceFilterRequest::mutable_year() {
  std::string* _s = _internal_mutable_year();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterRequest.year)
  return _s;
}
inline const std::string& InvoiceFilterRequest::_internal_year() const {
  return year_.Get();
}
inline void InvoiceFilterRequest::_internal_set_year(const std::string& value) {
  
  year_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::_internal_mutable_year() {
  
  return year_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::release_year() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterRequest.year)
  return year_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvoiceFilterRequest::set_allocated_year(std::string* year) {
  if (year != nullptr) {
    
  } else {
    
  }
  year_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), year,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterRequest.year)
}

// string month = 4 [json_name = "month"];
inline void InvoiceFilterRequest::clear_month() {
  month_.ClearToEmpty();
}
inline const std::string& InvoiceFilterRequest::month() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.month)
  return _internal_month();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceFilterRequest::set_month(ArgT0&& arg0, ArgT... args) {
 
 month_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.month)
}
inline std::string* InvoiceFilterRequest::mutable_month() {
  std::string* _s = _internal_mutable_month();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterRequest.month)
  return _s;
}
inline const std::string& InvoiceFilterRequest::_internal_month() const {
  return month_.Get();
}
inline void InvoiceFilterRequest::_internal_set_month(const std::string& value) {
  
  month_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::_internal_mutable_month() {
  
  return month_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::release_month() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterRequest.month)
  return month_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvoiceFilterRequest::set_allocated_month(std::string* month) {
  if (month != nullptr) {
    
  } else {
    
  }
  month_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), month,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterRequest.month)
}

// string customer_id = 5 [json_name = "customerId"];
inline void InvoiceFilterRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& InvoiceFilterRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceFilterRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.customer_id)
}
inline std::string* InvoiceFilterRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterRequest.customer_id)
  return _s;
}
inline const std::string& InvoiceFilterRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void InvoiceFilterRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvoiceFilterRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterRequest.customer_id)
}

// string project_id = 6 [json_name = "projectId"];
inline void InvoiceFilterRequest::clear_project_id() {
  project_id_.ClearToEmpty();
}
inline const std::string& InvoiceFilterRequest::project_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.project_id)
  return _internal_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceFilterRequest::set_project_id(ArgT0&& arg0, ArgT... args) {
 
 project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.project_id)
}
inline std::string* InvoiceFilterRequest::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterRequest.project_id)
  return _s;
}
inline const std::string& InvoiceFilterRequest::_internal_project_id() const {
  return project_id_.Get();
}
inline void InvoiceFilterRequest::_internal_set_project_id(const std::string& value) {
  
  project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::_internal_mutable_project_id() {
  
  return project_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::release_project_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterRequest.project_id)
  return project_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvoiceFilterRequest::set_allocated_project_id(std::string* project_id) {
  if (project_id != nullptr) {
    
  } else {
    
  }
  project_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterRequest.project_id)
}

// double cpu = 7 [json_name = "cpu"];
inline void InvoiceFilterRequest::clear_cpu() {
  cpu_ = 0;
}
inline double InvoiceFilterRequest::_internal_cpu() const {
  return cpu_;
}
inline double InvoiceFilterRequest::cpu() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.cpu)
  return _internal_cpu();
}
inline void InvoiceFilterRequest::_internal_set_cpu(double value) {
  
  cpu_ = value;
}
inline void InvoiceFilterRequest::set_cpu(double value) {
  _internal_set_cpu(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.cpu)
}

// double ram = 8 [json_name = "ram"];
inline void InvoiceFilterRequest::clear_ram() {
  ram_ = 0;
}
inline double InvoiceFilterRequest::_internal_ram() const {
  return ram_;
}
inline double InvoiceFilterRequest::ram() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.ram)
  return _internal_ram();
}
inline void InvoiceFilterRequest::_internal_set_ram(double value) {
  
  ram_ = value;
}
inline void InvoiceFilterRequest::set_ram(double value) {
  _internal_set_ram(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.ram)
}

// double pipeline = 9 [json_name = "pipeline"];
inline void InvoiceFilterRequest::clear_pipeline() {
  pipeline_ = 0;
}
inline double InvoiceFilterRequest::_internal_pipeline() const {
  return pipeline_;
}
inline double InvoiceFilterRequest::pipeline() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.pipeline)
  return _internal_pipeline();
}
inline void InvoiceFilterRequest::_internal_set_pipeline(double value) {
  
  pipeline_ = value;
}
inline void InvoiceFilterRequest::set_pipeline(double value) {
  _internal_set_pipeline(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.pipeline)
}

// .payment.v1alpha1.CustomerList customer_list = 10 [json_name = "customerList"];
inline bool InvoiceFilterRequest::_internal_has_customer_list() const {
  return this != internal_default_instance() && customer_list_ != nullptr;
}
inline bool InvoiceFilterRequest::has_customer_list() const {
  return _internal_has_customer_list();
}
inline const ::payment::v1alpha1::CustomerList& InvoiceFilterRequest::_internal_customer_list() const {
  const ::payment::v1alpha1::CustomerList* p = customer_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::CustomerList&>(
      ::payment::v1alpha1::_CustomerList_default_instance_);
}
inline const ::payment::v1alpha1::CustomerList& InvoiceFilterRequest::customer_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.customer_list)
  return _internal_customer_list();
}
inline void InvoiceFilterRequest::unsafe_arena_set_allocated_customer_list(
    ::payment::v1alpha1::CustomerList* customer_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_list_);
  }
  customer_list_ = customer_list;
  if (customer_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.InvoiceFilterRequest.customer_list)
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterRequest::release_customer_list() {
  
  ::payment::v1alpha1::CustomerList* temp = customer_list_;
  customer_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterRequest::unsafe_arena_release_customer_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterRequest.customer_list)
  
  ::payment::v1alpha1::CustomerList* temp = customer_list_;
  customer_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterRequest::_internal_mutable_customer_list() {
  
  if (customer_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::CustomerList>(GetArenaForAllocation());
    customer_list_ = p;
  }
  return customer_list_;
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterRequest::mutable_customer_list() {
  ::payment::v1alpha1::CustomerList* _msg = _internal_mutable_customer_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterRequest.customer_list)
  return _msg;
}
inline void InvoiceFilterRequest::set_allocated_customer_list(::payment::v1alpha1::CustomerList* customer_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_list_);
  }
  if (customer_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_list));
    if (message_arena != submessage_arena) {
      customer_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer_list, submessage_arena);
    }
    
  } else {
    
  }
  customer_list_ = customer_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterRequest.customer_list)
}

// -------------------------------------------------------------------

// InvoiceFilterResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool InvoiceFilterResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool InvoiceFilterResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& InvoiceFilterResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& InvoiceFilterResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterResponse.customer)
  return _internal_customer();
}
inline void InvoiceFilterResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.InvoiceFilterResponse.customer)
}
inline ::payment::v1alpha1::Customer* InvoiceFilterResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* InvoiceFilterResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* InvoiceFilterResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* InvoiceFilterResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterResponse.customer)
  return _msg;
}
inline void InvoiceFilterResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterResponse.customer)
}

// .payment.v1alpha1.BilingList biling_list = 2 [json_name = "bilingList"];
inline bool InvoiceFilterResponse::_internal_has_biling_list() const {
  return this != internal_default_instance() && biling_list_ != nullptr;
}
inline bool InvoiceFilterResponse::has_biling_list() const {
  return _internal_has_biling_list();
}
inline const ::payment::v1alpha1::BilingList& InvoiceFilterResponse::_internal_biling_list() const {
  const ::payment::v1alpha1::BilingList* p = biling_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::BilingList&>(
      ::payment::v1alpha1::_BilingList_default_instance_);
}
inline const ::payment::v1alpha1::BilingList& InvoiceFilterResponse::biling_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterResponse.biling_list)
  return _internal_biling_list();
}
inline void InvoiceFilterResponse::unsafe_arena_set_allocated_biling_list(
    ::payment::v1alpha1::BilingList* biling_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling_list_);
  }
  biling_list_ = biling_list;
  if (biling_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.InvoiceFilterResponse.biling_list)
}
inline ::payment::v1alpha1::BilingList* InvoiceFilterResponse::release_biling_list() {
  
  ::payment::v1alpha1::BilingList* temp = biling_list_;
  biling_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::BilingList* InvoiceFilterResponse::unsafe_arena_release_biling_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterResponse.biling_list)
  
  ::payment::v1alpha1::BilingList* temp = biling_list_;
  biling_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::BilingList* InvoiceFilterResponse::_internal_mutable_biling_list() {
  
  if (biling_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::BilingList>(GetArenaForAllocation());
    biling_list_ = p;
  }
  return biling_list_;
}
inline ::payment::v1alpha1::BilingList* InvoiceFilterResponse::mutable_biling_list() {
  ::payment::v1alpha1::BilingList* _msg = _internal_mutable_biling_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterResponse.biling_list)
  return _msg;
}
inline void InvoiceFilterResponse::set_allocated_biling_list(::payment::v1alpha1::BilingList* biling_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling_list_);
  }
  if (biling_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling_list));
    if (message_arena != submessage_arena) {
      biling_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, biling_list, submessage_arena);
    }
    
  } else {
    
  }
  biling_list_ = biling_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterResponse.biling_list)
}

// string status = 3 [json_name = "status"];
inline void InvoiceFilterResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& InvoiceFilterResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceFilterResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterResponse.status)
}
inline std::string* InvoiceFilterResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterResponse.status)
  return _s;
}
inline const std::string& InvoiceFilterResponse::_internal_status() const {
  return status_.Get();
}
inline void InvoiceFilterResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvoiceFilterResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvoiceFilterResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvoiceFilterResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterResponse.status)
}

// -------------------------------------------------------------------

// DeleteCustomerRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void DeleteCustomerRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteCustomerRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteCustomerRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteCustomerRequest.organization_id)
  return _internal_organization_id();
}
inline void DeleteCustomerRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void DeleteCustomerRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeleteCustomerRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void DeleteCustomerRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& DeleteCustomerRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteCustomerRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteCustomerRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeleteCustomerRequest.customer_id)
}
inline std::string* DeleteCustomerRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeleteCustomerRequest.customer_id)
  return _s;
}
inline const std::string& DeleteCustomerRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void DeleteCustomerRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteCustomerRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteCustomerRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeleteCustomerRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteCustomerRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeleteCustomerRequest.customer_id)
}

// -------------------------------------------------------------------

// DeleteCustomerResponse

// string status = 1 [json_name = "status"];
inline void DeleteCustomerResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& DeleteCustomerResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteCustomerResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteCustomerResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeleteCustomerResponse.status)
}
inline std::string* DeleteCustomerResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeleteCustomerResponse.status)
  return _s;
}
inline const std::string& DeleteCustomerResponse::_internal_status() const {
  return status_.Get();
}
inline void DeleteCustomerResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteCustomerResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteCustomerResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeleteCustomerResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteCustomerResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeleteCustomerResponse.status)
}

// .payment.v1alpha1.Customer customer = 2 [json_name = "customer"];
inline bool DeleteCustomerResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool DeleteCustomerResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& DeleteCustomerResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& DeleteCustomerResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteCustomerResponse.customer)
  return _internal_customer();
}
inline void DeleteCustomerResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.DeleteCustomerResponse.customer)
}
inline ::payment::v1alpha1::Customer* DeleteCustomerResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* DeleteCustomerResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeleteCustomerResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* DeleteCustomerResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* DeleteCustomerResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeleteCustomerResponse.customer)
  return _msg;
}
inline void DeleteCustomerResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeleteCustomerResponse.customer)
}

// -------------------------------------------------------------------

// GetSubscriptionRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void GetSubscriptionRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetSubscriptionRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetSubscriptionRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetSubscriptionRequest.organization_id)
  return _internal_organization_id();
}
inline void GetSubscriptionRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void GetSubscriptionRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetSubscriptionRequest.organization_id)
}

// string subscription_id = 2 [json_name = "subscriptionId"];
inline void GetSubscriptionRequest::clear_subscription_id() {
  subscription_id_.ClearToEmpty();
}
inline const std::string& GetSubscriptionRequest::subscription_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetSubscriptionRequest.subscription_id)
  return _internal_subscription_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSubscriptionRequest::set_subscription_id(ArgT0&& arg0, ArgT... args) {
 
 subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetSubscriptionRequest.subscription_id)
}
inline std::string* GetSubscriptionRequest::mutable_subscription_id() {
  std::string* _s = _internal_mutable_subscription_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetSubscriptionRequest.subscription_id)
  return _s;
}
inline const std::string& GetSubscriptionRequest::_internal_subscription_id() const {
  return subscription_id_.Get();
}
inline void GetSubscriptionRequest::_internal_set_subscription_id(const std::string& value) {
  
  subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetSubscriptionRequest::_internal_mutable_subscription_id() {
  
  return subscription_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetSubscriptionRequest::release_subscription_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetSubscriptionRequest.subscription_id)
  return subscription_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetSubscriptionRequest::set_allocated_subscription_id(std::string* subscription_id) {
  if (subscription_id != nullptr) {
    
  } else {
    
  }
  subscription_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subscription_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetSubscriptionRequest.subscription_id)
}

// -------------------------------------------------------------------

// GetSubscriptionResponse

// .payment.v1alpha1.Subscription subscription = 1 [json_name = "subscription"];
inline bool GetSubscriptionResponse::_internal_has_subscription() const {
  return this != internal_default_instance() && subscription_ != nullptr;
}
inline bool GetSubscriptionResponse::has_subscription() const {
  return _internal_has_subscription();
}
inline const ::payment::v1alpha1::Subscription& GetSubscriptionResponse::_internal_subscription() const {
  const ::payment::v1alpha1::Subscription* p = subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Subscription&>(
      ::payment::v1alpha1::_Subscription_default_instance_);
}
inline const ::payment::v1alpha1::Subscription& GetSubscriptionResponse::subscription() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetSubscriptionResponse.subscription)
  return _internal_subscription();
}
inline void GetSubscriptionResponse::unsafe_arena_set_allocated_subscription(
    ::payment::v1alpha1::Subscription* subscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_);
  }
  subscription_ = subscription;
  if (subscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetSubscriptionResponse.subscription)
}
inline ::payment::v1alpha1::Subscription* GetSubscriptionResponse::release_subscription() {
  
  ::payment::v1alpha1::Subscription* temp = subscription_;
  subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Subscription* GetSubscriptionResponse::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetSubscriptionResponse.subscription)
  
  ::payment::v1alpha1::Subscription* temp = subscription_;
  subscription_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Subscription* GetSubscriptionResponse::_internal_mutable_subscription() {
  
  if (subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Subscription>(GetArenaForAllocation());
    subscription_ = p;
  }
  return subscription_;
}
inline ::payment::v1alpha1::Subscription* GetSubscriptionResponse::mutable_subscription() {
  ::payment::v1alpha1::Subscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetSubscriptionResponse.subscription)
  return _msg;
}
inline void GetSubscriptionResponse::set_allocated_subscription(::payment::v1alpha1::Subscription* subscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_);
  }
  if (subscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription));
    if (message_arena != submessage_arena) {
      subscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscription, submessage_arena);
    }
    
  } else {
    
  }
  subscription_ = subscription;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetSubscriptionResponse.subscription)
}

// string status = 2 [json_name = "status"];
inline void GetSubscriptionResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetSubscriptionResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetSubscriptionResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSubscriptionResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetSubscriptionResponse.status)
}
inline std::string* GetSubscriptionResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetSubscriptionResponse.status)
  return _s;
}
inline const std::string& GetSubscriptionResponse::_internal_status() const {
  return status_.Get();
}
inline void GetSubscriptionResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetSubscriptionResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetSubscriptionResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetSubscriptionResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetSubscriptionResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetSubscriptionResponse.status)
}

// -------------------------------------------------------------------

// GetOrganizationRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void GetOrganizationRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOrganizationRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOrganizationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetOrganizationRequest.organization_id)
  return _internal_organization_id();
}
inline void GetOrganizationRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void GetOrganizationRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetOrganizationRequest.organization_id)
}

// -------------------------------------------------------------------

// GetOrganizationResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool GetOrganizationResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool GetOrganizationResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& GetOrganizationResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& GetOrganizationResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetOrganizationResponse.customer)
  return _internal_customer();
}
inline void GetOrganizationResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetOrganizationResponse.customer)
}
inline ::payment::v1alpha1::Customer* GetOrganizationResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* GetOrganizationResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetOrganizationResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* GetOrganizationResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* GetOrganizationResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetOrganizationResponse.customer)
  return _msg;
}
inline void GetOrganizationResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetOrganizationResponse.customer)
}

// string status = 2 [json_name = "status"];
inline void GetOrganizationResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetOrganizationResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetOrganizationResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOrganizationResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetOrganizationResponse.status)
}
inline std::string* GetOrganizationResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetOrganizationResponse.status)
  return _s;
}
inline const std::string& GetOrganizationResponse::_internal_status() const {
  return status_.Get();
}
inline void GetOrganizationResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOrganizationResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOrganizationResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetOrganizationResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOrganizationResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetOrganizationResponse.status)
}

// -------------------------------------------------------------------

// GetCustomerRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void GetCustomerRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetCustomerRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetCustomerRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetCustomerRequest.organization_id)
  return _internal_organization_id();
}
inline void GetCustomerRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void GetCustomerRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetCustomerRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void GetCustomerRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& GetCustomerRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetCustomerRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCustomerRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetCustomerRequest.customer_id)
}
inline std::string* GetCustomerRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetCustomerRequest.customer_id)
  return _s;
}
inline const std::string& GetCustomerRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void GetCustomerRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetCustomerRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetCustomerRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetCustomerRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetCustomerRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetCustomerRequest.customer_id)
}

// -------------------------------------------------------------------

// GetCustomerResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool GetCustomerResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool GetCustomerResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& GetCustomerResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& GetCustomerResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetCustomerResponse.customer)
  return _internal_customer();
}
inline void GetCustomerResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetCustomerResponse.customer)
}
inline ::payment::v1alpha1::Customer* GetCustomerResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* GetCustomerResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetCustomerResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* GetCustomerResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* GetCustomerResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetCustomerResponse.customer)
  return _msg;
}
inline void GetCustomerResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetCustomerResponse.customer)
}

// string status = 2 [json_name = "status"];
inline void GetCustomerResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetCustomerResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetCustomerResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCustomerResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetCustomerResponse.status)
}
inline std::string* GetCustomerResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetCustomerResponse.status)
  return _s;
}
inline const std::string& GetCustomerResponse::_internal_status() const {
  return status_.Get();
}
inline void GetCustomerResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetCustomerResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetCustomerResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetCustomerResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetCustomerResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetCustomerResponse.status)
}

// -------------------------------------------------------------------

// GetBilingMonthRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void GetBilingMonthRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetBilingMonthRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetBilingMonthRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetBilingMonthRequest.organization_id)
  return _internal_organization_id();
}
inline void GetBilingMonthRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void GetBilingMonthRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetBilingMonthRequest.organization_id)
}

// string invoice_id = 2 [json_name = "invoiceId"];
inline void GetBilingMonthRequest::clear_invoice_id() {
  invoice_id_.ClearToEmpty();
}
inline const std::string& GetBilingMonthRequest::invoice_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetBilingMonthRequest.invoice_id)
  return _internal_invoice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBilingMonthRequest::set_invoice_id(ArgT0&& arg0, ArgT... args) {
 
 invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetBilingMonthRequest.invoice_id)
}
inline std::string* GetBilingMonthRequest::mutable_invoice_id() {
  std::string* _s = _internal_mutable_invoice_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetBilingMonthRequest.invoice_id)
  return _s;
}
inline const std::string& GetBilingMonthRequest::_internal_invoice_id() const {
  return invoice_id_.Get();
}
inline void GetBilingMonthRequest::_internal_set_invoice_id(const std::string& value) {
  
  invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBilingMonthRequest::_internal_mutable_invoice_id() {
  
  return invoice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBilingMonthRequest::release_invoice_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetBilingMonthRequest.invoice_id)
  return invoice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetBilingMonthRequest::set_allocated_invoice_id(std::string* invoice_id) {
  if (invoice_id != nullptr) {
    
  } else {
    
  }
  invoice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invoice_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetBilingMonthRequest.invoice_id)
}

// -------------------------------------------------------------------

// GetBilingMonthResponse

// .payment.v1alpha1.Biling biling = 1 [json_name = "biling"];
inline bool GetBilingMonthResponse::_internal_has_biling() const {
  return this != internal_default_instance() && biling_ != nullptr;
}
inline bool GetBilingMonthResponse::has_biling() const {
  return _internal_has_biling();
}
inline const ::payment::v1alpha1::Biling& GetBilingMonthResponse::_internal_biling() const {
  const ::payment::v1alpha1::Biling* p = biling_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Biling&>(
      ::payment::v1alpha1::_Biling_default_instance_);
}
inline const ::payment::v1alpha1::Biling& GetBilingMonthResponse::biling() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetBilingMonthResponse.biling)
  return _internal_biling();
}
inline void GetBilingMonthResponse::unsafe_arena_set_allocated_biling(
    ::payment::v1alpha1::Biling* biling) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling_);
  }
  biling_ = biling;
  if (biling) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetBilingMonthResponse.biling)
}
inline ::payment::v1alpha1::Biling* GetBilingMonthResponse::release_biling() {
  
  ::payment::v1alpha1::Biling* temp = biling_;
  biling_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Biling* GetBilingMonthResponse::unsafe_arena_release_biling() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetBilingMonthResponse.biling)
  
  ::payment::v1alpha1::Biling* temp = biling_;
  biling_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Biling* GetBilingMonthResponse::_internal_mutable_biling() {
  
  if (biling_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Biling>(GetArenaForAllocation());
    biling_ = p;
  }
  return biling_;
}
inline ::payment::v1alpha1::Biling* GetBilingMonthResponse::mutable_biling() {
  ::payment::v1alpha1::Biling* _msg = _internal_mutable_biling();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetBilingMonthResponse.biling)
  return _msg;
}
inline void GetBilingMonthResponse::set_allocated_biling(::payment::v1alpha1::Biling* biling) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling_);
  }
  if (biling) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling));
    if (message_arena != submessage_arena) {
      biling = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, biling, submessage_arena);
    }
    
  } else {
    
  }
  biling_ = biling;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetBilingMonthResponse.biling)
}

// string status = 2 [json_name = "status"];
inline void GetBilingMonthResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetBilingMonthResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetBilingMonthResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBilingMonthResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetBilingMonthResponse.status)
}
inline std::string* GetBilingMonthResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetBilingMonthResponse.status)
  return _s;
}
inline const std::string& GetBilingMonthResponse::_internal_status() const {
  return status_.Get();
}
inline void GetBilingMonthResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBilingMonthResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBilingMonthResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetBilingMonthResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetBilingMonthResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetBilingMonthResponse.status)
}

// -------------------------------------------------------------------

// GetPaymentsRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void GetPaymentsRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetPaymentsRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetPaymentsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentsRequest.organization_id)
  return _internal_organization_id();
}
inline void GetPaymentsRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void GetPaymentsRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentsRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void GetPaymentsRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& GetPaymentsRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentsRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentsRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentsRequest.customer_id)
}
inline std::string* GetPaymentsRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentsRequest.customer_id)
  return _s;
}
inline const std::string& GetPaymentsRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void GetPaymentsRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentsRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentsRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentsRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentsRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentsRequest.customer_id)
}

// -------------------------------------------------------------------

// GetPaymentsResponse

// .payment.v1alpha1.CardList card = 1 [json_name = "card"];
inline bool GetPaymentsResponse::_internal_has_card() const {
  return this != internal_default_instance() && card_ != nullptr;
}
inline bool GetPaymentsResponse::has_card() const {
  return _internal_has_card();
}
inline const ::payment::v1alpha1::CardList& GetPaymentsResponse::_internal_card() const {
  const ::payment::v1alpha1::CardList* p = card_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::CardList&>(
      ::payment::v1alpha1::_CardList_default_instance_);
}
inline const ::payment::v1alpha1::CardList& GetPaymentsResponse::card() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentsResponse.card)
  return _internal_card();
}
inline void GetPaymentsResponse::unsafe_arena_set_allocated_card(
    ::payment::v1alpha1::CardList* card) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(card_);
  }
  card_ = card;
  if (card) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetPaymentsResponse.card)
}
inline ::payment::v1alpha1::CardList* GetPaymentsResponse::release_card() {
  
  ::payment::v1alpha1::CardList* temp = card_;
  card_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::CardList* GetPaymentsResponse::unsafe_arena_release_card() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentsResponse.card)
  
  ::payment::v1alpha1::CardList* temp = card_;
  card_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::CardList* GetPaymentsResponse::_internal_mutable_card() {
  
  if (card_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::CardList>(GetArenaForAllocation());
    card_ = p;
  }
  return card_;
}
inline ::payment::v1alpha1::CardList* GetPaymentsResponse::mutable_card() {
  ::payment::v1alpha1::CardList* _msg = _internal_mutable_card();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentsResponse.card)
  return _msg;
}
inline void GetPaymentsResponse::set_allocated_card(::payment::v1alpha1::CardList* card) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(card_);
  }
  if (card) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(card));
    if (message_arena != submessage_arena) {
      card = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, card, submessage_arena);
    }
    
  } else {
    
  }
  card_ = card;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentsResponse.card)
}

// string status = 2 [json_name = "status"];
inline void GetPaymentsResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetPaymentsResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentsResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentsResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentsResponse.status)
}
inline std::string* GetPaymentsResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentsResponse.status)
  return _s;
}
inline const std::string& GetPaymentsResponse::_internal_status() const {
  return status_.Get();
}
inline void GetPaymentsResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentsResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentsResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentsResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentsResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentsResponse.status)
}

// -------------------------------------------------------------------

// CreateSubscriptionRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void CreateSubscriptionRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateSubscriptionRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateSubscriptionRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateSubscriptionRequest.organization_id)
  return _internal_organization_id();
}
inline void CreateSubscriptionRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CreateSubscriptionRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateSubscriptionRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void CreateSubscriptionRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& CreateSubscriptionRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateSubscriptionRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSubscriptionRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateSubscriptionRequest.customer_id)
}
inline std::string* CreateSubscriptionRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateSubscriptionRequest.customer_id)
  return _s;
}
inline const std::string& CreateSubscriptionRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void CreateSubscriptionRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSubscriptionRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSubscriptionRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateSubscriptionRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSubscriptionRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateSubscriptionRequest.customer_id)
}

// .payment.v1alpha1.Subscription subscription = 3 [json_name = "subscription"];
inline bool CreateSubscriptionRequest::_internal_has_subscription() const {
  return this != internal_default_instance() && subscription_ != nullptr;
}
inline bool CreateSubscriptionRequest::has_subscription() const {
  return _internal_has_subscription();
}
inline const ::payment::v1alpha1::Subscription& CreateSubscriptionRequest::_internal_subscription() const {
  const ::payment::v1alpha1::Subscription* p = subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Subscription&>(
      ::payment::v1alpha1::_Subscription_default_instance_);
}
inline const ::payment::v1alpha1::Subscription& CreateSubscriptionRequest::subscription() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateSubscriptionRequest.subscription)
  return _internal_subscription();
}
inline void CreateSubscriptionRequest::unsafe_arena_set_allocated_subscription(
    ::payment::v1alpha1::Subscription* subscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_);
  }
  subscription_ = subscription;
  if (subscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateSubscriptionRequest.subscription)
}
inline ::payment::v1alpha1::Subscription* CreateSubscriptionRequest::release_subscription() {
  
  ::payment::v1alpha1::Subscription* temp = subscription_;
  subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Subscription* CreateSubscriptionRequest::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateSubscriptionRequest.subscription)
  
  ::payment::v1alpha1::Subscription* temp = subscription_;
  subscription_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Subscription* CreateSubscriptionRequest::_internal_mutable_subscription() {
  
  if (subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Subscription>(GetArenaForAllocation());
    subscription_ = p;
  }
  return subscription_;
}
inline ::payment::v1alpha1::Subscription* CreateSubscriptionRequest::mutable_subscription() {
  ::payment::v1alpha1::Subscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateSubscriptionRequest.subscription)
  return _msg;
}
inline void CreateSubscriptionRequest::set_allocated_subscription(::payment::v1alpha1::Subscription* subscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_);
  }
  if (subscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription));
    if (message_arena != submessage_arena) {
      subscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscription, submessage_arena);
    }
    
  } else {
    
  }
  subscription_ = subscription;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateSubscriptionRequest.subscription)
}

// -------------------------------------------------------------------

// CreateSubscriptionResponse

// .payment.v1alpha1.Subscription subscription = 1 [json_name = "subscription"];
inline bool CreateSubscriptionResponse::_internal_has_subscription() const {
  return this != internal_default_instance() && subscription_ != nullptr;
}
inline bool CreateSubscriptionResponse::has_subscription() const {
  return _internal_has_subscription();
}
inline const ::payment::v1alpha1::Subscription& CreateSubscriptionResponse::_internal_subscription() const {
  const ::payment::v1alpha1::Subscription* p = subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Subscription&>(
      ::payment::v1alpha1::_Subscription_default_instance_);
}
inline const ::payment::v1alpha1::Subscription& CreateSubscriptionResponse::subscription() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateSubscriptionResponse.subscription)
  return _internal_subscription();
}
inline void CreateSubscriptionResponse::unsafe_arena_set_allocated_subscription(
    ::payment::v1alpha1::Subscription* subscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_);
  }
  subscription_ = subscription;
  if (subscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateSubscriptionResponse.subscription)
}
inline ::payment::v1alpha1::Subscription* CreateSubscriptionResponse::release_subscription() {
  
  ::payment::v1alpha1::Subscription* temp = subscription_;
  subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Subscription* CreateSubscriptionResponse::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateSubscriptionResponse.subscription)
  
  ::payment::v1alpha1::Subscription* temp = subscription_;
  subscription_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Subscription* CreateSubscriptionResponse::_internal_mutable_subscription() {
  
  if (subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Subscription>(GetArenaForAllocation());
    subscription_ = p;
  }
  return subscription_;
}
inline ::payment::v1alpha1::Subscription* CreateSubscriptionResponse::mutable_subscription() {
  ::payment::v1alpha1::Subscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateSubscriptionResponse.subscription)
  return _msg;
}
inline void CreateSubscriptionResponse::set_allocated_subscription(::payment::v1alpha1::Subscription* subscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_);
  }
  if (subscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription));
    if (message_arena != submessage_arena) {
      subscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscription, submessage_arena);
    }
    
  } else {
    
  }
  subscription_ = subscription;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateSubscriptionResponse.subscription)
}

// string status = 2 [json_name = "status"];
inline void CreateSubscriptionResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateSubscriptionResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateSubscriptionResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSubscriptionResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateSubscriptionResponse.status)
}
inline std::string* CreateSubscriptionResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateSubscriptionResponse.status)
  return _s;
}
inline const std::string& CreateSubscriptionResponse::_internal_status() const {
  return status_.Get();
}
inline void CreateSubscriptionResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSubscriptionResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSubscriptionResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateSubscriptionResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSubscriptionResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateSubscriptionResponse.status)
}

// -------------------------------------------------------------------

// UpdateSubscriptionRequest

// string subscription_id = 1 [json_name = "subscriptionId"];
inline void UpdateSubscriptionRequest::clear_subscription_id() {
  subscription_id_.ClearToEmpty();
}
inline const std::string& UpdateSubscriptionRequest::subscription_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdateSubscriptionRequest.subscription_id)
  return _internal_subscription_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSubscriptionRequest::set_subscription_id(ArgT0&& arg0, ArgT... args) {
 
 subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.UpdateSubscriptionRequest.subscription_id)
}
inline std::string* UpdateSubscriptionRequest::mutable_subscription_id() {
  std::string* _s = _internal_mutable_subscription_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.UpdateSubscriptionRequest.subscription_id)
  return _s;
}
inline const std::string& UpdateSubscriptionRequest::_internal_subscription_id() const {
  return subscription_id_.Get();
}
inline void UpdateSubscriptionRequest::_internal_set_subscription_id(const std::string& value) {
  
  subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateSubscriptionRequest::_internal_mutable_subscription_id() {
  
  return subscription_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateSubscriptionRequest::release_subscription_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.UpdateSubscriptionRequest.subscription_id)
  return subscription_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateSubscriptionRequest::set_allocated_subscription_id(std::string* subscription_id) {
  if (subscription_id != nullptr) {
    
  } else {
    
  }
  subscription_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subscription_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.UpdateSubscriptionRequest.subscription_id)
}

// uint32 organization_id = 2 [json_name = "organizationId"];
inline void UpdateSubscriptionRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateSubscriptionRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateSubscriptionRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdateSubscriptionRequest.organization_id)
  return _internal_organization_id();
}
inline void UpdateSubscriptionRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void UpdateSubscriptionRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.UpdateSubscriptionRequest.organization_id)
}

// -------------------------------------------------------------------

// UpdateSubscriptionResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool UpdateSubscriptionResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool UpdateSubscriptionResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& UpdateSubscriptionResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& UpdateSubscriptionResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdateSubscriptionResponse.customer)
  return _internal_customer();
}
inline void UpdateSubscriptionResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.UpdateSubscriptionResponse.customer)
}
inline ::payment::v1alpha1::Customer* UpdateSubscriptionResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* UpdateSubscriptionResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.UpdateSubscriptionResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* UpdateSubscriptionResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* UpdateSubscriptionResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.UpdateSubscriptionResponse.customer)
  return _msg;
}
inline void UpdateSubscriptionResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.UpdateSubscriptionResponse.customer)
}

// string status = 2 [json_name = "status"];
inline void UpdateSubscriptionResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& UpdateSubscriptionResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdateSubscriptionResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSubscriptionResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.UpdateSubscriptionResponse.status)
}
inline std::string* UpdateSubscriptionResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.UpdateSubscriptionResponse.status)
  return _s;
}
inline const std::string& UpdateSubscriptionResponse::_internal_status() const {
  return status_.Get();
}
inline void UpdateSubscriptionResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateSubscriptionResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateSubscriptionResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.UpdateSubscriptionResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateSubscriptionResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.UpdateSubscriptionResponse.status)
}

// -------------------------------------------------------------------

// CreateProjectRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void CreateProjectRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateProjectRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateProjectRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateProjectRequest.organization_id)
  return _internal_organization_id();
}
inline void CreateProjectRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CreateProjectRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateProjectRequest.organization_id)
}

// .payment.v1alpha1.Project project = 2 [json_name = "project"];
inline bool CreateProjectRequest::_internal_has_project() const {
  return this != internal_default_instance() && project_ != nullptr;
}
inline bool CreateProjectRequest::has_project() const {
  return _internal_has_project();
}
inline const ::payment::v1alpha1::Project& CreateProjectRequest::_internal_project() const {
  const ::payment::v1alpha1::Project* p = project_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Project&>(
      ::payment::v1alpha1::_Project_default_instance_);
}
inline const ::payment::v1alpha1::Project& CreateProjectRequest::project() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateProjectRequest.project)
  return _internal_project();
}
inline void CreateProjectRequest::unsafe_arena_set_allocated_project(
    ::payment::v1alpha1::Project* project) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_);
  }
  project_ = project;
  if (project) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateProjectRequest.project)
}
inline ::payment::v1alpha1::Project* CreateProjectRequest::release_project() {
  
  ::payment::v1alpha1::Project* temp = project_;
  project_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Project* CreateProjectRequest::unsafe_arena_release_project() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateProjectRequest.project)
  
  ::payment::v1alpha1::Project* temp = project_;
  project_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Project* CreateProjectRequest::_internal_mutable_project() {
  
  if (project_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Project>(GetArenaForAllocation());
    project_ = p;
  }
  return project_;
}
inline ::payment::v1alpha1::Project* CreateProjectRequest::mutable_project() {
  ::payment::v1alpha1::Project* _msg = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateProjectRequest.project)
  return _msg;
}
inline void CreateProjectRequest::set_allocated_project(::payment::v1alpha1::Project* project) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_);
  }
  if (project) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project));
    if (message_arena != submessage_arena) {
      project = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, project, submessage_arena);
    }
    
  } else {
    
  }
  project_ = project;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateProjectRequest.project)
}

// -------------------------------------------------------------------

// CreateProjectResponse

// string status = 1 [json_name = "status"];
inline void CreateProjectResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateProjectResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateProjectResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateProjectResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateProjectResponse.status)
}
inline std::string* CreateProjectResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateProjectResponse.status)
  return _s;
}
inline const std::string& CreateProjectResponse::_internal_status() const {
  return status_.Get();
}
inline void CreateProjectResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateProjectResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateProjectResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateProjectResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateProjectResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateProjectResponse.status)
}

// -------------------------------------------------------------------

// CreateInvoiceRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void CreateInvoiceRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateInvoiceRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateInvoiceRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceRequest.organization_id)
  return _internal_organization_id();
}
inline void CreateInvoiceRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CreateInvoiceRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateInvoiceRequest.organization_id)
}

// string invoice_id = 2 [json_name = "invoiceId"];
inline void CreateInvoiceRequest::clear_invoice_id() {
  invoice_id_.ClearToEmpty();
}
inline const std::string& CreateInvoiceRequest::invoice_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceRequest.invoice_id)
  return _internal_invoice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInvoiceRequest::set_invoice_id(ArgT0&& arg0, ArgT... args) {
 
 invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateInvoiceRequest.invoice_id)
}
inline std::string* CreateInvoiceRequest::mutable_invoice_id() {
  std::string* _s = _internal_mutable_invoice_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceRequest.invoice_id)
  return _s;
}
inline const std::string& CreateInvoiceRequest::_internal_invoice_id() const {
  return invoice_id_.Get();
}
inline void CreateInvoiceRequest::_internal_set_invoice_id(const std::string& value) {
  
  invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::_internal_mutable_invoice_id() {
  
  return invoice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::release_invoice_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceRequest.invoice_id)
  return invoice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateInvoiceRequest::set_allocated_invoice_id(std::string* invoice_id) {
  if (invoice_id != nullptr) {
    
  } else {
    
  }
  invoice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invoice_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceRequest.invoice_id)
}

// string year = 3 [json_name = "year"];
inline void CreateInvoiceRequest::clear_year() {
  year_.ClearToEmpty();
}
inline const std::string& CreateInvoiceRequest::year() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceRequest.year)
  return _internal_year();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInvoiceRequest::set_year(ArgT0&& arg0, ArgT... args) {
 
 year_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateInvoiceRequest.year)
}
inline std::string* CreateInvoiceRequest::mutable_year() {
  std::string* _s = _internal_mutable_year();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceRequest.year)
  return _s;
}
inline const std::string& CreateInvoiceRequest::_internal_year() const {
  return year_.Get();
}
inline void CreateInvoiceRequest::_internal_set_year(const std::string& value) {
  
  year_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::_internal_mutable_year() {
  
  return year_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::release_year() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceRequest.year)
  return year_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateInvoiceRequest::set_allocated_year(std::string* year) {
  if (year != nullptr) {
    
  } else {
    
  }
  year_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), year,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceRequest.year)
}

// string month = 4 [json_name = "month"];
inline void CreateInvoiceRequest::clear_month() {
  month_.ClearToEmpty();
}
inline const std::string& CreateInvoiceRequest::month() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceRequest.month)
  return _internal_month();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInvoiceRequest::set_month(ArgT0&& arg0, ArgT... args) {
 
 month_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateInvoiceRequest.month)
}
inline std::string* CreateInvoiceRequest::mutable_month() {
  std::string* _s = _internal_mutable_month();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceRequest.month)
  return _s;
}
inline const std::string& CreateInvoiceRequest::_internal_month() const {
  return month_.Get();
}
inline void CreateInvoiceRequest::_internal_set_month(const std::string& value) {
  
  month_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::_internal_mutable_month() {
  
  return month_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::release_month() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceRequest.month)
  return month_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateInvoiceRequest::set_allocated_month(std::string* month) {
  if (month != nullptr) {
    
  } else {
    
  }
  month_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), month,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceRequest.month)
}

// string customer_id = 5 [json_name = "customerId"];
inline void CreateInvoiceRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& CreateInvoiceRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInvoiceRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateInvoiceRequest.customer_id)
}
inline std::string* CreateInvoiceRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceRequest.customer_id)
  return _s;
}
inline const std::string& CreateInvoiceRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void CreateInvoiceRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateInvoiceRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceRequest.customer_id)
}

// string project_id = 6 [json_name = "projectId"];
inline void CreateInvoiceRequest::clear_project_id() {
  project_id_.ClearToEmpty();
}
inline const std::string& CreateInvoiceRequest::project_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceRequest.project_id)
  return _internal_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInvoiceRequest::set_project_id(ArgT0&& arg0, ArgT... args) {
 
 project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateInvoiceRequest.project_id)
}
inline std::string* CreateInvoiceRequest::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceRequest.project_id)
  return _s;
}
inline const std::string& CreateInvoiceRequest::_internal_project_id() const {
  return project_id_.Get();
}
inline void CreateInvoiceRequest::_internal_set_project_id(const std::string& value) {
  
  project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::_internal_mutable_project_id() {
  
  return project_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::release_project_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceRequest.project_id)
  return project_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateInvoiceRequest::set_allocated_project_id(std::string* project_id) {
  if (project_id != nullptr) {
    
  } else {
    
  }
  project_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceRequest.project_id)
}

// string status = 7 [json_name = "status"];
inline void CreateInvoiceRequest::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateInvoiceRequest::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceRequest.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInvoiceRequest::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateInvoiceRequest.status)
}
inline std::string* CreateInvoiceRequest::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceRequest.status)
  return _s;
}
inline const std::string& CreateInvoiceRequest::_internal_status() const {
  return status_.Get();
}
inline void CreateInvoiceRequest::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceRequest.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateInvoiceRequest::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceRequest.status)
}

// -------------------------------------------------------------------

// CreateInvoiceResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool CreateInvoiceResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool CreateInvoiceResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& CreateInvoiceResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& CreateInvoiceResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceResponse.customer)
  return _internal_customer();
}
inline void CreateInvoiceResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateInvoiceResponse.customer)
}
inline ::payment::v1alpha1::Customer* CreateInvoiceResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* CreateInvoiceResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* CreateInvoiceResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* CreateInvoiceResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceResponse.customer)
  return _msg;
}
inline void CreateInvoiceResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceResponse.customer)
}

// string status = 2 [json_name = "status"];
inline void CreateInvoiceResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateInvoiceResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInvoiceResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateInvoiceResponse.status)
}
inline std::string* CreateInvoiceResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceResponse.status)
  return _s;
}
inline const std::string& CreateInvoiceResponse::_internal_status() const {
  return status_.Get();
}
inline void CreateInvoiceResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateInvoiceResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateInvoiceResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateInvoiceResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceResponse.status)
}

// -------------------------------------------------------------------

// CreateCardRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void CreateCardRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateCardRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateCardRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCardRequest.organization_id)
  return _internal_organization_id();
}
inline void CreateCardRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CreateCardRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCardRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void CreateCardRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& CreateCardRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCardRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCardRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCardRequest.customer_id)
}
inline std::string* CreateCardRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCardRequest.customer_id)
  return _s;
}
inline const std::string& CreateCardRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void CreateCardRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCardRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCardRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCardRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCardRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCardRequest.customer_id)
}

// .payment.v1alpha1.Card card = 3 [json_name = "card"];
inline bool CreateCardRequest::_internal_has_card() const {
  return this != internal_default_instance() && card_ != nullptr;
}
inline bool CreateCardRequest::has_card() const {
  return _internal_has_card();
}
inline const ::payment::v1alpha1::Card& CreateCardRequest::_internal_card() const {
  const ::payment::v1alpha1::Card* p = card_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Card&>(
      ::payment::v1alpha1::_Card_default_instance_);
}
inline const ::payment::v1alpha1::Card& CreateCardRequest::card() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCardRequest.card)
  return _internal_card();
}
inline void CreateCardRequest::unsafe_arena_set_allocated_card(
    ::payment::v1alpha1::Card* card) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(card_);
  }
  card_ = card;
  if (card) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateCardRequest.card)
}
inline ::payment::v1alpha1::Card* CreateCardRequest::release_card() {
  
  ::payment::v1alpha1::Card* temp = card_;
  card_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Card* CreateCardRequest::unsafe_arena_release_card() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCardRequest.card)
  
  ::payment::v1alpha1::Card* temp = card_;
  card_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Card* CreateCardRequest::_internal_mutable_card() {
  
  if (card_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Card>(GetArenaForAllocation());
    card_ = p;
  }
  return card_;
}
inline ::payment::v1alpha1::Card* CreateCardRequest::mutable_card() {
  ::payment::v1alpha1::Card* _msg = _internal_mutable_card();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCardRequest.card)
  return _msg;
}
inline void CreateCardRequest::set_allocated_card(::payment::v1alpha1::Card* card) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(card_);
  }
  if (card) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(card));
    if (message_arena != submessage_arena) {
      card = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, card, submessage_arena);
    }
    
  } else {
    
  }
  card_ = card;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCardRequest.card)
}

// -------------------------------------------------------------------

// CreateCardResponse

// string token_id = 1 [json_name = "tokenId"];
inline void CreateCardResponse::clear_token_id() {
  token_id_.ClearToEmpty();
}
inline const std::string& CreateCardResponse::token_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCardResponse.token_id)
  return _internal_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCardResponse::set_token_id(ArgT0&& arg0, ArgT... args) {
 
 token_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCardResponse.token_id)
}
inline std::string* CreateCardResponse::mutable_token_id() {
  std::string* _s = _internal_mutable_token_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCardResponse.token_id)
  return _s;
}
inline const std::string& CreateCardResponse::_internal_token_id() const {
  return token_id_.Get();
}
inline void CreateCardResponse::_internal_set_token_id(const std::string& value) {
  
  token_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCardResponse::_internal_mutable_token_id() {
  
  return token_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCardResponse::release_token_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCardResponse.token_id)
  return token_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCardResponse::set_allocated_token_id(std::string* token_id) {
  if (token_id != nullptr) {
    
  } else {
    
  }
  token_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCardResponse.token_id)
}

// string status = 2 [json_name = "status"];
inline void CreateCardResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateCardResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCardResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCardResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCardResponse.status)
}
inline std::string* CreateCardResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCardResponse.status)
  return _s;
}
inline const std::string& CreateCardResponse::_internal_status() const {
  return status_.Get();
}
inline void CreateCardResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCardResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCardResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCardResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCardResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCardResponse.status)
}

// -------------------------------------------------------------------

// CancelSubscriptionRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void CancelSubscriptionRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CancelSubscriptionRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CancelSubscriptionRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CancelSubscriptionRequest.organization_id)
  return _internal_organization_id();
}
inline void CancelSubscriptionRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CancelSubscriptionRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CancelSubscriptionRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void CancelSubscriptionRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& CancelSubscriptionRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CancelSubscriptionRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelSubscriptionRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CancelSubscriptionRequest.customer_id)
}
inline std::string* CancelSubscriptionRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CancelSubscriptionRequest.customer_id)
  return _s;
}
inline const std::string& CancelSubscriptionRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void CancelSubscriptionRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelSubscriptionRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelSubscriptionRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CancelSubscriptionRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelSubscriptionRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CancelSubscriptionRequest.customer_id)
}

// string subscription_id = 3 [json_name = "subscriptionId"];
inline void CancelSubscriptionRequest::clear_subscription_id() {
  subscription_id_.ClearToEmpty();
}
inline const std::string& CancelSubscriptionRequest::subscription_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CancelSubscriptionRequest.subscription_id)
  return _internal_subscription_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelSubscriptionRequest::set_subscription_id(ArgT0&& arg0, ArgT... args) {
 
 subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CancelSubscriptionRequest.subscription_id)
}
inline std::string* CancelSubscriptionRequest::mutable_subscription_id() {
  std::string* _s = _internal_mutable_subscription_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CancelSubscriptionRequest.subscription_id)
  return _s;
}
inline const std::string& CancelSubscriptionRequest::_internal_subscription_id() const {
  return subscription_id_.Get();
}
inline void CancelSubscriptionRequest::_internal_set_subscription_id(const std::string& value) {
  
  subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelSubscriptionRequest::_internal_mutable_subscription_id() {
  
  return subscription_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelSubscriptionRequest::release_subscription_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CancelSubscriptionRequest.subscription_id)
  return subscription_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelSubscriptionRequest::set_allocated_subscription_id(std::string* subscription_id) {
  if (subscription_id != nullptr) {
    
  } else {
    
  }
  subscription_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subscription_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CancelSubscriptionRequest.subscription_id)
}

// -------------------------------------------------------------------

// CancelSubscriptionResponse

// string status = 1 [json_name = "status"];
inline void CancelSubscriptionResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CancelSubscriptionResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CancelSubscriptionResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelSubscriptionResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CancelSubscriptionResponse.status)
}
inline std::string* CancelSubscriptionResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CancelSubscriptionResponse.status)
  return _s;
}
inline const std::string& CancelSubscriptionResponse::_internal_status() const {
  return status_.Get();
}
inline void CancelSubscriptionResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelSubscriptionResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelSubscriptionResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CancelSubscriptionResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelSubscriptionResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CancelSubscriptionResponse.status)
}

// -------------------------------------------------------------------

// CreateCustomerRequest

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool CreateCustomerRequest::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool CreateCustomerRequest::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& CreateCustomerRequest::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& CreateCustomerRequest::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCustomerRequest.customer)
  return _internal_customer();
}
inline void CreateCustomerRequest::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateCustomerRequest.customer)
}
inline ::payment::v1alpha1::Customer* CreateCustomerRequest::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* CreateCustomerRequest::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCustomerRequest.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* CreateCustomerRequest::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* CreateCustomerRequest::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCustomerRequest.customer)
  return _msg;
}
inline void CreateCustomerRequest::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCustomerRequest.customer)
}

// -------------------------------------------------------------------

// CreateCustomerResponse

// string customer_id = 1 [json_name = "customerId"];
inline void CreateCustomerResponse::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& CreateCustomerResponse::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCustomerResponse.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCustomerResponse::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCustomerResponse.customer_id)
}
inline std::string* CreateCustomerResponse::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCustomerResponse.customer_id)
  return _s;
}
inline const std::string& CreateCustomerResponse::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void CreateCustomerResponse::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCustomerResponse::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCustomerResponse::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCustomerResponse.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCustomerResponse::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCustomerResponse.customer_id)
}

// string status = 2 [json_name = "status"];
inline void CreateCustomerResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateCustomerResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCustomerResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCustomerResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCustomerResponse.status)
}
inline std::string* CreateCustomerResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCustomerResponse.status)
  return _s;
}
inline const std::string& CreateCustomerResponse::_internal_status() const {
  return status_.Get();
}
inline void CreateCustomerResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCustomerResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCustomerResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCustomerResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCustomerResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCustomerResponse.status)
}

// -------------------------------------------------------------------

// CreatePaymentRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void CreatePaymentRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreatePaymentRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreatePaymentRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentRequest.organization_id)
  return _internal_organization_id();
}
inline void CreatePaymentRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CreatePaymentRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreatePaymentRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void CreatePaymentRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& CreatePaymentRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePaymentRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreatePaymentRequest.customer_id)
}
inline std::string* CreatePaymentRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentRequest.customer_id)
  return _s;
}
inline const std::string& CreatePaymentRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void CreatePaymentRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePaymentRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePaymentRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePaymentRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentRequest.customer_id)
}

// .payment.v1alpha1.Payment payment = 3 [json_name = "payment"];
inline bool CreatePaymentRequest::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool CreatePaymentRequest::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::Payment& CreatePaymentRequest::_internal_payment() const {
  const ::payment::v1alpha1::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Payment&>(
      ::payment::v1alpha1::_Payment_default_instance_);
}
inline const ::payment::v1alpha1::Payment& CreatePaymentRequest::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentRequest.payment)
  return _internal_payment();
}
inline void CreatePaymentRequest::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreatePaymentRequest.payment)
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::release_payment() {
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentRequest.payment)
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::mutable_payment() {
  ::payment::v1alpha1::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentRequest.payment)
  return _msg;
}
inline void CreatePaymentRequest::set_allocated_payment(::payment::v1alpha1::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentRequest.payment)
}

// -------------------------------------------------------------------

// CreatePaymentResponse

// string card_id = 1 [json_name = "cardId"];
inline void CreatePaymentResponse::clear_card_id() {
  card_id_.ClearToEmpty();
}
inline const std::string& CreatePaymentResponse::card_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentResponse.card_id)
  return _internal_card_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePaymentResponse::set_card_id(ArgT0&& arg0, ArgT... args) {
 
 card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreatePaymentResponse.card_id)
}
inline std::string* CreatePaymentResponse::mutable_card_id() {
  std::string* _s = _internal_mutable_card_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentResponse.card_id)
  return _s;
}
inline const std::string& CreatePaymentResponse::_internal_card_id() const {
  return card_id_.Get();
}
inline void CreatePaymentResponse::_internal_set_card_id(const std::string& value) {
  
  card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePaymentResponse::_internal_mutable_card_id() {
  
  return card_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePaymentResponse::release_card_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentResponse.card_id)
  return card_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePaymentResponse::set_allocated_card_id(std::string* card_id) {
  if (card_id != nullptr) {
    
  } else {
    
  }
  card_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentResponse.card_id)
}

// string status = 2 [json_name = "status"];
inline void CreatePaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreatePaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreatePaymentResponse.status)
}
inline std::string* CreatePaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentResponse.status)
  return _s;
}
inline const std::string& CreatePaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void CreatePaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentResponse.status)
}

// -------------------------------------------------------------------

// DeletePaymentRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void DeletePaymentRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeletePaymentRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeletePaymentRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentRequest.organization_id)
  return _internal_organization_id();
}
inline void DeletePaymentRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void DeletePaymentRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void DeletePaymentRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& DeletePaymentRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePaymentRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentRequest.customer_id)
}
inline std::string* DeletePaymentRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeletePaymentRequest.customer_id)
  return _s;
}
inline const std::string& DeletePaymentRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void DeletePaymentRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeletePaymentRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePaymentRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeletePaymentRequest.customer_id)
}

// string card_id = 3 [json_name = "cardId"];
inline void DeletePaymentRequest::clear_card_id() {
  card_id_.ClearToEmpty();
}
inline const std::string& DeletePaymentRequest::card_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentRequest.card_id)
  return _internal_card_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePaymentRequest::set_card_id(ArgT0&& arg0, ArgT... args) {
 
 card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentRequest.card_id)
}
inline std::string* DeletePaymentRequest::mutable_card_id() {
  std::string* _s = _internal_mutable_card_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeletePaymentRequest.card_id)
  return _s;
}
inline const std::string& DeletePaymentRequest::_internal_card_id() const {
  return card_id_.Get();
}
inline void DeletePaymentRequest::_internal_set_card_id(const std::string& value) {
  
  card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::_internal_mutable_card_id() {
  
  return card_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::release_card_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeletePaymentRequest.card_id)
  return card_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePaymentRequest::set_allocated_card_id(std::string* card_id) {
  if (card_id != nullptr) {
    
  } else {
    
  }
  card_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeletePaymentRequest.card_id)
}

// -------------------------------------------------------------------

// DeletePaymentResponse

// string status = 1 [json_name = "status"];
inline void DeletePaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& DeletePaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentResponse.status)
}
inline std::string* DeletePaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeletePaymentResponse.status)
  return _s;
}
inline const std::string& DeletePaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void DeletePaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeletePaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeletePaymentResponse.status)
}

// string msg_error = 2 [json_name = "msgError"];
inline void DeletePaymentResponse::clear_msg_error() {
  msg_error_.ClearToEmpty();
}
inline const std::string& DeletePaymentResponse::msg_error() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentResponse.msg_error)
  return _internal_msg_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePaymentResponse::set_msg_error(ArgT0&& arg0, ArgT... args) {
 
 msg_error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentResponse.msg_error)
}
inline std::string* DeletePaymentResponse::mutable_msg_error() {
  std::string* _s = _internal_mutable_msg_error();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeletePaymentResponse.msg_error)
  return _s;
}
inline const std::string& DeletePaymentResponse::_internal_msg_error() const {
  return msg_error_.Get();
}
inline void DeletePaymentResponse::_internal_set_msg_error(const std::string& value) {
  
  msg_error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePaymentResponse::_internal_mutable_msg_error() {
  
  return msg_error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePaymentResponse::release_msg_error() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeletePaymentResponse.msg_error)
  return msg_error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePaymentResponse::set_allocated_msg_error(std::string* msg_error) {
  if (msg_error != nullptr) {
    
  } else {
    
  }
  msg_error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg_error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeletePaymentResponse.msg_error)
}

// -------------------------------------------------------------------

// GetPaymentRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void GetPaymentRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetPaymentRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetPaymentRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentRequest.organization_id)
  return _internal_organization_id();
}
inline void GetPaymentRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void GetPaymentRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void GetPaymentRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& GetPaymentRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentRequest.customer_id)
}
inline std::string* GetPaymentRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentRequest.customer_id)
  return _s;
}
inline const std::string& GetPaymentRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void GetPaymentRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentRequest.customer_id)
}

// string card_id = 3 [json_name = "cardId"];
inline void GetPaymentRequest::clear_card_id() {
  card_id_.ClearToEmpty();
}
inline const std::string& GetPaymentRequest::card_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentRequest.card_id)
  return _internal_card_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentRequest::set_card_id(ArgT0&& arg0, ArgT... args) {
 
 card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentRequest.card_id)
}
inline std::string* GetPaymentRequest::mutable_card_id() {
  std::string* _s = _internal_mutable_card_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentRequest.card_id)
  return _s;
}
inline const std::string& GetPaymentRequest::_internal_card_id() const {
  return card_id_.Get();
}
inline void GetPaymentRequest::_internal_set_card_id(const std::string& value) {
  
  card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentRequest::_internal_mutable_card_id() {
  
  return card_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentRequest::release_card_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentRequest.card_id)
  return card_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentRequest::set_allocated_card_id(std::string* card_id) {
  if (card_id != nullptr) {
    
  } else {
    
  }
  card_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentRequest.card_id)
}

// -------------------------------------------------------------------

// GetPaymentResponse

// .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
inline bool GetPaymentResponse::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool GetPaymentResponse::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::Payment& GetPaymentResponse::_internal_payment() const {
  const ::payment::v1alpha1::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Payment&>(
      ::payment::v1alpha1::_Payment_default_instance_);
}
inline const ::payment::v1alpha1::Payment& GetPaymentResponse::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentResponse.payment)
  return _internal_payment();
}
inline void GetPaymentResponse::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetPaymentResponse.payment)
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::release_payment() {
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentResponse.payment)
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::mutable_payment() {
  ::payment::v1alpha1::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentResponse.payment)
  return _msg;
}
inline void GetPaymentResponse::set_allocated_payment(::payment::v1alpha1::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentResponse.payment)
}

// string status = 2 [json_name = "status"];
inline void GetPaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetPaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentResponse.status)
}
inline std::string* GetPaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentResponse.status)
  return _s;
}
inline const std::string& GetPaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void GetPaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentResponse.status)
}

// -------------------------------------------------------------------

// ListPaymentRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void ListPaymentRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListPaymentRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListPaymentRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentRequest.organization_id)
  return _internal_organization_id();
}
inline void ListPaymentRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void ListPaymentRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListPaymentRequest.organization_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void ListPaymentRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& ListPaymentRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPaymentRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListPaymentRequest.customer_id)
}
inline std::string* ListPaymentRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListPaymentRequest.customer_id)
  return _s;
}
inline const std::string& ListPaymentRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void ListPaymentRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPaymentRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPaymentRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListPaymentRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPaymentRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListPaymentRequest.customer_id)
}

// -------------------------------------------------------------------

// ListPaymentResponse

// .payment.v1alpha1.PaymentList payment_list = 1 [json_name = "paymentList"];
inline bool ListPaymentResponse::_internal_has_payment_list() const {
  return this != internal_default_instance() && payment_list_ != nullptr;
}
inline bool ListPaymentResponse::has_payment_list() const {
  return _internal_has_payment_list();
}
inline const ::payment::v1alpha1::PaymentList& ListPaymentResponse::_internal_payment_list() const {
  const ::payment::v1alpha1::PaymentList* p = payment_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::PaymentList&>(
      ::payment::v1alpha1::_PaymentList_default_instance_);
}
inline const ::payment::v1alpha1::PaymentList& ListPaymentResponse::payment_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentResponse.payment_list)
  return _internal_payment_list();
}
inline void ListPaymentResponse::unsafe_arena_set_allocated_payment_list(
    ::payment::v1alpha1::PaymentList* payment_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_list_);
  }
  payment_list_ = payment_list;
  if (payment_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.ListPaymentResponse.payment_list)
}
inline ::payment::v1alpha1::PaymentList* ListPaymentResponse::release_payment_list() {
  
  ::payment::v1alpha1::PaymentList* temp = payment_list_;
  payment_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::PaymentList* ListPaymentResponse::unsafe_arena_release_payment_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListPaymentResponse.payment_list)
  
  ::payment::v1alpha1::PaymentList* temp = payment_list_;
  payment_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::PaymentList* ListPaymentResponse::_internal_mutable_payment_list() {
  
  if (payment_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::PaymentList>(GetArenaForAllocation());
    payment_list_ = p;
  }
  return payment_list_;
}
inline ::payment::v1alpha1::PaymentList* ListPaymentResponse::mutable_payment_list() {
  ::payment::v1alpha1::PaymentList* _msg = _internal_mutable_payment_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListPaymentResponse.payment_list)
  return _msg;
}
inline void ListPaymentResponse::set_allocated_payment_list(::payment::v1alpha1::PaymentList* payment_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_list_);
  }
  if (payment_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_list));
    if (message_arena != submessage_arena) {
      payment_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment_list, submessage_arena);
    }
    
  } else {
    
  }
  payment_list_ = payment_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListPaymentResponse.payment_list)
}

// string error = 2 [json_name = "error"];
inline void ListPaymentResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& ListPaymentResponse::error() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPaymentResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListPaymentResponse.error)
}
inline std::string* ListPaymentResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListPaymentResponse.error)
  return _s;
}
inline const std::string& ListPaymentResponse::_internal_error() const {
  return error_.Get();
}
inline void ListPaymentResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPaymentResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPaymentResponse::release_error() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListPaymentResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPaymentResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListPaymentResponse.error)
}

// -------------------------------------------------------------------

// ListSubscriptionItemsRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void ListSubscriptionItemsRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListSubscriptionItemsRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListSubscriptionItemsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListSubscriptionItemsRequest.organization_id)
  return _internal_organization_id();
}
inline void ListSubscriptionItemsRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void ListSubscriptionItemsRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListSubscriptionItemsRequest.organization_id)
}

// string subscription_id = 2 [json_name = "subscriptionId"];
inline void ListSubscriptionItemsRequest::clear_subscription_id() {
  subscription_id_.ClearToEmpty();
}
inline const std::string& ListSubscriptionItemsRequest::subscription_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListSubscriptionItemsRequest.subscription_id)
  return _internal_subscription_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListSubscriptionItemsRequest::set_subscription_id(ArgT0&& arg0, ArgT... args) {
 
 subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListSubscriptionItemsRequest.subscription_id)
}
inline std::string* ListSubscriptionItemsRequest::mutable_subscription_id() {
  std::string* _s = _internal_mutable_subscription_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListSubscriptionItemsRequest.subscription_id)
  return _s;
}
inline const std::string& ListSubscriptionItemsRequest::_internal_subscription_id() const {
  return subscription_id_.Get();
}
inline void ListSubscriptionItemsRequest::_internal_set_subscription_id(const std::string& value) {
  
  subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListSubscriptionItemsRequest::_internal_mutable_subscription_id() {
  
  return subscription_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListSubscriptionItemsRequest::release_subscription_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListSubscriptionItemsRequest.subscription_id)
  return subscription_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListSubscriptionItemsRequest::set_allocated_subscription_id(std::string* subscription_id) {
  if (subscription_id != nullptr) {
    
  } else {
    
  }
  subscription_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subscription_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListSubscriptionItemsRequest.subscription_id)
}

// -------------------------------------------------------------------

// ListSubscriptionItemsResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool ListSubscriptionItemsResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool ListSubscriptionItemsResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& ListSubscriptionItemsResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& ListSubscriptionItemsResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListSubscriptionItemsResponse.customer)
  return _internal_customer();
}
inline void ListSubscriptionItemsResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.ListSubscriptionItemsResponse.customer)
}
inline ::payment::v1alpha1::Customer* ListSubscriptionItemsResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* ListSubscriptionItemsResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListSubscriptionItemsResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* ListSubscriptionItemsResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* ListSubscriptionItemsResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListSubscriptionItemsResponse.customer)
  return _msg;
}
inline void ListSubscriptionItemsResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListSubscriptionItemsResponse.customer)
}

// .payment.v1alpha1.SubscriptionItemsList subscription_items_list = 2 [json_name = "subscriptionItemsList"];
inline bool ListSubscriptionItemsResponse::_internal_has_subscription_items_list() const {
  return this != internal_default_instance() && subscription_items_list_ != nullptr;
}
inline bool ListSubscriptionItemsResponse::has_subscription_items_list() const {
  return _internal_has_subscription_items_list();
}
inline const ::payment::v1alpha1::SubscriptionItemsList& ListSubscriptionItemsResponse::_internal_subscription_items_list() const {
  const ::payment::v1alpha1::SubscriptionItemsList* p = subscription_items_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::SubscriptionItemsList&>(
      ::payment::v1alpha1::_SubscriptionItemsList_default_instance_);
}
inline const ::payment::v1alpha1::SubscriptionItemsList& ListSubscriptionItemsResponse::subscription_items_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListSubscriptionItemsResponse.subscription_items_list)
  return _internal_subscription_items_list();
}
inline void ListSubscriptionItemsResponse::unsafe_arena_set_allocated_subscription_items_list(
    ::payment::v1alpha1::SubscriptionItemsList* subscription_items_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_items_list_);
  }
  subscription_items_list_ = subscription_items_list;
  if (subscription_items_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.ListSubscriptionItemsResponse.subscription_items_list)
}
inline ::payment::v1alpha1::SubscriptionItemsList* ListSubscriptionItemsResponse::release_subscription_items_list() {
  
  ::payment::v1alpha1::SubscriptionItemsList* temp = subscription_items_list_;
  subscription_items_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::SubscriptionItemsList* ListSubscriptionItemsResponse::unsafe_arena_release_subscription_items_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListSubscriptionItemsResponse.subscription_items_list)
  
  ::payment::v1alpha1::SubscriptionItemsList* temp = subscription_items_list_;
  subscription_items_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::SubscriptionItemsList* ListSubscriptionItemsResponse::_internal_mutable_subscription_items_list() {
  
  if (subscription_items_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::SubscriptionItemsList>(GetArenaForAllocation());
    subscription_items_list_ = p;
  }
  return subscription_items_list_;
}
inline ::payment::v1alpha1::SubscriptionItemsList* ListSubscriptionItemsResponse::mutable_subscription_items_list() {
  ::payment::v1alpha1::SubscriptionItemsList* _msg = _internal_mutable_subscription_items_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListSubscriptionItemsResponse.subscription_items_list)
  return _msg;
}
inline void ListSubscriptionItemsResponse::set_allocated_subscription_items_list(::payment::v1alpha1::SubscriptionItemsList* subscription_items_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_items_list_);
  }
  if (subscription_items_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_items_list));
    if (message_arena != submessage_arena) {
      subscription_items_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscription_items_list, submessage_arena);
    }
    
  } else {
    
  }
  subscription_items_list_ = subscription_items_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListSubscriptionItemsResponse.subscription_items_list)
}

// string status = 3 [json_name = "status"];
inline void ListSubscriptionItemsResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& ListSubscriptionItemsResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListSubscriptionItemsResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListSubscriptionItemsResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListSubscriptionItemsResponse.status)
}
inline std::string* ListSubscriptionItemsResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListSubscriptionItemsResponse.status)
  return _s;
}
inline const std::string& ListSubscriptionItemsResponse::_internal_status() const {
  return status_.Get();
}
inline void ListSubscriptionItemsResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListSubscriptionItemsResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListSubscriptionItemsResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListSubscriptionItemsResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListSubscriptionItemsResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListSubscriptionItemsResponse.status)
}

// -------------------------------------------------------------------

// ListProjectsRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void ListProjectsRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListProjectsRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListProjectsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListProjectsRequest.organization_id)
  return _internal_organization_id();
}
inline void ListProjectsRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void ListProjectsRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListProjectsRequest.organization_id)
}

// -------------------------------------------------------------------

// ListProjectsResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool ListProjectsResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool ListProjectsResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& ListProjectsResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& ListProjectsResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListProjectsResponse.customer)
  return _internal_customer();
}
inline void ListProjectsResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.ListProjectsResponse.customer)
}
inline ::payment::v1alpha1::Customer* ListProjectsResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* ListProjectsResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListProjectsResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* ListProjectsResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* ListProjectsResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListProjectsResponse.customer)
  return _msg;
}
inline void ListProjectsResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListProjectsResponse.customer)
}

// string status = 2 [json_name = "status"];
inline void ListProjectsResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& ListProjectsResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListProjectsResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListProjectsResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListProjectsResponse.status)
}
inline std::string* ListProjectsResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListProjectsResponse.status)
  return _s;
}
inline const std::string& ListProjectsResponse::_internal_status() const {
  return status_.Get();
}
inline void ListProjectsResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListProjectsResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListProjectsResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListProjectsResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListProjectsResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListProjectsResponse.status)
}

// -------------------------------------------------------------------

// GetProjectRequest

// string organization_id = 1 [json_name = "organizationId"];
inline void GetProjectRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& GetProjectRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetProjectRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProjectRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetProjectRequest.organization_id)
}
inline std::string* GetProjectRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetProjectRequest.organization_id)
  return _s;
}
inline const std::string& GetProjectRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void GetProjectRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetProjectRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetProjectRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetProjectRequest.organization_id)
  return organization_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetProjectRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), organization_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetProjectRequest.organization_id)
}

// string project_id = 2 [json_name = "projectId"];
inline void GetProjectRequest::clear_project_id() {
  project_id_.ClearToEmpty();
}
inline const std::string& GetProjectRequest::project_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetProjectRequest.project_id)
  return _internal_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProjectRequest::set_project_id(ArgT0&& arg0, ArgT... args) {
 
 project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetProjectRequest.project_id)
}
inline std::string* GetProjectRequest::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetProjectRequest.project_id)
  return _s;
}
inline const std::string& GetProjectRequest::_internal_project_id() const {
  return project_id_.Get();
}
inline void GetProjectRequest::_internal_set_project_id(const std::string& value) {
  
  project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetProjectRequest::_internal_mutable_project_id() {
  
  return project_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetProjectRequest::release_project_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetProjectRequest.project_id)
  return project_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetProjectRequest::set_allocated_project_id(std::string* project_id) {
  if (project_id != nullptr) {
    
  } else {
    
  }
  project_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetProjectRequest.project_id)
}

// -------------------------------------------------------------------

// GetProjectResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool GetProjectResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool GetProjectResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& GetProjectResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& GetProjectResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetProjectResponse.customer)
  return _internal_customer();
}
inline void GetProjectResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetProjectResponse.customer)
}
inline ::payment::v1alpha1::Customer* GetProjectResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* GetProjectResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetProjectResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* GetProjectResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* GetProjectResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetProjectResponse.customer)
  return _msg;
}
inline void GetProjectResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetProjectResponse.customer)
}

// string status = 2 [json_name = "status"];
inline void GetProjectResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetProjectResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetProjectResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProjectResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetProjectResponse.status)
}
inline std::string* GetProjectResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetProjectResponse.status)
  return _s;
}
inline const std::string& GetProjectResponse::_internal_status() const {
  return status_.Get();
}
inline void GetProjectResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetProjectResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetProjectResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetProjectResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetProjectResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetProjectResponse.status)
}

// -------------------------------------------------------------------

// DeleteProjectRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void DeleteProjectRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteProjectRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteProjectRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteProjectRequest.organization_id)
  return _internal_organization_id();
}
inline void DeleteProjectRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void DeleteProjectRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeleteProjectRequest.organization_id)
}

// string project_id = 2 [json_name = "projectId"];
inline void DeleteProjectRequest::clear_project_id() {
  project_id_.ClearToEmpty();
}
inline const std::string& DeleteProjectRequest::project_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteProjectRequest.project_id)
  return _internal_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteProjectRequest::set_project_id(ArgT0&& arg0, ArgT... args) {
 
 project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeleteProjectRequest.project_id)
}
inline std::string* DeleteProjectRequest::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeleteProjectRequest.project_id)
  return _s;
}
inline const std::string& DeleteProjectRequest::_internal_project_id() const {
  return project_id_.Get();
}
inline void DeleteProjectRequest::_internal_set_project_id(const std::string& value) {
  
  project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteProjectRequest::_internal_mutable_project_id() {
  
  return project_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteProjectRequest::release_project_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeleteProjectRequest.project_id)
  return project_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteProjectRequest::set_allocated_project_id(std::string* project_id) {
  if (project_id != nullptr) {
    
  } else {
    
  }
  project_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeleteProjectRequest.project_id)
}

// .payment.v1alpha1.Project project = 3 [json_name = "project"];
inline bool DeleteProjectRequest::_internal_has_project() const {
  return this != internal_default_instance() && project_ != nullptr;
}
inline bool DeleteProjectRequest::has_project() const {
  return _internal_has_project();
}
inline const ::payment::v1alpha1::Project& DeleteProjectRequest::_internal_project() const {
  const ::payment::v1alpha1::Project* p = project_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Project&>(
      ::payment::v1alpha1::_Project_default_instance_);
}
inline const ::payment::v1alpha1::Project& DeleteProjectRequest::project() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteProjectRequest.project)
  return _internal_project();
}
inline void DeleteProjectRequest::unsafe_arena_set_allocated_project(
    ::payment::v1alpha1::Project* project) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_);
  }
  project_ = project;
  if (project) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.DeleteProjectRequest.project)
}
inline ::payment::v1alpha1::Project* DeleteProjectRequest::release_project() {
  
  ::payment::v1alpha1::Project* temp = project_;
  project_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Project* DeleteProjectRequest::unsafe_arena_release_project() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeleteProjectRequest.project)
  
  ::payment::v1alpha1::Project* temp = project_;
  project_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Project* DeleteProjectRequest::_internal_mutable_project() {
  
  if (project_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Project>(GetArenaForAllocation());
    project_ = p;
  }
  return project_;
}
inline ::payment::v1alpha1::Project* DeleteProjectRequest::mutable_project() {
  ::payment::v1alpha1::Project* _msg = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeleteProjectRequest.project)
  return _msg;
}
inline void DeleteProjectRequest::set_allocated_project(::payment::v1alpha1::Project* project) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_);
  }
  if (project) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project));
    if (message_arena != submessage_arena) {
      project = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, project, submessage_arena);
    }
    
  } else {
    
  }
  project_ = project;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeleteProjectRequest.project)
}

// -------------------------------------------------------------------

// DeleteProjectResponse

// string status = 1 [json_name = "status"];
inline void DeleteProjectResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& DeleteProjectResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteProjectResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteProjectResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeleteProjectResponse.status)
}
inline std::string* DeleteProjectResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeleteProjectResponse.status)
  return _s;
}
inline const std::string& DeleteProjectResponse::_internal_status() const {
  return status_.Get();
}
inline void DeleteProjectResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteProjectResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteProjectResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeleteProjectResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteProjectResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeleteProjectResponse.status)
}

// -------------------------------------------------------------------

// SetDefaultPaymentMethodRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void SetDefaultPaymentMethodRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SetDefaultPaymentMethodRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SetDefaultPaymentMethodRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.SetDefaultPaymentMethodRequest.organization_id)
  return _internal_organization_id();
}
inline void SetDefaultPaymentMethodRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void SetDefaultPaymentMethodRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.SetDefaultPaymentMethodRequest.organization_id)
}

// string card_id = 2 [json_name = "cardId"];
inline void SetDefaultPaymentMethodRequest::clear_card_id() {
  card_id_.ClearToEmpty();
}
inline const std::string& SetDefaultPaymentMethodRequest::card_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.SetDefaultPaymentMethodRequest.card_id)
  return _internal_card_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetDefaultPaymentMethodRequest::set_card_id(ArgT0&& arg0, ArgT... args) {
 
 card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.SetDefaultPaymentMethodRequest.card_id)
}
inline std::string* SetDefaultPaymentMethodRequest::mutable_card_id() {
  std::string* _s = _internal_mutable_card_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.SetDefaultPaymentMethodRequest.card_id)
  return _s;
}
inline const std::string& SetDefaultPaymentMethodRequest::_internal_card_id() const {
  return card_id_.Get();
}
inline void SetDefaultPaymentMethodRequest::_internal_set_card_id(const std::string& value) {
  
  card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetDefaultPaymentMethodRequest::_internal_mutable_card_id() {
  
  return card_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetDefaultPaymentMethodRequest::release_card_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.SetDefaultPaymentMethodRequest.card_id)
  return card_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetDefaultPaymentMethodRequest::set_allocated_card_id(std::string* card_id) {
  if (card_id != nullptr) {
    
  } else {
    
  }
  card_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.SetDefaultPaymentMethodRequest.card_id)
}

// -------------------------------------------------------------------

// SetDefaultPaymentMethodResponse

// string msg = 1 [json_name = "msg"];
inline void SetDefaultPaymentMethodResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& SetDefaultPaymentMethodResponse::msg() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.SetDefaultPaymentMethodResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetDefaultPaymentMethodResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.SetDefaultPaymentMethodResponse.msg)
}
inline std::string* SetDefaultPaymentMethodResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.SetDefaultPaymentMethodResponse.msg)
  return _s;
}
inline const std::string& SetDefaultPaymentMethodResponse::_internal_msg() const {
  return msg_.Get();
}
inline void SetDefaultPaymentMethodResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetDefaultPaymentMethodResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetDefaultPaymentMethodResponse::release_msg() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.SetDefaultPaymentMethodResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetDefaultPaymentMethodResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.SetDefaultPaymentMethodResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void SetDefaultPaymentMethodResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& SetDefaultPaymentMethodResponse::error() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.SetDefaultPaymentMethodResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetDefaultPaymentMethodResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.SetDefaultPaymentMethodResponse.error)
}
inline std::string* SetDefaultPaymentMethodResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.SetDefaultPaymentMethodResponse.error)
  return _s;
}
inline const std::string& SetDefaultPaymentMethodResponse::_internal_error() const {
  return error_.Get();
}
inline void SetDefaultPaymentMethodResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetDefaultPaymentMethodResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetDefaultPaymentMethodResponse::release_error() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.SetDefaultPaymentMethodResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetDefaultPaymentMethodResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.SetDefaultPaymentMethodResponse.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace payment

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_payment_2fv1alpha1_2fpayment_5fapi_2eproto
