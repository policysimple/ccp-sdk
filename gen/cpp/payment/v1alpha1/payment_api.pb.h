// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: payment/v1alpha1/payment_api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_payment_2fv1alpha1_2fpayment_5fapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_payment_2fv1alpha1_2fpayment_5fapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "payment/v1alpha1/payment.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_payment_2fv1alpha1_2fpayment_5fapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[36]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
namespace payment {
namespace v1alpha1 {
class CancelSuscriptionRequest;
struct CancelSuscriptionRequestDefaultTypeInternal;
extern CancelSuscriptionRequestDefaultTypeInternal _CancelSuscriptionRequest_default_instance_;
class CancelSuscriptionResponse;
struct CancelSuscriptionResponseDefaultTypeInternal;
extern CancelSuscriptionResponseDefaultTypeInternal _CancelSuscriptionResponse_default_instance_;
class CreateCardRequest;
struct CreateCardRequestDefaultTypeInternal;
extern CreateCardRequestDefaultTypeInternal _CreateCardRequest_default_instance_;
class CreateCardResponse;
struct CreateCardResponseDefaultTypeInternal;
extern CreateCardResponseDefaultTypeInternal _CreateCardResponse_default_instance_;
class CreateCustomerRequest;
struct CreateCustomerRequestDefaultTypeInternal;
extern CreateCustomerRequestDefaultTypeInternal _CreateCustomerRequest_default_instance_;
class CreateCustomerResponse;
struct CreateCustomerResponseDefaultTypeInternal;
extern CreateCustomerResponseDefaultTypeInternal _CreateCustomerResponse_default_instance_;
class CreateInvoiceRequest;
struct CreateInvoiceRequestDefaultTypeInternal;
extern CreateInvoiceRequestDefaultTypeInternal _CreateInvoiceRequest_default_instance_;
class CreateInvoiceResponse;
struct CreateInvoiceResponseDefaultTypeInternal;
extern CreateInvoiceResponseDefaultTypeInternal _CreateInvoiceResponse_default_instance_;
class CreatePaymentRequest;
struct CreatePaymentRequestDefaultTypeInternal;
extern CreatePaymentRequestDefaultTypeInternal _CreatePaymentRequest_default_instance_;
class CreatePaymentResponse;
struct CreatePaymentResponseDefaultTypeInternal;
extern CreatePaymentResponseDefaultTypeInternal _CreatePaymentResponse_default_instance_;
class CreateSuscriptionRequest;
struct CreateSuscriptionRequestDefaultTypeInternal;
extern CreateSuscriptionRequestDefaultTypeInternal _CreateSuscriptionRequest_default_instance_;
class CreateSuscriptionResponse;
struct CreateSuscriptionResponseDefaultTypeInternal;
extern CreateSuscriptionResponseDefaultTypeInternal _CreateSuscriptionResponse_default_instance_;
class DeleteCustomerRequest;
struct DeleteCustomerRequestDefaultTypeInternal;
extern DeleteCustomerRequestDefaultTypeInternal _DeleteCustomerRequest_default_instance_;
class DeleteCustomerResponse;
struct DeleteCustomerResponseDefaultTypeInternal;
extern DeleteCustomerResponseDefaultTypeInternal _DeleteCustomerResponse_default_instance_;
class DeletePaymentRequest;
struct DeletePaymentRequestDefaultTypeInternal;
extern DeletePaymentRequestDefaultTypeInternal _DeletePaymentRequest_default_instance_;
class DeletePaymentResponse;
struct DeletePaymentResponseDefaultTypeInternal;
extern DeletePaymentResponseDefaultTypeInternal _DeletePaymentResponse_default_instance_;
class GetBilingMonthRequest;
struct GetBilingMonthRequestDefaultTypeInternal;
extern GetBilingMonthRequestDefaultTypeInternal _GetBilingMonthRequest_default_instance_;
class GetBilingMonthResponse;
struct GetBilingMonthResponseDefaultTypeInternal;
extern GetBilingMonthResponseDefaultTypeInternal _GetBilingMonthResponse_default_instance_;
class GetCustomerRequest;
struct GetCustomerRequestDefaultTypeInternal;
extern GetCustomerRequestDefaultTypeInternal _GetCustomerRequest_default_instance_;
class GetCustomerResponse;
struct GetCustomerResponseDefaultTypeInternal;
extern GetCustomerResponseDefaultTypeInternal _GetCustomerResponse_default_instance_;
class GetOrganizationPaymentRequest;
struct GetOrganizationPaymentRequestDefaultTypeInternal;
extern GetOrganizationPaymentRequestDefaultTypeInternal _GetOrganizationPaymentRequest_default_instance_;
class GetOrganizationPaymentResponse;
struct GetOrganizationPaymentResponseDefaultTypeInternal;
extern GetOrganizationPaymentResponseDefaultTypeInternal _GetOrganizationPaymentResponse_default_instance_;
class GetPaymentRequest;
struct GetPaymentRequestDefaultTypeInternal;
extern GetPaymentRequestDefaultTypeInternal _GetPaymentRequest_default_instance_;
class GetPaymentResponse;
struct GetPaymentResponseDefaultTypeInternal;
extern GetPaymentResponseDefaultTypeInternal _GetPaymentResponse_default_instance_;
class GetPaymentsRequest;
struct GetPaymentsRequestDefaultTypeInternal;
extern GetPaymentsRequestDefaultTypeInternal _GetPaymentsRequest_default_instance_;
class GetPaymentsResponse;
struct GetPaymentsResponseDefaultTypeInternal;
extern GetPaymentsResponseDefaultTypeInternal _GetPaymentsResponse_default_instance_;
class GetSuscriptionRequest;
struct GetSuscriptionRequestDefaultTypeInternal;
extern GetSuscriptionRequestDefaultTypeInternal _GetSuscriptionRequest_default_instance_;
class GetSuscriptionResponse;
struct GetSuscriptionResponseDefaultTypeInternal;
extern GetSuscriptionResponseDefaultTypeInternal _GetSuscriptionResponse_default_instance_;
class InvoiceFilterRequest;
struct InvoiceFilterRequestDefaultTypeInternal;
extern InvoiceFilterRequestDefaultTypeInternal _InvoiceFilterRequest_default_instance_;
class InvoiceFilterResponse;
struct InvoiceFilterResponseDefaultTypeInternal;
extern InvoiceFilterResponseDefaultTypeInternal _InvoiceFilterResponse_default_instance_;
class ListPaymentRequest;
struct ListPaymentRequestDefaultTypeInternal;
extern ListPaymentRequestDefaultTypeInternal _ListPaymentRequest_default_instance_;
class ListPaymentResponse;
struct ListPaymentResponseDefaultTypeInternal;
extern ListPaymentResponseDefaultTypeInternal _ListPaymentResponse_default_instance_;
class UpdatePaymentRequest;
struct UpdatePaymentRequestDefaultTypeInternal;
extern UpdatePaymentRequestDefaultTypeInternal _UpdatePaymentRequest_default_instance_;
class UpdatePaymentResponse;
struct UpdatePaymentResponseDefaultTypeInternal;
extern UpdatePaymentResponseDefaultTypeInternal _UpdatePaymentResponse_default_instance_;
class UpdateSuscriptionRequest;
struct UpdateSuscriptionRequestDefaultTypeInternal;
extern UpdateSuscriptionRequestDefaultTypeInternal _UpdateSuscriptionRequest_default_instance_;
class UpdateSuscriptionResponse;
struct UpdateSuscriptionResponseDefaultTypeInternal;
extern UpdateSuscriptionResponseDefaultTypeInternal _UpdateSuscriptionResponse_default_instance_;
}  // namespace v1alpha1
}  // namespace payment
PROTOBUF_NAMESPACE_OPEN
template<> ::payment::v1alpha1::CancelSuscriptionRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CancelSuscriptionRequest>(Arena*);
template<> ::payment::v1alpha1::CancelSuscriptionResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CancelSuscriptionResponse>(Arena*);
template<> ::payment::v1alpha1::CreateCardRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateCardRequest>(Arena*);
template<> ::payment::v1alpha1::CreateCardResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateCardResponse>(Arena*);
template<> ::payment::v1alpha1::CreateCustomerRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateCustomerRequest>(Arena*);
template<> ::payment::v1alpha1::CreateCustomerResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateCustomerResponse>(Arena*);
template<> ::payment::v1alpha1::CreateInvoiceRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateInvoiceRequest>(Arena*);
template<> ::payment::v1alpha1::CreateInvoiceResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateInvoiceResponse>(Arena*);
template<> ::payment::v1alpha1::CreatePaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreatePaymentRequest>(Arena*);
template<> ::payment::v1alpha1::CreatePaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreatePaymentResponse>(Arena*);
template<> ::payment::v1alpha1::CreateSuscriptionRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateSuscriptionRequest>(Arena*);
template<> ::payment::v1alpha1::CreateSuscriptionResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::CreateSuscriptionResponse>(Arena*);
template<> ::payment::v1alpha1::DeleteCustomerRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::DeleteCustomerRequest>(Arena*);
template<> ::payment::v1alpha1::DeleteCustomerResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::DeleteCustomerResponse>(Arena*);
template<> ::payment::v1alpha1::DeletePaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::DeletePaymentRequest>(Arena*);
template<> ::payment::v1alpha1::DeletePaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::DeletePaymentResponse>(Arena*);
template<> ::payment::v1alpha1::GetBilingMonthRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetBilingMonthRequest>(Arena*);
template<> ::payment::v1alpha1::GetBilingMonthResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetBilingMonthResponse>(Arena*);
template<> ::payment::v1alpha1::GetCustomerRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetCustomerRequest>(Arena*);
template<> ::payment::v1alpha1::GetCustomerResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetCustomerResponse>(Arena*);
template<> ::payment::v1alpha1::GetOrganizationPaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetOrganizationPaymentRequest>(Arena*);
template<> ::payment::v1alpha1::GetOrganizationPaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetOrganizationPaymentResponse>(Arena*);
template<> ::payment::v1alpha1::GetPaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetPaymentRequest>(Arena*);
template<> ::payment::v1alpha1::GetPaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetPaymentResponse>(Arena*);
template<> ::payment::v1alpha1::GetPaymentsRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetPaymentsRequest>(Arena*);
template<> ::payment::v1alpha1::GetPaymentsResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetPaymentsResponse>(Arena*);
template<> ::payment::v1alpha1::GetSuscriptionRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::GetSuscriptionRequest>(Arena*);
template<> ::payment::v1alpha1::GetSuscriptionResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::GetSuscriptionResponse>(Arena*);
template<> ::payment::v1alpha1::InvoiceFilterRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::InvoiceFilterRequest>(Arena*);
template<> ::payment::v1alpha1::InvoiceFilterResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::InvoiceFilterResponse>(Arena*);
template<> ::payment::v1alpha1::ListPaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::ListPaymentRequest>(Arena*);
template<> ::payment::v1alpha1::ListPaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::ListPaymentResponse>(Arena*);
template<> ::payment::v1alpha1::UpdatePaymentRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::UpdatePaymentRequest>(Arena*);
template<> ::payment::v1alpha1::UpdatePaymentResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::UpdatePaymentResponse>(Arena*);
template<> ::payment::v1alpha1::UpdateSuscriptionRequest* Arena::CreateMaybeMessage<::payment::v1alpha1::UpdateSuscriptionRequest>(Arena*);
template<> ::payment::v1alpha1::UpdateSuscriptionResponse* Arena::CreateMaybeMessage<::payment::v1alpha1::UpdateSuscriptionResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace payment {
namespace v1alpha1 {

// ===================================================================

class InvoiceFilterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.InvoiceFilterRequest) */ {
 public:
  inline InvoiceFilterRequest() : InvoiceFilterRequest(nullptr) {}
  ~InvoiceFilterRequest() override;
  explicit constexpr InvoiceFilterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvoiceFilterRequest(const InvoiceFilterRequest& from);
  InvoiceFilterRequest(InvoiceFilterRequest&& from) noexcept
    : InvoiceFilterRequest() {
    *this = ::std::move(from);
  }

  inline InvoiceFilterRequest& operator=(const InvoiceFilterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvoiceFilterRequest& operator=(InvoiceFilterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvoiceFilterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvoiceFilterRequest* internal_default_instance() {
    return reinterpret_cast<const InvoiceFilterRequest*>(
               &_InvoiceFilterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InvoiceFilterRequest& a, InvoiceFilterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InvoiceFilterRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvoiceFilterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InvoiceFilterRequest* New() const final {
    return new InvoiceFilterRequest();
  }

  InvoiceFilterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InvoiceFilterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvoiceFilterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvoiceFilterRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvoiceFilterRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.InvoiceFilterRequest";
  }
  protected:
  explicit InvoiceFilterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYearFieldNumber = 1,
    kMonthFieldNumber = 2,
    kCustomerListFieldNumber = 3,
    kOrganizationIdFieldNumber = 4,
  };
  // string year = 1 [json_name = "year"];
  void clear_year();
  const std::string& year() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_year(ArgT0&& arg0, ArgT... args);
  std::string* mutable_year();
  PROTOBUF_MUST_USE_RESULT std::string* release_year();
  void set_allocated_year(std::string* year);
  private:
  const std::string& _internal_year() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_year(const std::string& value);
  std::string* _internal_mutable_year();
  public:

  // string month = 2 [json_name = "month"];
  void clear_month();
  const std::string& month() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_month(ArgT0&& arg0, ArgT... args);
  std::string* mutable_month();
  PROTOBUF_MUST_USE_RESULT std::string* release_month();
  void set_allocated_month(std::string* month);
  private:
  const std::string& _internal_month() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_month(const std::string& value);
  std::string* _internal_mutable_month();
  public:

  // .payment.v1alpha1.CustomerList customer_list = 3 [json_name = "customerList"];
  bool has_customer_list() const;
  private:
  bool _internal_has_customer_list() const;
  public:
  void clear_customer_list();
  const ::payment::v1alpha1::CustomerList& customer_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::CustomerList* release_customer_list();
  ::payment::v1alpha1::CustomerList* mutable_customer_list();
  void set_allocated_customer_list(::payment::v1alpha1::CustomerList* customer_list);
  private:
  const ::payment::v1alpha1::CustomerList& _internal_customer_list() const;
  ::payment::v1alpha1::CustomerList* _internal_mutable_customer_list();
  public:
  void unsafe_arena_set_allocated_customer_list(
      ::payment::v1alpha1::CustomerList* customer_list);
  ::payment::v1alpha1::CustomerList* unsafe_arena_release_customer_list();

  // uint32 organization_id = 4 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.InvoiceFilterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr year_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr month_;
  ::payment::v1alpha1::CustomerList* customer_list_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class InvoiceFilterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.InvoiceFilterResponse) */ {
 public:
  inline InvoiceFilterResponse() : InvoiceFilterResponse(nullptr) {}
  ~InvoiceFilterResponse() override;
  explicit constexpr InvoiceFilterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvoiceFilterResponse(const InvoiceFilterResponse& from);
  InvoiceFilterResponse(InvoiceFilterResponse&& from) noexcept
    : InvoiceFilterResponse() {
    *this = ::std::move(from);
  }

  inline InvoiceFilterResponse& operator=(const InvoiceFilterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvoiceFilterResponse& operator=(InvoiceFilterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvoiceFilterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvoiceFilterResponse* internal_default_instance() {
    return reinterpret_cast<const InvoiceFilterResponse*>(
               &_InvoiceFilterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InvoiceFilterResponse& a, InvoiceFilterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InvoiceFilterResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvoiceFilterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InvoiceFilterResponse* New() const final {
    return new InvoiceFilterResponse();
  }

  InvoiceFilterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InvoiceFilterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvoiceFilterResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvoiceFilterResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvoiceFilterResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.InvoiceFilterResponse";
  }
  protected:
  explicit InvoiceFilterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 4,
    kCustomerListFieldNumber = 1,
    kInvoiceListFieldNumber = 2,
    kBilingListFieldNumber = 3,
  };
  // string status = 4 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.CustomerList customer_list = 1 [json_name = "customerList"];
  bool has_customer_list() const;
  private:
  bool _internal_has_customer_list() const;
  public:
  void clear_customer_list();
  const ::payment::v1alpha1::CustomerList& customer_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::CustomerList* release_customer_list();
  ::payment::v1alpha1::CustomerList* mutable_customer_list();
  void set_allocated_customer_list(::payment::v1alpha1::CustomerList* customer_list);
  private:
  const ::payment::v1alpha1::CustomerList& _internal_customer_list() const;
  ::payment::v1alpha1::CustomerList* _internal_mutable_customer_list();
  public:
  void unsafe_arena_set_allocated_customer_list(
      ::payment::v1alpha1::CustomerList* customer_list);
  ::payment::v1alpha1::CustomerList* unsafe_arena_release_customer_list();

  // .payment.v1alpha1.InvoiceList invoice_list = 2 [json_name = "invoiceList"];
  bool has_invoice_list() const;
  private:
  bool _internal_has_invoice_list() const;
  public:
  void clear_invoice_list();
  const ::payment::v1alpha1::InvoiceList& invoice_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::InvoiceList* release_invoice_list();
  ::payment::v1alpha1::InvoiceList* mutable_invoice_list();
  void set_allocated_invoice_list(::payment::v1alpha1::InvoiceList* invoice_list);
  private:
  const ::payment::v1alpha1::InvoiceList& _internal_invoice_list() const;
  ::payment::v1alpha1::InvoiceList* _internal_mutable_invoice_list();
  public:
  void unsafe_arena_set_allocated_invoice_list(
      ::payment::v1alpha1::InvoiceList* invoice_list);
  ::payment::v1alpha1::InvoiceList* unsafe_arena_release_invoice_list();

  // .payment.v1alpha1.BilingList biling_list = 3 [json_name = "bilingList"];
  bool has_biling_list() const;
  private:
  bool _internal_has_biling_list() const;
  public:
  void clear_biling_list();
  const ::payment::v1alpha1::BilingList& biling_list() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::BilingList* release_biling_list();
  ::payment::v1alpha1::BilingList* mutable_biling_list();
  void set_allocated_biling_list(::payment::v1alpha1::BilingList* biling_list);
  private:
  const ::payment::v1alpha1::BilingList& _internal_biling_list() const;
  ::payment::v1alpha1::BilingList* _internal_mutable_biling_list();
  public:
  void unsafe_arena_set_allocated_biling_list(
      ::payment::v1alpha1::BilingList* biling_list);
  ::payment::v1alpha1::BilingList* unsafe_arena_release_biling_list();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.InvoiceFilterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::CustomerList* customer_list_;
  ::payment::v1alpha1::InvoiceList* invoice_list_;
  ::payment::v1alpha1::BilingList* biling_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteCustomerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeleteCustomerRequest) */ {
 public:
  inline DeleteCustomerRequest() : DeleteCustomerRequest(nullptr) {}
  ~DeleteCustomerRequest() override;
  explicit constexpr DeleteCustomerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteCustomerRequest(const DeleteCustomerRequest& from);
  DeleteCustomerRequest(DeleteCustomerRequest&& from) noexcept
    : DeleteCustomerRequest() {
    *this = ::std::move(from);
  }

  inline DeleteCustomerRequest& operator=(const DeleteCustomerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteCustomerRequest& operator=(DeleteCustomerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteCustomerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteCustomerRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteCustomerRequest*>(
               &_DeleteCustomerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DeleteCustomerRequest& a, DeleteCustomerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteCustomerRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteCustomerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteCustomerRequest* New() const final {
    return new DeleteCustomerRequest();
  }

  DeleteCustomerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteCustomerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteCustomerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteCustomerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteCustomerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeleteCustomerRequest";
  }
  protected:
  explicit DeleteCustomerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 1,
  };
  // string customer_id = 1 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeleteCustomerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteCustomerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeleteCustomerResponse) */ {
 public:
  inline DeleteCustomerResponse() : DeleteCustomerResponse(nullptr) {}
  ~DeleteCustomerResponse() override;
  explicit constexpr DeleteCustomerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteCustomerResponse(const DeleteCustomerResponse& from);
  DeleteCustomerResponse(DeleteCustomerResponse&& from) noexcept
    : DeleteCustomerResponse() {
    *this = ::std::move(from);
  }

  inline DeleteCustomerResponse& operator=(const DeleteCustomerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteCustomerResponse& operator=(DeleteCustomerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteCustomerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteCustomerResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteCustomerResponse*>(
               &_DeleteCustomerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeleteCustomerResponse& a, DeleteCustomerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteCustomerResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteCustomerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteCustomerResponse* New() const final {
    return new DeleteCustomerResponse();
  }

  DeleteCustomerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteCustomerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteCustomerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteCustomerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteCustomerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeleteCustomerResponse";
  }
  protected:
  explicit DeleteCustomerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeleteCustomerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetSuscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetSuscriptionRequest) */ {
 public:
  inline GetSuscriptionRequest() : GetSuscriptionRequest(nullptr) {}
  ~GetSuscriptionRequest() override;
  explicit constexpr GetSuscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSuscriptionRequest(const GetSuscriptionRequest& from);
  GetSuscriptionRequest(GetSuscriptionRequest&& from) noexcept
    : GetSuscriptionRequest() {
    *this = ::std::move(from);
  }

  inline GetSuscriptionRequest& operator=(const GetSuscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSuscriptionRequest& operator=(GetSuscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSuscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSuscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const GetSuscriptionRequest*>(
               &_GetSuscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetSuscriptionRequest& a, GetSuscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSuscriptionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSuscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetSuscriptionRequest* New() const final {
    return new GetSuscriptionRequest();
  }

  GetSuscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetSuscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSuscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSuscriptionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSuscriptionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetSuscriptionRequest";
  }
  protected:
  explicit GetSuscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuscriptionIdFieldNumber = 1,
  };
  // string suscription_id = 1 [json_name = "suscriptionId"];
  void clear_suscription_id();
  const std::string& suscription_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_suscription_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_suscription_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_suscription_id();
  void set_allocated_suscription_id(std::string* suscription_id);
  private:
  const std::string& _internal_suscription_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suscription_id(const std::string& value);
  std::string* _internal_mutable_suscription_id();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetSuscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr suscription_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetSuscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetSuscriptionResponse) */ {
 public:
  inline GetSuscriptionResponse() : GetSuscriptionResponse(nullptr) {}
  ~GetSuscriptionResponse() override;
  explicit constexpr GetSuscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSuscriptionResponse(const GetSuscriptionResponse& from);
  GetSuscriptionResponse(GetSuscriptionResponse&& from) noexcept
    : GetSuscriptionResponse() {
    *this = ::std::move(from);
  }

  inline GetSuscriptionResponse& operator=(const GetSuscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSuscriptionResponse& operator=(GetSuscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSuscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSuscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const GetSuscriptionResponse*>(
               &_GetSuscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetSuscriptionResponse& a, GetSuscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSuscriptionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSuscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetSuscriptionResponse* New() const final {
    return new GetSuscriptionResponse();
  }

  GetSuscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetSuscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSuscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSuscriptionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSuscriptionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetSuscriptionResponse";
  }
  protected:
  explicit GetSuscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kSuscriptionFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Suscription suscription = 1 [json_name = "suscription"];
  bool has_suscription() const;
  private:
  bool _internal_has_suscription() const;
  public:
  void clear_suscription();
  const ::payment::v1alpha1::Suscription& suscription() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Suscription* release_suscription();
  ::payment::v1alpha1::Suscription* mutable_suscription();
  void set_allocated_suscription(::payment::v1alpha1::Suscription* suscription);
  private:
  const ::payment::v1alpha1::Suscription& _internal_suscription() const;
  ::payment::v1alpha1::Suscription* _internal_mutable_suscription();
  public:
  void unsafe_arena_set_allocated_suscription(
      ::payment::v1alpha1::Suscription* suscription);
  ::payment::v1alpha1::Suscription* unsafe_arena_release_suscription();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetSuscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Suscription* suscription_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationPaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetOrganizationPaymentRequest) */ {
 public:
  inline GetOrganizationPaymentRequest() : GetOrganizationPaymentRequest(nullptr) {}
  ~GetOrganizationPaymentRequest() override;
  explicit constexpr GetOrganizationPaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationPaymentRequest(const GetOrganizationPaymentRequest& from);
  GetOrganizationPaymentRequest(GetOrganizationPaymentRequest&& from) noexcept
    : GetOrganizationPaymentRequest() {
    *this = ::std::move(from);
  }

  inline GetOrganizationPaymentRequest& operator=(const GetOrganizationPaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationPaymentRequest& operator=(GetOrganizationPaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationPaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationPaymentRequest* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationPaymentRequest*>(
               &_GetOrganizationPaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetOrganizationPaymentRequest& a, GetOrganizationPaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationPaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationPaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetOrganizationPaymentRequest* New() const final {
    return new GetOrganizationPaymentRequest();
  }

  GetOrganizationPaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOrganizationPaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationPaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationPaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationPaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetOrganizationPaymentRequest";
  }
  protected:
  explicit GetOrganizationPaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetOrganizationPaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetOrganizationPaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetOrganizationPaymentResponse) */ {
 public:
  inline GetOrganizationPaymentResponse() : GetOrganizationPaymentResponse(nullptr) {}
  ~GetOrganizationPaymentResponse() override;
  explicit constexpr GetOrganizationPaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOrganizationPaymentResponse(const GetOrganizationPaymentResponse& from);
  GetOrganizationPaymentResponse(GetOrganizationPaymentResponse&& from) noexcept
    : GetOrganizationPaymentResponse() {
    *this = ::std::move(from);
  }

  inline GetOrganizationPaymentResponse& operator=(const GetOrganizationPaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOrganizationPaymentResponse& operator=(GetOrganizationPaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOrganizationPaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOrganizationPaymentResponse* internal_default_instance() {
    return reinterpret_cast<const GetOrganizationPaymentResponse*>(
               &_GetOrganizationPaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetOrganizationPaymentResponse& a, GetOrganizationPaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOrganizationPaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOrganizationPaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetOrganizationPaymentResponse* New() const final {
    return new GetOrganizationPaymentResponse();
  }

  GetOrganizationPaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOrganizationPaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOrganizationPaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOrganizationPaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrganizationPaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetOrganizationPaymentResponse";
  }
  protected:
  explicit GetOrganizationPaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 3,
    kCustomerFieldNumber = 1,
  };
  // string status = 3 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetOrganizationPaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetCustomerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetCustomerRequest) */ {
 public:
  inline GetCustomerRequest() : GetCustomerRequest(nullptr) {}
  ~GetCustomerRequest() override;
  explicit constexpr GetCustomerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCustomerRequest(const GetCustomerRequest& from);
  GetCustomerRequest(GetCustomerRequest&& from) noexcept
    : GetCustomerRequest() {
    *this = ::std::move(from);
  }

  inline GetCustomerRequest& operator=(const GetCustomerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCustomerRequest& operator=(GetCustomerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCustomerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCustomerRequest* internal_default_instance() {
    return reinterpret_cast<const GetCustomerRequest*>(
               &_GetCustomerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetCustomerRequest& a, GetCustomerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCustomerRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCustomerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetCustomerRequest* New() const final {
    return new GetCustomerRequest();
  }

  GetCustomerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetCustomerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCustomerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetCustomerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCustomerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetCustomerRequest";
  }
  protected:
  explicit GetCustomerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 1,
  };
  // string customer_id = 1 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetCustomerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetCustomerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetCustomerResponse) */ {
 public:
  inline GetCustomerResponse() : GetCustomerResponse(nullptr) {}
  ~GetCustomerResponse() override;
  explicit constexpr GetCustomerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCustomerResponse(const GetCustomerResponse& from);
  GetCustomerResponse(GetCustomerResponse&& from) noexcept
    : GetCustomerResponse() {
    *this = ::std::move(from);
  }

  inline GetCustomerResponse& operator=(const GetCustomerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCustomerResponse& operator=(GetCustomerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCustomerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCustomerResponse* internal_default_instance() {
    return reinterpret_cast<const GetCustomerResponse*>(
               &_GetCustomerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetCustomerResponse& a, GetCustomerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCustomerResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCustomerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetCustomerResponse* New() const final {
    return new GetCustomerResponse();
  }

  GetCustomerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetCustomerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCustomerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetCustomerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCustomerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetCustomerResponse";
  }
  protected:
  explicit GetCustomerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kCustomerFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetCustomerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetBilingMonthRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetBilingMonthRequest) */ {
 public:
  inline GetBilingMonthRequest() : GetBilingMonthRequest(nullptr) {}
  ~GetBilingMonthRequest() override;
  explicit constexpr GetBilingMonthRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBilingMonthRequest(const GetBilingMonthRequest& from);
  GetBilingMonthRequest(GetBilingMonthRequest&& from) noexcept
    : GetBilingMonthRequest() {
    *this = ::std::move(from);
  }

  inline GetBilingMonthRequest& operator=(const GetBilingMonthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBilingMonthRequest& operator=(GetBilingMonthRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBilingMonthRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBilingMonthRequest* internal_default_instance() {
    return reinterpret_cast<const GetBilingMonthRequest*>(
               &_GetBilingMonthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetBilingMonthRequest& a, GetBilingMonthRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBilingMonthRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBilingMonthRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBilingMonthRequest* New() const final {
    return new GetBilingMonthRequest();
  }

  GetBilingMonthRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBilingMonthRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBilingMonthRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBilingMonthRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBilingMonthRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetBilingMonthRequest";
  }
  protected:
  explicit GetBilingMonthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvoiceIdFieldNumber = 1,
  };
  // string invoice_id = 1 [json_name = "invoiceId"];
  void clear_invoice_id();
  const std::string& invoice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invoice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invoice_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_invoice_id();
  void set_allocated_invoice_id(std::string* invoice_id);
  private:
  const std::string& _internal_invoice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invoice_id(const std::string& value);
  std::string* _internal_mutable_invoice_id();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetBilingMonthRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invoice_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetBilingMonthResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetBilingMonthResponse) */ {
 public:
  inline GetBilingMonthResponse() : GetBilingMonthResponse(nullptr) {}
  ~GetBilingMonthResponse() override;
  explicit constexpr GetBilingMonthResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBilingMonthResponse(const GetBilingMonthResponse& from);
  GetBilingMonthResponse(GetBilingMonthResponse&& from) noexcept
    : GetBilingMonthResponse() {
    *this = ::std::move(from);
  }

  inline GetBilingMonthResponse& operator=(const GetBilingMonthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBilingMonthResponse& operator=(GetBilingMonthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBilingMonthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBilingMonthResponse* internal_default_instance() {
    return reinterpret_cast<const GetBilingMonthResponse*>(
               &_GetBilingMonthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetBilingMonthResponse& a, GetBilingMonthResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBilingMonthResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBilingMonthResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBilingMonthResponse* New() const final {
    return new GetBilingMonthResponse();
  }

  GetBilingMonthResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBilingMonthResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBilingMonthResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBilingMonthResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBilingMonthResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetBilingMonthResponse";
  }
  protected:
  explicit GetBilingMonthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kCustomerFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetBilingMonthResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPaymentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetPaymentsRequest) */ {
 public:
  inline GetPaymentsRequest() : GetPaymentsRequest(nullptr) {}
  ~GetPaymentsRequest() override;
  explicit constexpr GetPaymentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaymentsRequest(const GetPaymentsRequest& from);
  GetPaymentsRequest(GetPaymentsRequest&& from) noexcept
    : GetPaymentsRequest() {
    *this = ::std::move(from);
  }

  inline GetPaymentsRequest& operator=(const GetPaymentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaymentsRequest& operator=(GetPaymentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaymentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaymentsRequest* internal_default_instance() {
    return reinterpret_cast<const GetPaymentsRequest*>(
               &_GetPaymentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetPaymentsRequest& a, GetPaymentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaymentsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaymentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPaymentsRequest* New() const final {
    return new GetPaymentsRequest();
  }

  GetPaymentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPaymentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPaymentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPaymentsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPaymentsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetPaymentsRequest";
  }
  protected:
  explicit GetPaymentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 1,
  };
  // string customer_id = 1 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetPaymentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPaymentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetPaymentsResponse) */ {
 public:
  inline GetPaymentsResponse() : GetPaymentsResponse(nullptr) {}
  ~GetPaymentsResponse() override;
  explicit constexpr GetPaymentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaymentsResponse(const GetPaymentsResponse& from);
  GetPaymentsResponse(GetPaymentsResponse&& from) noexcept
    : GetPaymentsResponse() {
    *this = ::std::move(from);
  }

  inline GetPaymentsResponse& operator=(const GetPaymentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaymentsResponse& operator=(GetPaymentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaymentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaymentsResponse* internal_default_instance() {
    return reinterpret_cast<const GetPaymentsResponse*>(
               &_GetPaymentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetPaymentsResponse& a, GetPaymentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaymentsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaymentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPaymentsResponse* New() const final {
    return new GetPaymentsResponse();
  }

  GetPaymentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPaymentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPaymentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPaymentsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPaymentsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetPaymentsResponse";
  }
  protected:
  explicit GetPaymentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPaymentFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::Payment& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Payment* release_payment();
  ::payment::v1alpha1::Payment* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::Payment* payment);
  private:
  const ::payment::v1alpha1::Payment& _internal_payment() const;
  ::payment::v1alpha1::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::Payment* payment);
  ::payment::v1alpha1::Payment* unsafe_arena_release_payment();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetPaymentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Payment* payment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UpdateSuscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.UpdateSuscriptionRequest) */ {
 public:
  inline UpdateSuscriptionRequest() : UpdateSuscriptionRequest(nullptr) {}
  ~UpdateSuscriptionRequest() override;
  explicit constexpr UpdateSuscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSuscriptionRequest(const UpdateSuscriptionRequest& from);
  UpdateSuscriptionRequest(UpdateSuscriptionRequest&& from) noexcept
    : UpdateSuscriptionRequest() {
    *this = ::std::move(from);
  }

  inline UpdateSuscriptionRequest& operator=(const UpdateSuscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSuscriptionRequest& operator=(UpdateSuscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSuscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSuscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateSuscriptionRequest*>(
               &_UpdateSuscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UpdateSuscriptionRequest& a, UpdateSuscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSuscriptionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSuscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateSuscriptionRequest* New() const final {
    return new UpdateSuscriptionRequest();
  }

  UpdateSuscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateSuscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateSuscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateSuscriptionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSuscriptionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.UpdateSuscriptionRequest";
  }
  protected:
  explicit UpdateSuscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 1,
    kSuscriptionFieldNumber = 2,
  };
  // string customer_id = 1 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // .payment.v1alpha1.Suscription suscription = 2 [json_name = "suscription"];
  bool has_suscription() const;
  private:
  bool _internal_has_suscription() const;
  public:
  void clear_suscription();
  const ::payment::v1alpha1::Suscription& suscription() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Suscription* release_suscription();
  ::payment::v1alpha1::Suscription* mutable_suscription();
  void set_allocated_suscription(::payment::v1alpha1::Suscription* suscription);
  private:
  const ::payment::v1alpha1::Suscription& _internal_suscription() const;
  ::payment::v1alpha1::Suscription* _internal_mutable_suscription();
  public:
  void unsafe_arena_set_allocated_suscription(
      ::payment::v1alpha1::Suscription* suscription);
  ::payment::v1alpha1::Suscription* unsafe_arena_release_suscription();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.UpdateSuscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::payment::v1alpha1::Suscription* suscription_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UpdateSuscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.UpdateSuscriptionResponse) */ {
 public:
  inline UpdateSuscriptionResponse() : UpdateSuscriptionResponse(nullptr) {}
  ~UpdateSuscriptionResponse() override;
  explicit constexpr UpdateSuscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSuscriptionResponse(const UpdateSuscriptionResponse& from);
  UpdateSuscriptionResponse(UpdateSuscriptionResponse&& from) noexcept
    : UpdateSuscriptionResponse() {
    *this = ::std::move(from);
  }

  inline UpdateSuscriptionResponse& operator=(const UpdateSuscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSuscriptionResponse& operator=(UpdateSuscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSuscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSuscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateSuscriptionResponse*>(
               &_UpdateSuscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UpdateSuscriptionResponse& a, UpdateSuscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSuscriptionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSuscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateSuscriptionResponse* New() const final {
    return new UpdateSuscriptionResponse();
  }

  UpdateSuscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateSuscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateSuscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateSuscriptionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSuscriptionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.UpdateSuscriptionResponse";
  }
  protected:
  explicit UpdateSuscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kSuscriptionFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Suscription suscription = 1 [json_name = "suscription"];
  bool has_suscription() const;
  private:
  bool _internal_has_suscription() const;
  public:
  void clear_suscription();
  const ::payment::v1alpha1::Suscription& suscription() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Suscription* release_suscription();
  ::payment::v1alpha1::Suscription* mutable_suscription();
  void set_allocated_suscription(::payment::v1alpha1::Suscription* suscription);
  private:
  const ::payment::v1alpha1::Suscription& _internal_suscription() const;
  ::payment::v1alpha1::Suscription* _internal_mutable_suscription();
  public:
  void unsafe_arena_set_allocated_suscription(
      ::payment::v1alpha1::Suscription* suscription);
  ::payment::v1alpha1::Suscription* unsafe_arena_release_suscription();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.UpdateSuscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Suscription* suscription_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateSuscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateSuscriptionRequest) */ {
 public:
  inline CreateSuscriptionRequest() : CreateSuscriptionRequest(nullptr) {}
  ~CreateSuscriptionRequest() override;
  explicit constexpr CreateSuscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSuscriptionRequest(const CreateSuscriptionRequest& from);
  CreateSuscriptionRequest(CreateSuscriptionRequest&& from) noexcept
    : CreateSuscriptionRequest() {
    *this = ::std::move(from);
  }

  inline CreateSuscriptionRequest& operator=(const CreateSuscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSuscriptionRequest& operator=(CreateSuscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSuscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSuscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSuscriptionRequest*>(
               &_CreateSuscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CreateSuscriptionRequest& a, CreateSuscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSuscriptionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSuscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateSuscriptionRequest* New() const final {
    return new CreateSuscriptionRequest();
  }

  CreateSuscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateSuscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSuscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateSuscriptionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSuscriptionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateSuscriptionRequest";
  }
  protected:
  explicit CreateSuscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 1,
    kSuscriptionFieldNumber = 2,
  };
  // string customer_id = 1 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // .payment.v1alpha1.Suscription suscription = 2 [json_name = "suscription"];
  bool has_suscription() const;
  private:
  bool _internal_has_suscription() const;
  public:
  void clear_suscription();
  const ::payment::v1alpha1::Suscription& suscription() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Suscription* release_suscription();
  ::payment::v1alpha1::Suscription* mutable_suscription();
  void set_allocated_suscription(::payment::v1alpha1::Suscription* suscription);
  private:
  const ::payment::v1alpha1::Suscription& _internal_suscription() const;
  ::payment::v1alpha1::Suscription* _internal_mutable_suscription();
  public:
  void unsafe_arena_set_allocated_suscription(
      ::payment::v1alpha1::Suscription* suscription);
  ::payment::v1alpha1::Suscription* unsafe_arena_release_suscription();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateSuscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::payment::v1alpha1::Suscription* suscription_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateSuscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateSuscriptionResponse) */ {
 public:
  inline CreateSuscriptionResponse() : CreateSuscriptionResponse(nullptr) {}
  ~CreateSuscriptionResponse() override;
  explicit constexpr CreateSuscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSuscriptionResponse(const CreateSuscriptionResponse& from);
  CreateSuscriptionResponse(CreateSuscriptionResponse&& from) noexcept
    : CreateSuscriptionResponse() {
    *this = ::std::move(from);
  }

  inline CreateSuscriptionResponse& operator=(const CreateSuscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSuscriptionResponse& operator=(CreateSuscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSuscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSuscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const CreateSuscriptionResponse*>(
               &_CreateSuscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CreateSuscriptionResponse& a, CreateSuscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSuscriptionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSuscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateSuscriptionResponse* New() const final {
    return new CreateSuscriptionResponse();
  }

  CreateSuscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateSuscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSuscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateSuscriptionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSuscriptionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateSuscriptionResponse";
  }
  protected:
  explicit CreateSuscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kCustomerFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateSuscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateInvoiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateInvoiceRequest) */ {
 public:
  inline CreateInvoiceRequest() : CreateInvoiceRequest(nullptr) {}
  ~CreateInvoiceRequest() override;
  explicit constexpr CreateInvoiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateInvoiceRequest(const CreateInvoiceRequest& from);
  CreateInvoiceRequest(CreateInvoiceRequest&& from) noexcept
    : CreateInvoiceRequest() {
    *this = ::std::move(from);
  }

  inline CreateInvoiceRequest& operator=(const CreateInvoiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInvoiceRequest& operator=(CreateInvoiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInvoiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateInvoiceRequest* internal_default_instance() {
    return reinterpret_cast<const CreateInvoiceRequest*>(
               &_CreateInvoiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CreateInvoiceRequest& a, CreateInvoiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInvoiceRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInvoiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateInvoiceRequest* New() const final {
    return new CreateInvoiceRequest();
  }

  CreateInvoiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateInvoiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateInvoiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateInvoiceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateInvoiceRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateInvoiceRequest";
  }
  protected:
  explicit CreateInvoiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvoiceIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string invoice_id = 1 [json_name = "invoiceId"];
  void clear_invoice_id();
  const std::string& invoice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invoice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invoice_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_invoice_id();
  void set_allocated_invoice_id(std::string* invoice_id);
  private:
  const std::string& _internal_invoice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invoice_id(const std::string& value);
  std::string* _internal_mutable_invoice_id();
  public:

  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateInvoiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invoice_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateInvoiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateInvoiceResponse) */ {
 public:
  inline CreateInvoiceResponse() : CreateInvoiceResponse(nullptr) {}
  ~CreateInvoiceResponse() override;
  explicit constexpr CreateInvoiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateInvoiceResponse(const CreateInvoiceResponse& from);
  CreateInvoiceResponse(CreateInvoiceResponse&& from) noexcept
    : CreateInvoiceResponse() {
    *this = ::std::move(from);
  }

  inline CreateInvoiceResponse& operator=(const CreateInvoiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInvoiceResponse& operator=(CreateInvoiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInvoiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateInvoiceResponse* internal_default_instance() {
    return reinterpret_cast<const CreateInvoiceResponse*>(
               &_CreateInvoiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CreateInvoiceResponse& a, CreateInvoiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInvoiceResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInvoiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateInvoiceResponse* New() const final {
    return new CreateInvoiceResponse();
  }

  CreateInvoiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateInvoiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateInvoiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateInvoiceResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateInvoiceResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateInvoiceResponse";
  }
  protected:
  explicit CreateInvoiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 4,
    kCustomerFieldNumber = 1,
  };
  // string status = 4 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateInvoiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateCardRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateCardRequest) */ {
 public:
  inline CreateCardRequest() : CreateCardRequest(nullptr) {}
  ~CreateCardRequest() override;
  explicit constexpr CreateCardRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCardRequest(const CreateCardRequest& from);
  CreateCardRequest(CreateCardRequest&& from) noexcept
    : CreateCardRequest() {
    *this = ::std::move(from);
  }

  inline CreateCardRequest& operator=(const CreateCardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCardRequest& operator=(CreateCardRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCardRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCardRequest* internal_default_instance() {
    return reinterpret_cast<const CreateCardRequest*>(
               &_CreateCardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CreateCardRequest& a, CreateCardRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCardRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCardRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateCardRequest* New() const final {
    return new CreateCardRequest();
  }

  CreateCardRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateCardRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCardRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCardRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCardRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateCardRequest";
  }
  protected:
  explicit CreateCardRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardFieldNumber = 1,
  };
  // .payment.v1alpha1.Card card = 1 [json_name = "card"];
  bool has_card() const;
  private:
  bool _internal_has_card() const;
  public:
  void clear_card();
  const ::payment::v1alpha1::Card& card() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Card* release_card();
  ::payment::v1alpha1::Card* mutable_card();
  void set_allocated_card(::payment::v1alpha1::Card* card);
  private:
  const ::payment::v1alpha1::Card& _internal_card() const;
  ::payment::v1alpha1::Card* _internal_mutable_card();
  public:
  void unsafe_arena_set_allocated_card(
      ::payment::v1alpha1::Card* card);
  ::payment::v1alpha1::Card* unsafe_arena_release_card();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateCardRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::payment::v1alpha1::Card* card_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateCardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateCardResponse) */ {
 public:
  inline CreateCardResponse() : CreateCardResponse(nullptr) {}
  ~CreateCardResponse() override;
  explicit constexpr CreateCardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCardResponse(const CreateCardResponse& from);
  CreateCardResponse(CreateCardResponse&& from) noexcept
    : CreateCardResponse() {
    *this = ::std::move(from);
  }

  inline CreateCardResponse& operator=(const CreateCardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCardResponse& operator=(CreateCardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCardResponse* internal_default_instance() {
    return reinterpret_cast<const CreateCardResponse*>(
               &_CreateCardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CreateCardResponse& a, CreateCardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCardResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateCardResponse* New() const final {
    return new CreateCardResponse();
  }

  CreateCardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateCardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCardResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCardResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCardResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateCardResponse";
  }
  protected:
  explicit CreateCardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string token_id = 1 [json_name = "tokenId"];
  void clear_token_id();
  const std::string& token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_token_id();
  void set_allocated_token_id(std::string* token_id);
  private:
  const std::string& _internal_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_id(const std::string& value);
  std::string* _internal_mutable_token_id();
  public:

  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateCardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CancelSuscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CancelSuscriptionRequest) */ {
 public:
  inline CancelSuscriptionRequest() : CancelSuscriptionRequest(nullptr) {}
  ~CancelSuscriptionRequest() override;
  explicit constexpr CancelSuscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelSuscriptionRequest(const CancelSuscriptionRequest& from);
  CancelSuscriptionRequest(CancelSuscriptionRequest&& from) noexcept
    : CancelSuscriptionRequest() {
    *this = ::std::move(from);
  }

  inline CancelSuscriptionRequest& operator=(const CancelSuscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelSuscriptionRequest& operator=(CancelSuscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelSuscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelSuscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const CancelSuscriptionRequest*>(
               &_CancelSuscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CancelSuscriptionRequest& a, CancelSuscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelSuscriptionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelSuscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelSuscriptionRequest* New() const final {
    return new CancelSuscriptionRequest();
  }

  CancelSuscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelSuscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelSuscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CancelSuscriptionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelSuscriptionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CancelSuscriptionRequest";
  }
  protected:
  explicit CancelSuscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuscriptionIdFieldNumber = 1,
  };
  // string suscription_id = 1 [json_name = "suscriptionId"];
  void clear_suscription_id();
  const std::string& suscription_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_suscription_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_suscription_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_suscription_id();
  void set_allocated_suscription_id(std::string* suscription_id);
  private:
  const std::string& _internal_suscription_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suscription_id(const std::string& value);
  std::string* _internal_mutable_suscription_id();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CancelSuscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr suscription_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CancelSuscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CancelSuscriptionResponse) */ {
 public:
  inline CancelSuscriptionResponse() : CancelSuscriptionResponse(nullptr) {}
  ~CancelSuscriptionResponse() override;
  explicit constexpr CancelSuscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelSuscriptionResponse(const CancelSuscriptionResponse& from);
  CancelSuscriptionResponse(CancelSuscriptionResponse&& from) noexcept
    : CancelSuscriptionResponse() {
    *this = ::std::move(from);
  }

  inline CancelSuscriptionResponse& operator=(const CancelSuscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelSuscriptionResponse& operator=(CancelSuscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelSuscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelSuscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const CancelSuscriptionResponse*>(
               &_CancelSuscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CancelSuscriptionResponse& a, CancelSuscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelSuscriptionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelSuscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelSuscriptionResponse* New() const final {
    return new CancelSuscriptionResponse();
  }

  CancelSuscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelSuscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelSuscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CancelSuscriptionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelSuscriptionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CancelSuscriptionResponse";
  }
  protected:
  explicit CancelSuscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CancelSuscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateCustomerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateCustomerRequest) */ {
 public:
  inline CreateCustomerRequest() : CreateCustomerRequest(nullptr) {}
  ~CreateCustomerRequest() override;
  explicit constexpr CreateCustomerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCustomerRequest(const CreateCustomerRequest& from);
  CreateCustomerRequest(CreateCustomerRequest&& from) noexcept
    : CreateCustomerRequest() {
    *this = ::std::move(from);
  }

  inline CreateCustomerRequest& operator=(const CreateCustomerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCustomerRequest& operator=(CreateCustomerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCustomerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCustomerRequest* internal_default_instance() {
    return reinterpret_cast<const CreateCustomerRequest*>(
               &_CreateCustomerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CreateCustomerRequest& a, CreateCustomerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCustomerRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCustomerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateCustomerRequest* New() const final {
    return new CreateCustomerRequest();
  }

  CreateCustomerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateCustomerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCustomerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCustomerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCustomerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateCustomerRequest";
  }
  protected:
  explicit CreateCustomerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerFieldNumber = 1,
  };
  // .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::payment::v1alpha1::Customer& customer() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Customer* release_customer();
  ::payment::v1alpha1::Customer* mutable_customer();
  void set_allocated_customer(::payment::v1alpha1::Customer* customer);
  private:
  const ::payment::v1alpha1::Customer& _internal_customer() const;
  ::payment::v1alpha1::Customer* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::payment::v1alpha1::Customer* customer);
  ::payment::v1alpha1::Customer* unsafe_arena_release_customer();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateCustomerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::payment::v1alpha1::Customer* customer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateCustomerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreateCustomerResponse) */ {
 public:
  inline CreateCustomerResponse() : CreateCustomerResponse(nullptr) {}
  ~CreateCustomerResponse() override;
  explicit constexpr CreateCustomerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCustomerResponse(const CreateCustomerResponse& from);
  CreateCustomerResponse(CreateCustomerResponse&& from) noexcept
    : CreateCustomerResponse() {
    *this = ::std::move(from);
  }

  inline CreateCustomerResponse& operator=(const CreateCustomerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCustomerResponse& operator=(CreateCustomerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCustomerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCustomerResponse* internal_default_instance() {
    return reinterpret_cast<const CreateCustomerResponse*>(
               &_CreateCustomerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CreateCustomerResponse& a, CreateCustomerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCustomerResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCustomerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateCustomerResponse* New() const final {
    return new CreateCustomerResponse();
  }

  CreateCustomerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateCustomerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCustomerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCustomerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCustomerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreateCustomerResponse";
  }
  protected:
  explicit CreateCustomerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string customer_id = 1 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreateCustomerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreatePaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreatePaymentRequest) */ {
 public:
  inline CreatePaymentRequest() : CreatePaymentRequest(nullptr) {}
  ~CreatePaymentRequest() override;
  explicit constexpr CreatePaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatePaymentRequest(const CreatePaymentRequest& from);
  CreatePaymentRequest(CreatePaymentRequest&& from) noexcept
    : CreatePaymentRequest() {
    *this = ::std::move(from);
  }

  inline CreatePaymentRequest& operator=(const CreatePaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePaymentRequest& operator=(CreatePaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePaymentRequest* internal_default_instance() {
    return reinterpret_cast<const CreatePaymentRequest*>(
               &_CreatePaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CreatePaymentRequest& a, CreatePaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatePaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreatePaymentRequest* New() const final {
    return new CreatePaymentRequest();
  }

  CreatePaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreatePaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatePaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreatePaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreatePaymentRequest";
  }
  protected:
  explicit CreatePaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 1,
    kPaymentFieldNumber = 2,
  };
  // string customer_id = 1 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // .payment.v1alpha1.Payment payment = 2 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::Payment& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Payment* release_payment();
  ::payment::v1alpha1::Payment* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::Payment* payment);
  private:
  const ::payment::v1alpha1::Payment& _internal_payment() const;
  ::payment::v1alpha1::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::Payment* payment);
  ::payment::v1alpha1::Payment* unsafe_arena_release_payment();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreatePaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::payment::v1alpha1::Payment* payment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreatePaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.CreatePaymentResponse) */ {
 public:
  inline CreatePaymentResponse() : CreatePaymentResponse(nullptr) {}
  ~CreatePaymentResponse() override;
  explicit constexpr CreatePaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatePaymentResponse(const CreatePaymentResponse& from);
  CreatePaymentResponse(CreatePaymentResponse&& from) noexcept
    : CreatePaymentResponse() {
    *this = ::std::move(from);
  }

  inline CreatePaymentResponse& operator=(const CreatePaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePaymentResponse& operator=(CreatePaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePaymentResponse* internal_default_instance() {
    return reinterpret_cast<const CreatePaymentResponse*>(
               &_CreatePaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CreatePaymentResponse& a, CreatePaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatePaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreatePaymentResponse* New() const final {
    return new CreatePaymentResponse();
  }

  CreatePaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreatePaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatePaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreatePaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.CreatePaymentResponse";
  }
  protected:
  explicit CreatePaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string card_id = 1 [json_name = "cardId"];
  void clear_card_id();
  const std::string& card_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_id();
  void set_allocated_card_id(std::string* card_id);
  private:
  const std::string& _internal_card_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_id(const std::string& value);
  std::string* _internal_mutable_card_id();
  public:

  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.CreatePaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UpdatePaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.UpdatePaymentRequest) */ {
 public:
  inline UpdatePaymentRequest() : UpdatePaymentRequest(nullptr) {}
  ~UpdatePaymentRequest() override;
  explicit constexpr UpdatePaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdatePaymentRequest(const UpdatePaymentRequest& from);
  UpdatePaymentRequest(UpdatePaymentRequest&& from) noexcept
    : UpdatePaymentRequest() {
    *this = ::std::move(from);
  }

  inline UpdatePaymentRequest& operator=(const UpdatePaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePaymentRequest& operator=(UpdatePaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePaymentRequest* internal_default_instance() {
    return reinterpret_cast<const UpdatePaymentRequest*>(
               &_UpdatePaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(UpdatePaymentRequest& a, UpdatePaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdatePaymentRequest* New() const final {
    return new UpdatePaymentRequest();
  }

  UpdatePaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdatePaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdatePaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.UpdatePaymentRequest";
  }
  protected:
  explicit UpdatePaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 1,
    kPaymentFieldNumber = 2,
  };
  // string customer_id = 1 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // .payment.v1alpha1.Payment payment = 2 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::Payment& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Payment* release_payment();
  ::payment::v1alpha1::Payment* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::Payment* payment);
  private:
  const ::payment::v1alpha1::Payment& _internal_payment() const;
  ::payment::v1alpha1::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::Payment* payment);
  ::payment::v1alpha1::Payment* unsafe_arena_release_payment();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.UpdatePaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::payment::v1alpha1::Payment* payment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UpdatePaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.UpdatePaymentResponse) */ {
 public:
  inline UpdatePaymentResponse() : UpdatePaymentResponse(nullptr) {}
  ~UpdatePaymentResponse() override;
  explicit constexpr UpdatePaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdatePaymentResponse(const UpdatePaymentResponse& from);
  UpdatePaymentResponse(UpdatePaymentResponse&& from) noexcept
    : UpdatePaymentResponse() {
    *this = ::std::move(from);
  }

  inline UpdatePaymentResponse& operator=(const UpdatePaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePaymentResponse& operator=(UpdatePaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePaymentResponse* internal_default_instance() {
    return reinterpret_cast<const UpdatePaymentResponse*>(
               &_UpdatePaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(UpdatePaymentResponse& a, UpdatePaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdatePaymentResponse* New() const final {
    return new UpdatePaymentResponse();
  }

  UpdatePaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdatePaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdatePaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.UpdatePaymentResponse";
  }
  protected:
  explicit UpdatePaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPaymentFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::Payment& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Payment* release_payment();
  ::payment::v1alpha1::Payment* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::Payment* payment);
  private:
  const ::payment::v1alpha1::Payment& _internal_payment() const;
  ::payment::v1alpha1::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::Payment* payment);
  ::payment::v1alpha1::Payment* unsafe_arena_release_payment();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.UpdatePaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Payment* payment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeletePaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeletePaymentRequest) */ {
 public:
  inline DeletePaymentRequest() : DeletePaymentRequest(nullptr) {}
  ~DeletePaymentRequest() override;
  explicit constexpr DeletePaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePaymentRequest(const DeletePaymentRequest& from);
  DeletePaymentRequest(DeletePaymentRequest&& from) noexcept
    : DeletePaymentRequest() {
    *this = ::std::move(from);
  }

  inline DeletePaymentRequest& operator=(const DeletePaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePaymentRequest& operator=(DeletePaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePaymentRequest* internal_default_instance() {
    return reinterpret_cast<const DeletePaymentRequest*>(
               &_DeletePaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(DeletePaymentRequest& a, DeletePaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeletePaymentRequest* New() const final {
    return new DeletePaymentRequest();
  }

  DeletePaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeletePaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeletePaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeletePaymentRequest";
  }
  protected:
  explicit DeletePaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardIdFieldNumber = 1,
    kCustomerIdFieldNumber = 2,
  };
  // string card_id = 1 [json_name = "cardId"];
  void clear_card_id();
  const std::string& card_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_id();
  void set_allocated_card_id(std::string* card_id);
  private:
  const std::string& _internal_card_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_id(const std::string& value);
  std::string* _internal_mutable_card_id();
  public:

  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeletePaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeletePaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.DeletePaymentResponse) */ {
 public:
  inline DeletePaymentResponse() : DeletePaymentResponse(nullptr) {}
  ~DeletePaymentResponse() override;
  explicit constexpr DeletePaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePaymentResponse(const DeletePaymentResponse& from);
  DeletePaymentResponse(DeletePaymentResponse&& from) noexcept
    : DeletePaymentResponse() {
    *this = ::std::move(from);
  }

  inline DeletePaymentResponse& operator=(const DeletePaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePaymentResponse& operator=(DeletePaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePaymentResponse* internal_default_instance() {
    return reinterpret_cast<const DeletePaymentResponse*>(
               &_DeletePaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(DeletePaymentResponse& a, DeletePaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeletePaymentResponse* New() const final {
    return new DeletePaymentResponse();
  }

  DeletePaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeletePaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeletePaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.DeletePaymentResponse";
  }
  protected:
  explicit DeletePaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.DeletePaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetPaymentRequest) */ {
 public:
  inline GetPaymentRequest() : GetPaymentRequest(nullptr) {}
  ~GetPaymentRequest() override;
  explicit constexpr GetPaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaymentRequest(const GetPaymentRequest& from);
  GetPaymentRequest(GetPaymentRequest&& from) noexcept
    : GetPaymentRequest() {
    *this = ::std::move(from);
  }

  inline GetPaymentRequest& operator=(const GetPaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaymentRequest& operator=(GetPaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaymentRequest* internal_default_instance() {
    return reinterpret_cast<const GetPaymentRequest*>(
               &_GetPaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GetPaymentRequest& a, GetPaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPaymentRequest* New() const final {
    return new GetPaymentRequest();
  }

  GetPaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetPaymentRequest";
  }
  protected:
  explicit GetPaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardIdFieldNumber = 1,
    kCustomerIdFieldNumber = 2,
  };
  // string card_id = 1 [json_name = "cardId"];
  void clear_card_id();
  const std::string& card_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_card_id();
  void set_allocated_card_id(std::string* card_id);
  private:
  const std::string& _internal_card_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_id(const std::string& value);
  std::string* _internal_mutable_card_id();
  public:

  // string customer_id = 2 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetPaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.GetPaymentResponse) */ {
 public:
  inline GetPaymentResponse() : GetPaymentResponse(nullptr) {}
  ~GetPaymentResponse() override;
  explicit constexpr GetPaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaymentResponse(const GetPaymentResponse& from);
  GetPaymentResponse(GetPaymentResponse&& from) noexcept
    : GetPaymentResponse() {
    *this = ::std::move(from);
  }

  inline GetPaymentResponse& operator=(const GetPaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaymentResponse& operator=(GetPaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaymentResponse* internal_default_instance() {
    return reinterpret_cast<const GetPaymentResponse*>(
               &_GetPaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetPaymentResponse& a, GetPaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPaymentResponse* New() const final {
    return new GetPaymentResponse();
  }

  GetPaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.GetPaymentResponse";
  }
  protected:
  explicit GetPaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPaymentFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::Payment& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Payment* release_payment();
  ::payment::v1alpha1::Payment* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::Payment* payment);
  private:
  const ::payment::v1alpha1::Payment& _internal_payment() const;
  ::payment::v1alpha1::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::Payment* payment);
  ::payment::v1alpha1::Payment* unsafe_arena_release_payment();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.GetPaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Payment* payment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListPaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ListPaymentRequest) */ {
 public:
  inline ListPaymentRequest() : ListPaymentRequest(nullptr) {}
  ~ListPaymentRequest() override;
  explicit constexpr ListPaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPaymentRequest(const ListPaymentRequest& from);
  ListPaymentRequest(ListPaymentRequest&& from) noexcept
    : ListPaymentRequest() {
    *this = ::std::move(from);
  }

  inline ListPaymentRequest& operator=(const ListPaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPaymentRequest& operator=(ListPaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPaymentRequest* internal_default_instance() {
    return reinterpret_cast<const ListPaymentRequest*>(
               &_ListPaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ListPaymentRequest& a, ListPaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPaymentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPaymentRequest* New() const final {
    return new ListPaymentRequest();
  }

  ListPaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPaymentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ListPaymentRequest";
  }
  protected:
  explicit ListPaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 1,
  };
  // string customer_id = 1 [json_name = "customerId"];
  void clear_customer_id();
  const std::string& customer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ListPaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListPaymentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payment.v1alpha1.ListPaymentResponse) */ {
 public:
  inline ListPaymentResponse() : ListPaymentResponse(nullptr) {}
  ~ListPaymentResponse() override;
  explicit constexpr ListPaymentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPaymentResponse(const ListPaymentResponse& from);
  ListPaymentResponse(ListPaymentResponse&& from) noexcept
    : ListPaymentResponse() {
    *this = ::std::move(from);
  }

  inline ListPaymentResponse& operator=(const ListPaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPaymentResponse& operator=(ListPaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPaymentResponse* internal_default_instance() {
    return reinterpret_cast<const ListPaymentResponse*>(
               &_ListPaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ListPaymentResponse& a, ListPaymentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPaymentResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPaymentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPaymentResponse* New() const final {
    return new ListPaymentResponse();
  }

  ListPaymentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPaymentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPaymentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPaymentResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPaymentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payment.v1alpha1.ListPaymentResponse";
  }
  protected:
  explicit ListPaymentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPaymentFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payment::v1alpha1::Payment& payment() const;
  PROTOBUF_MUST_USE_RESULT ::payment::v1alpha1::Payment* release_payment();
  ::payment::v1alpha1::Payment* mutable_payment();
  void set_allocated_payment(::payment::v1alpha1::Payment* payment);
  private:
  const ::payment::v1alpha1::Payment& _internal_payment() const;
  ::payment::v1alpha1::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payment::v1alpha1::Payment* payment);
  ::payment::v1alpha1::Payment* unsafe_arena_release_payment();

  // @@protoc_insertion_point(class_scope:payment.v1alpha1.ListPaymentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::payment::v1alpha1::Payment* payment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_2fv1alpha1_2fpayment_5fapi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InvoiceFilterRequest

// string year = 1 [json_name = "year"];
inline void InvoiceFilterRequest::clear_year() {
  year_.ClearToEmpty();
}
inline const std::string& InvoiceFilterRequest::year() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.year)
  return _internal_year();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceFilterRequest::set_year(ArgT0&& arg0, ArgT... args) {
 
 year_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.year)
}
inline std::string* InvoiceFilterRequest::mutable_year() {
  std::string* _s = _internal_mutable_year();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterRequest.year)
  return _s;
}
inline const std::string& InvoiceFilterRequest::_internal_year() const {
  return year_.Get();
}
inline void InvoiceFilterRequest::_internal_set_year(const std::string& value) {
  
  year_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::_internal_mutable_year() {
  
  return year_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::release_year() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterRequest.year)
  return year_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvoiceFilterRequest::set_allocated_year(std::string* year) {
  if (year != nullptr) {
    
  } else {
    
  }
  year_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), year,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterRequest.year)
}

// string month = 2 [json_name = "month"];
inline void InvoiceFilterRequest::clear_month() {
  month_.ClearToEmpty();
}
inline const std::string& InvoiceFilterRequest::month() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.month)
  return _internal_month();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceFilterRequest::set_month(ArgT0&& arg0, ArgT... args) {
 
 month_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.month)
}
inline std::string* InvoiceFilterRequest::mutable_month() {
  std::string* _s = _internal_mutable_month();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterRequest.month)
  return _s;
}
inline const std::string& InvoiceFilterRequest::_internal_month() const {
  return month_.Get();
}
inline void InvoiceFilterRequest::_internal_set_month(const std::string& value) {
  
  month_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::_internal_mutable_month() {
  
  return month_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvoiceFilterRequest::release_month() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterRequest.month)
  return month_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvoiceFilterRequest::set_allocated_month(std::string* month) {
  if (month != nullptr) {
    
  } else {
    
  }
  month_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), month,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterRequest.month)
}

// .payment.v1alpha1.CustomerList customer_list = 3 [json_name = "customerList"];
inline bool InvoiceFilterRequest::_internal_has_customer_list() const {
  return this != internal_default_instance() && customer_list_ != nullptr;
}
inline bool InvoiceFilterRequest::has_customer_list() const {
  return _internal_has_customer_list();
}
inline const ::payment::v1alpha1::CustomerList& InvoiceFilterRequest::_internal_customer_list() const {
  const ::payment::v1alpha1::CustomerList* p = customer_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::CustomerList&>(
      ::payment::v1alpha1::_CustomerList_default_instance_);
}
inline const ::payment::v1alpha1::CustomerList& InvoiceFilterRequest::customer_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.customer_list)
  return _internal_customer_list();
}
inline void InvoiceFilterRequest::unsafe_arena_set_allocated_customer_list(
    ::payment::v1alpha1::CustomerList* customer_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_list_);
  }
  customer_list_ = customer_list;
  if (customer_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.InvoiceFilterRequest.customer_list)
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterRequest::release_customer_list() {
  
  ::payment::v1alpha1::CustomerList* temp = customer_list_;
  customer_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterRequest::unsafe_arena_release_customer_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterRequest.customer_list)
  
  ::payment::v1alpha1::CustomerList* temp = customer_list_;
  customer_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterRequest::_internal_mutable_customer_list() {
  
  if (customer_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::CustomerList>(GetArenaForAllocation());
    customer_list_ = p;
  }
  return customer_list_;
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterRequest::mutable_customer_list() {
  ::payment::v1alpha1::CustomerList* _msg = _internal_mutable_customer_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterRequest.customer_list)
  return _msg;
}
inline void InvoiceFilterRequest::set_allocated_customer_list(::payment::v1alpha1::CustomerList* customer_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_list_);
  }
  if (customer_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_list));
    if (message_arena != submessage_arena) {
      customer_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer_list, submessage_arena);
    }
    
  } else {
    
  }
  customer_list_ = customer_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterRequest.customer_list)
}

// uint32 organization_id = 4 [json_name = "organizationId"];
inline void InvoiceFilterRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InvoiceFilterRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InvoiceFilterRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterRequest.organization_id)
  return _internal_organization_id();
}
inline void InvoiceFilterRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void InvoiceFilterRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterRequest.organization_id)
}

// -------------------------------------------------------------------

// InvoiceFilterResponse

// .payment.v1alpha1.CustomerList customer_list = 1 [json_name = "customerList"];
inline bool InvoiceFilterResponse::_internal_has_customer_list() const {
  return this != internal_default_instance() && customer_list_ != nullptr;
}
inline bool InvoiceFilterResponse::has_customer_list() const {
  return _internal_has_customer_list();
}
inline const ::payment::v1alpha1::CustomerList& InvoiceFilterResponse::_internal_customer_list() const {
  const ::payment::v1alpha1::CustomerList* p = customer_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::CustomerList&>(
      ::payment::v1alpha1::_CustomerList_default_instance_);
}
inline const ::payment::v1alpha1::CustomerList& InvoiceFilterResponse::customer_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterResponse.customer_list)
  return _internal_customer_list();
}
inline void InvoiceFilterResponse::unsafe_arena_set_allocated_customer_list(
    ::payment::v1alpha1::CustomerList* customer_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_list_);
  }
  customer_list_ = customer_list;
  if (customer_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.InvoiceFilterResponse.customer_list)
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterResponse::release_customer_list() {
  
  ::payment::v1alpha1::CustomerList* temp = customer_list_;
  customer_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterResponse::unsafe_arena_release_customer_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterResponse.customer_list)
  
  ::payment::v1alpha1::CustomerList* temp = customer_list_;
  customer_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterResponse::_internal_mutable_customer_list() {
  
  if (customer_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::CustomerList>(GetArenaForAllocation());
    customer_list_ = p;
  }
  return customer_list_;
}
inline ::payment::v1alpha1::CustomerList* InvoiceFilterResponse::mutable_customer_list() {
  ::payment::v1alpha1::CustomerList* _msg = _internal_mutable_customer_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterResponse.customer_list)
  return _msg;
}
inline void InvoiceFilterResponse::set_allocated_customer_list(::payment::v1alpha1::CustomerList* customer_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_list_);
  }
  if (customer_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_list));
    if (message_arena != submessage_arena) {
      customer_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer_list, submessage_arena);
    }
    
  } else {
    
  }
  customer_list_ = customer_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterResponse.customer_list)
}

// .payment.v1alpha1.InvoiceList invoice_list = 2 [json_name = "invoiceList"];
inline bool InvoiceFilterResponse::_internal_has_invoice_list() const {
  return this != internal_default_instance() && invoice_list_ != nullptr;
}
inline bool InvoiceFilterResponse::has_invoice_list() const {
  return _internal_has_invoice_list();
}
inline const ::payment::v1alpha1::InvoiceList& InvoiceFilterResponse::_internal_invoice_list() const {
  const ::payment::v1alpha1::InvoiceList* p = invoice_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::InvoiceList&>(
      ::payment::v1alpha1::_InvoiceList_default_instance_);
}
inline const ::payment::v1alpha1::InvoiceList& InvoiceFilterResponse::invoice_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterResponse.invoice_list)
  return _internal_invoice_list();
}
inline void InvoiceFilterResponse::unsafe_arena_set_allocated_invoice_list(
    ::payment::v1alpha1::InvoiceList* invoice_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invoice_list_);
  }
  invoice_list_ = invoice_list;
  if (invoice_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.InvoiceFilterResponse.invoice_list)
}
inline ::payment::v1alpha1::InvoiceList* InvoiceFilterResponse::release_invoice_list() {
  
  ::payment::v1alpha1::InvoiceList* temp = invoice_list_;
  invoice_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::InvoiceList* InvoiceFilterResponse::unsafe_arena_release_invoice_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterResponse.invoice_list)
  
  ::payment::v1alpha1::InvoiceList* temp = invoice_list_;
  invoice_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::InvoiceList* InvoiceFilterResponse::_internal_mutable_invoice_list() {
  
  if (invoice_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::InvoiceList>(GetArenaForAllocation());
    invoice_list_ = p;
  }
  return invoice_list_;
}
inline ::payment::v1alpha1::InvoiceList* InvoiceFilterResponse::mutable_invoice_list() {
  ::payment::v1alpha1::InvoiceList* _msg = _internal_mutable_invoice_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterResponse.invoice_list)
  return _msg;
}
inline void InvoiceFilterResponse::set_allocated_invoice_list(::payment::v1alpha1::InvoiceList* invoice_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(invoice_list_);
  }
  if (invoice_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invoice_list));
    if (message_arena != submessage_arena) {
      invoice_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invoice_list, submessage_arena);
    }
    
  } else {
    
  }
  invoice_list_ = invoice_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterResponse.invoice_list)
}

// .payment.v1alpha1.BilingList biling_list = 3 [json_name = "bilingList"];
inline bool InvoiceFilterResponse::_internal_has_biling_list() const {
  return this != internal_default_instance() && biling_list_ != nullptr;
}
inline bool InvoiceFilterResponse::has_biling_list() const {
  return _internal_has_biling_list();
}
inline const ::payment::v1alpha1::BilingList& InvoiceFilterResponse::_internal_biling_list() const {
  const ::payment::v1alpha1::BilingList* p = biling_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::BilingList&>(
      ::payment::v1alpha1::_BilingList_default_instance_);
}
inline const ::payment::v1alpha1::BilingList& InvoiceFilterResponse::biling_list() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterResponse.biling_list)
  return _internal_biling_list();
}
inline void InvoiceFilterResponse::unsafe_arena_set_allocated_biling_list(
    ::payment::v1alpha1::BilingList* biling_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling_list_);
  }
  biling_list_ = biling_list;
  if (biling_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.InvoiceFilterResponse.biling_list)
}
inline ::payment::v1alpha1::BilingList* InvoiceFilterResponse::release_biling_list() {
  
  ::payment::v1alpha1::BilingList* temp = biling_list_;
  biling_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::BilingList* InvoiceFilterResponse::unsafe_arena_release_biling_list() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterResponse.biling_list)
  
  ::payment::v1alpha1::BilingList* temp = biling_list_;
  biling_list_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::BilingList* InvoiceFilterResponse::_internal_mutable_biling_list() {
  
  if (biling_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::BilingList>(GetArenaForAllocation());
    biling_list_ = p;
  }
  return biling_list_;
}
inline ::payment::v1alpha1::BilingList* InvoiceFilterResponse::mutable_biling_list() {
  ::payment::v1alpha1::BilingList* _msg = _internal_mutable_biling_list();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterResponse.biling_list)
  return _msg;
}
inline void InvoiceFilterResponse::set_allocated_biling_list(::payment::v1alpha1::BilingList* biling_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling_list_);
  }
  if (biling_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(biling_list));
    if (message_arena != submessage_arena) {
      biling_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, biling_list, submessage_arena);
    }
    
  } else {
    
  }
  biling_list_ = biling_list;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterResponse.biling_list)
}

// string status = 4 [json_name = "status"];
inline void InvoiceFilterResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& InvoiceFilterResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.InvoiceFilterResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceFilterResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.InvoiceFilterResponse.status)
}
inline std::string* InvoiceFilterResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.InvoiceFilterResponse.status)
  return _s;
}
inline const std::string& InvoiceFilterResponse::_internal_status() const {
  return status_.Get();
}
inline void InvoiceFilterResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvoiceFilterResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvoiceFilterResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.InvoiceFilterResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvoiceFilterResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.InvoiceFilterResponse.status)
}

// -------------------------------------------------------------------

// DeleteCustomerRequest

// string customer_id = 1 [json_name = "customerId"];
inline void DeleteCustomerRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& DeleteCustomerRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteCustomerRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteCustomerRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeleteCustomerRequest.customer_id)
}
inline std::string* DeleteCustomerRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeleteCustomerRequest.customer_id)
  return _s;
}
inline const std::string& DeleteCustomerRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void DeleteCustomerRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteCustomerRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteCustomerRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeleteCustomerRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteCustomerRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeleteCustomerRequest.customer_id)
}

// -------------------------------------------------------------------

// DeleteCustomerResponse

// string status = 1 [json_name = "status"];
inline void DeleteCustomerResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& DeleteCustomerResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeleteCustomerResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteCustomerResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeleteCustomerResponse.status)
}
inline std::string* DeleteCustomerResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeleteCustomerResponse.status)
  return _s;
}
inline const std::string& DeleteCustomerResponse::_internal_status() const {
  return status_.Get();
}
inline void DeleteCustomerResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteCustomerResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteCustomerResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeleteCustomerResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteCustomerResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeleteCustomerResponse.status)
}

// -------------------------------------------------------------------

// GetSuscriptionRequest

// string suscription_id = 1 [json_name = "suscriptionId"];
inline void GetSuscriptionRequest::clear_suscription_id() {
  suscription_id_.ClearToEmpty();
}
inline const std::string& GetSuscriptionRequest::suscription_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetSuscriptionRequest.suscription_id)
  return _internal_suscription_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSuscriptionRequest::set_suscription_id(ArgT0&& arg0, ArgT... args) {
 
 suscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetSuscriptionRequest.suscription_id)
}
inline std::string* GetSuscriptionRequest::mutable_suscription_id() {
  std::string* _s = _internal_mutable_suscription_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetSuscriptionRequest.suscription_id)
  return _s;
}
inline const std::string& GetSuscriptionRequest::_internal_suscription_id() const {
  return suscription_id_.Get();
}
inline void GetSuscriptionRequest::_internal_set_suscription_id(const std::string& value) {
  
  suscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetSuscriptionRequest::_internal_mutable_suscription_id() {
  
  return suscription_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetSuscriptionRequest::release_suscription_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetSuscriptionRequest.suscription_id)
  return suscription_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetSuscriptionRequest::set_allocated_suscription_id(std::string* suscription_id) {
  if (suscription_id != nullptr) {
    
  } else {
    
  }
  suscription_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), suscription_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetSuscriptionRequest.suscription_id)
}

// -------------------------------------------------------------------

// GetSuscriptionResponse

// .payment.v1alpha1.Suscription suscription = 1 [json_name = "suscription"];
inline bool GetSuscriptionResponse::_internal_has_suscription() const {
  return this != internal_default_instance() && suscription_ != nullptr;
}
inline bool GetSuscriptionResponse::has_suscription() const {
  return _internal_has_suscription();
}
inline const ::payment::v1alpha1::Suscription& GetSuscriptionResponse::_internal_suscription() const {
  const ::payment::v1alpha1::Suscription* p = suscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Suscription&>(
      ::payment::v1alpha1::_Suscription_default_instance_);
}
inline const ::payment::v1alpha1::Suscription& GetSuscriptionResponse::suscription() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetSuscriptionResponse.suscription)
  return _internal_suscription();
}
inline void GetSuscriptionResponse::unsafe_arena_set_allocated_suscription(
    ::payment::v1alpha1::Suscription* suscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_);
  }
  suscription_ = suscription;
  if (suscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetSuscriptionResponse.suscription)
}
inline ::payment::v1alpha1::Suscription* GetSuscriptionResponse::release_suscription() {
  
  ::payment::v1alpha1::Suscription* temp = suscription_;
  suscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Suscription* GetSuscriptionResponse::unsafe_arena_release_suscription() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetSuscriptionResponse.suscription)
  
  ::payment::v1alpha1::Suscription* temp = suscription_;
  suscription_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Suscription* GetSuscriptionResponse::_internal_mutable_suscription() {
  
  if (suscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Suscription>(GetArenaForAllocation());
    suscription_ = p;
  }
  return suscription_;
}
inline ::payment::v1alpha1::Suscription* GetSuscriptionResponse::mutable_suscription() {
  ::payment::v1alpha1::Suscription* _msg = _internal_mutable_suscription();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetSuscriptionResponse.suscription)
  return _msg;
}
inline void GetSuscriptionResponse::set_allocated_suscription(::payment::v1alpha1::Suscription* suscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_);
  }
  if (suscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription));
    if (message_arena != submessage_arena) {
      suscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, suscription, submessage_arena);
    }
    
  } else {
    
  }
  suscription_ = suscription;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetSuscriptionResponse.suscription)
}

// string status = 2 [json_name = "status"];
inline void GetSuscriptionResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetSuscriptionResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetSuscriptionResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSuscriptionResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetSuscriptionResponse.status)
}
inline std::string* GetSuscriptionResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetSuscriptionResponse.status)
  return _s;
}
inline const std::string& GetSuscriptionResponse::_internal_status() const {
  return status_.Get();
}
inline void GetSuscriptionResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetSuscriptionResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetSuscriptionResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetSuscriptionResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetSuscriptionResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetSuscriptionResponse.status)
}

// -------------------------------------------------------------------

// GetOrganizationPaymentRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void GetOrganizationPaymentRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOrganizationPaymentRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOrganizationPaymentRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetOrganizationPaymentRequest.organization_id)
  return _internal_organization_id();
}
inline void GetOrganizationPaymentRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void GetOrganizationPaymentRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetOrganizationPaymentRequest.organization_id)
}

// -------------------------------------------------------------------

// GetOrganizationPaymentResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool GetOrganizationPaymentResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool GetOrganizationPaymentResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& GetOrganizationPaymentResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& GetOrganizationPaymentResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetOrganizationPaymentResponse.customer)
  return _internal_customer();
}
inline void GetOrganizationPaymentResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetOrganizationPaymentResponse.customer)
}
inline ::payment::v1alpha1::Customer* GetOrganizationPaymentResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* GetOrganizationPaymentResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetOrganizationPaymentResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* GetOrganizationPaymentResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* GetOrganizationPaymentResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetOrganizationPaymentResponse.customer)
  return _msg;
}
inline void GetOrganizationPaymentResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetOrganizationPaymentResponse.customer)
}

// string status = 3 [json_name = "status"];
inline void GetOrganizationPaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetOrganizationPaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetOrganizationPaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOrganizationPaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetOrganizationPaymentResponse.status)
}
inline std::string* GetOrganizationPaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetOrganizationPaymentResponse.status)
  return _s;
}
inline const std::string& GetOrganizationPaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void GetOrganizationPaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOrganizationPaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOrganizationPaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetOrganizationPaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOrganizationPaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetOrganizationPaymentResponse.status)
}

// -------------------------------------------------------------------

// GetCustomerRequest

// string customer_id = 1 [json_name = "customerId"];
inline void GetCustomerRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& GetCustomerRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetCustomerRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCustomerRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetCustomerRequest.customer_id)
}
inline std::string* GetCustomerRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetCustomerRequest.customer_id)
  return _s;
}
inline const std::string& GetCustomerRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void GetCustomerRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetCustomerRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetCustomerRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetCustomerRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetCustomerRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetCustomerRequest.customer_id)
}

// -------------------------------------------------------------------

// GetCustomerResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool GetCustomerResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool GetCustomerResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& GetCustomerResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& GetCustomerResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetCustomerResponse.customer)
  return _internal_customer();
}
inline void GetCustomerResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetCustomerResponse.customer)
}
inline ::payment::v1alpha1::Customer* GetCustomerResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* GetCustomerResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetCustomerResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* GetCustomerResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* GetCustomerResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetCustomerResponse.customer)
  return _msg;
}
inline void GetCustomerResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetCustomerResponse.customer)
}

// string status = 2 [json_name = "status"];
inline void GetCustomerResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetCustomerResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetCustomerResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCustomerResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetCustomerResponse.status)
}
inline std::string* GetCustomerResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetCustomerResponse.status)
  return _s;
}
inline const std::string& GetCustomerResponse::_internal_status() const {
  return status_.Get();
}
inline void GetCustomerResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetCustomerResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetCustomerResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetCustomerResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetCustomerResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetCustomerResponse.status)
}

// -------------------------------------------------------------------

// GetBilingMonthRequest

// string invoice_id = 1 [json_name = "invoiceId"];
inline void GetBilingMonthRequest::clear_invoice_id() {
  invoice_id_.ClearToEmpty();
}
inline const std::string& GetBilingMonthRequest::invoice_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetBilingMonthRequest.invoice_id)
  return _internal_invoice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBilingMonthRequest::set_invoice_id(ArgT0&& arg0, ArgT... args) {
 
 invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetBilingMonthRequest.invoice_id)
}
inline std::string* GetBilingMonthRequest::mutable_invoice_id() {
  std::string* _s = _internal_mutable_invoice_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetBilingMonthRequest.invoice_id)
  return _s;
}
inline const std::string& GetBilingMonthRequest::_internal_invoice_id() const {
  return invoice_id_.Get();
}
inline void GetBilingMonthRequest::_internal_set_invoice_id(const std::string& value) {
  
  invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBilingMonthRequest::_internal_mutable_invoice_id() {
  
  return invoice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBilingMonthRequest::release_invoice_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetBilingMonthRequest.invoice_id)
  return invoice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetBilingMonthRequest::set_allocated_invoice_id(std::string* invoice_id) {
  if (invoice_id != nullptr) {
    
  } else {
    
  }
  invoice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invoice_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetBilingMonthRequest.invoice_id)
}

// -------------------------------------------------------------------

// GetBilingMonthResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool GetBilingMonthResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool GetBilingMonthResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& GetBilingMonthResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& GetBilingMonthResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetBilingMonthResponse.customer)
  return _internal_customer();
}
inline void GetBilingMonthResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetBilingMonthResponse.customer)
}
inline ::payment::v1alpha1::Customer* GetBilingMonthResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* GetBilingMonthResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetBilingMonthResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* GetBilingMonthResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* GetBilingMonthResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetBilingMonthResponse.customer)
  return _msg;
}
inline void GetBilingMonthResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetBilingMonthResponse.customer)
}

// string status = 2 [json_name = "status"];
inline void GetBilingMonthResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetBilingMonthResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetBilingMonthResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBilingMonthResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetBilingMonthResponse.status)
}
inline std::string* GetBilingMonthResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetBilingMonthResponse.status)
  return _s;
}
inline const std::string& GetBilingMonthResponse::_internal_status() const {
  return status_.Get();
}
inline void GetBilingMonthResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBilingMonthResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBilingMonthResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetBilingMonthResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetBilingMonthResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetBilingMonthResponse.status)
}

// -------------------------------------------------------------------

// GetPaymentsRequest

// string customer_id = 1 [json_name = "customerId"];
inline void GetPaymentsRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& GetPaymentsRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentsRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentsRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentsRequest.customer_id)
}
inline std::string* GetPaymentsRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentsRequest.customer_id)
  return _s;
}
inline const std::string& GetPaymentsRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void GetPaymentsRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentsRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentsRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentsRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentsRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentsRequest.customer_id)
}

// -------------------------------------------------------------------

// GetPaymentsResponse

// .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
inline bool GetPaymentsResponse::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool GetPaymentsResponse::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::Payment& GetPaymentsResponse::_internal_payment() const {
  const ::payment::v1alpha1::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Payment&>(
      ::payment::v1alpha1::_Payment_default_instance_);
}
inline const ::payment::v1alpha1::Payment& GetPaymentsResponse::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentsResponse.payment)
  return _internal_payment();
}
inline void GetPaymentsResponse::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetPaymentsResponse.payment)
}
inline ::payment::v1alpha1::Payment* GetPaymentsResponse::release_payment() {
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Payment* GetPaymentsResponse::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentsResponse.payment)
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Payment* GetPaymentsResponse::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::Payment* GetPaymentsResponse::mutable_payment() {
  ::payment::v1alpha1::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentsResponse.payment)
  return _msg;
}
inline void GetPaymentsResponse::set_allocated_payment(::payment::v1alpha1::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentsResponse.payment)
}

// string status = 2 [json_name = "status"];
inline void GetPaymentsResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetPaymentsResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentsResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentsResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentsResponse.status)
}
inline std::string* GetPaymentsResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentsResponse.status)
  return _s;
}
inline const std::string& GetPaymentsResponse::_internal_status() const {
  return status_.Get();
}
inline void GetPaymentsResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentsResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentsResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentsResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentsResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentsResponse.status)
}

// -------------------------------------------------------------------

// UpdateSuscriptionRequest

// string customer_id = 1 [json_name = "customerId"];
inline void UpdateSuscriptionRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& UpdateSuscriptionRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdateSuscriptionRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSuscriptionRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.UpdateSuscriptionRequest.customer_id)
}
inline std::string* UpdateSuscriptionRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.UpdateSuscriptionRequest.customer_id)
  return _s;
}
inline const std::string& UpdateSuscriptionRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void UpdateSuscriptionRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateSuscriptionRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateSuscriptionRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.UpdateSuscriptionRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateSuscriptionRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.UpdateSuscriptionRequest.customer_id)
}

// .payment.v1alpha1.Suscription suscription = 2 [json_name = "suscription"];
inline bool UpdateSuscriptionRequest::_internal_has_suscription() const {
  return this != internal_default_instance() && suscription_ != nullptr;
}
inline bool UpdateSuscriptionRequest::has_suscription() const {
  return _internal_has_suscription();
}
inline const ::payment::v1alpha1::Suscription& UpdateSuscriptionRequest::_internal_suscription() const {
  const ::payment::v1alpha1::Suscription* p = suscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Suscription&>(
      ::payment::v1alpha1::_Suscription_default_instance_);
}
inline const ::payment::v1alpha1::Suscription& UpdateSuscriptionRequest::suscription() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdateSuscriptionRequest.suscription)
  return _internal_suscription();
}
inline void UpdateSuscriptionRequest::unsafe_arena_set_allocated_suscription(
    ::payment::v1alpha1::Suscription* suscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_);
  }
  suscription_ = suscription;
  if (suscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.UpdateSuscriptionRequest.suscription)
}
inline ::payment::v1alpha1::Suscription* UpdateSuscriptionRequest::release_suscription() {
  
  ::payment::v1alpha1::Suscription* temp = suscription_;
  suscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Suscription* UpdateSuscriptionRequest::unsafe_arena_release_suscription() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.UpdateSuscriptionRequest.suscription)
  
  ::payment::v1alpha1::Suscription* temp = suscription_;
  suscription_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Suscription* UpdateSuscriptionRequest::_internal_mutable_suscription() {
  
  if (suscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Suscription>(GetArenaForAllocation());
    suscription_ = p;
  }
  return suscription_;
}
inline ::payment::v1alpha1::Suscription* UpdateSuscriptionRequest::mutable_suscription() {
  ::payment::v1alpha1::Suscription* _msg = _internal_mutable_suscription();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.UpdateSuscriptionRequest.suscription)
  return _msg;
}
inline void UpdateSuscriptionRequest::set_allocated_suscription(::payment::v1alpha1::Suscription* suscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_);
  }
  if (suscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription));
    if (message_arena != submessage_arena) {
      suscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, suscription, submessage_arena);
    }
    
  } else {
    
  }
  suscription_ = suscription;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.UpdateSuscriptionRequest.suscription)
}

// -------------------------------------------------------------------

// UpdateSuscriptionResponse

// .payment.v1alpha1.Suscription suscription = 1 [json_name = "suscription"];
inline bool UpdateSuscriptionResponse::_internal_has_suscription() const {
  return this != internal_default_instance() && suscription_ != nullptr;
}
inline bool UpdateSuscriptionResponse::has_suscription() const {
  return _internal_has_suscription();
}
inline const ::payment::v1alpha1::Suscription& UpdateSuscriptionResponse::_internal_suscription() const {
  const ::payment::v1alpha1::Suscription* p = suscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Suscription&>(
      ::payment::v1alpha1::_Suscription_default_instance_);
}
inline const ::payment::v1alpha1::Suscription& UpdateSuscriptionResponse::suscription() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdateSuscriptionResponse.suscription)
  return _internal_suscription();
}
inline void UpdateSuscriptionResponse::unsafe_arena_set_allocated_suscription(
    ::payment::v1alpha1::Suscription* suscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_);
  }
  suscription_ = suscription;
  if (suscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.UpdateSuscriptionResponse.suscription)
}
inline ::payment::v1alpha1::Suscription* UpdateSuscriptionResponse::release_suscription() {
  
  ::payment::v1alpha1::Suscription* temp = suscription_;
  suscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Suscription* UpdateSuscriptionResponse::unsafe_arena_release_suscription() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.UpdateSuscriptionResponse.suscription)
  
  ::payment::v1alpha1::Suscription* temp = suscription_;
  suscription_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Suscription* UpdateSuscriptionResponse::_internal_mutable_suscription() {
  
  if (suscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Suscription>(GetArenaForAllocation());
    suscription_ = p;
  }
  return suscription_;
}
inline ::payment::v1alpha1::Suscription* UpdateSuscriptionResponse::mutable_suscription() {
  ::payment::v1alpha1::Suscription* _msg = _internal_mutable_suscription();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.UpdateSuscriptionResponse.suscription)
  return _msg;
}
inline void UpdateSuscriptionResponse::set_allocated_suscription(::payment::v1alpha1::Suscription* suscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_);
  }
  if (suscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription));
    if (message_arena != submessage_arena) {
      suscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, suscription, submessage_arena);
    }
    
  } else {
    
  }
  suscription_ = suscription;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.UpdateSuscriptionResponse.suscription)
}

// string status = 2 [json_name = "status"];
inline void UpdateSuscriptionResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& UpdateSuscriptionResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdateSuscriptionResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSuscriptionResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.UpdateSuscriptionResponse.status)
}
inline std::string* UpdateSuscriptionResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.UpdateSuscriptionResponse.status)
  return _s;
}
inline const std::string& UpdateSuscriptionResponse::_internal_status() const {
  return status_.Get();
}
inline void UpdateSuscriptionResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateSuscriptionResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateSuscriptionResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.UpdateSuscriptionResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateSuscriptionResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.UpdateSuscriptionResponse.status)
}

// -------------------------------------------------------------------

// CreateSuscriptionRequest

// string customer_id = 1 [json_name = "customerId"];
inline void CreateSuscriptionRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& CreateSuscriptionRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateSuscriptionRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSuscriptionRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateSuscriptionRequest.customer_id)
}
inline std::string* CreateSuscriptionRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateSuscriptionRequest.customer_id)
  return _s;
}
inline const std::string& CreateSuscriptionRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void CreateSuscriptionRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSuscriptionRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSuscriptionRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateSuscriptionRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSuscriptionRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateSuscriptionRequest.customer_id)
}

// .payment.v1alpha1.Suscription suscription = 2 [json_name = "suscription"];
inline bool CreateSuscriptionRequest::_internal_has_suscription() const {
  return this != internal_default_instance() && suscription_ != nullptr;
}
inline bool CreateSuscriptionRequest::has_suscription() const {
  return _internal_has_suscription();
}
inline const ::payment::v1alpha1::Suscription& CreateSuscriptionRequest::_internal_suscription() const {
  const ::payment::v1alpha1::Suscription* p = suscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Suscription&>(
      ::payment::v1alpha1::_Suscription_default_instance_);
}
inline const ::payment::v1alpha1::Suscription& CreateSuscriptionRequest::suscription() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateSuscriptionRequest.suscription)
  return _internal_suscription();
}
inline void CreateSuscriptionRequest::unsafe_arena_set_allocated_suscription(
    ::payment::v1alpha1::Suscription* suscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_);
  }
  suscription_ = suscription;
  if (suscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateSuscriptionRequest.suscription)
}
inline ::payment::v1alpha1::Suscription* CreateSuscriptionRequest::release_suscription() {
  
  ::payment::v1alpha1::Suscription* temp = suscription_;
  suscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Suscription* CreateSuscriptionRequest::unsafe_arena_release_suscription() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateSuscriptionRequest.suscription)
  
  ::payment::v1alpha1::Suscription* temp = suscription_;
  suscription_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Suscription* CreateSuscriptionRequest::_internal_mutable_suscription() {
  
  if (suscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Suscription>(GetArenaForAllocation());
    suscription_ = p;
  }
  return suscription_;
}
inline ::payment::v1alpha1::Suscription* CreateSuscriptionRequest::mutable_suscription() {
  ::payment::v1alpha1::Suscription* _msg = _internal_mutable_suscription();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateSuscriptionRequest.suscription)
  return _msg;
}
inline void CreateSuscriptionRequest::set_allocated_suscription(::payment::v1alpha1::Suscription* suscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription_);
  }
  if (suscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(suscription));
    if (message_arena != submessage_arena) {
      suscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, suscription, submessage_arena);
    }
    
  } else {
    
  }
  suscription_ = suscription;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateSuscriptionRequest.suscription)
}

// -------------------------------------------------------------------

// CreateSuscriptionResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool CreateSuscriptionResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool CreateSuscriptionResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& CreateSuscriptionResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& CreateSuscriptionResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateSuscriptionResponse.customer)
  return _internal_customer();
}
inline void CreateSuscriptionResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateSuscriptionResponse.customer)
}
inline ::payment::v1alpha1::Customer* CreateSuscriptionResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* CreateSuscriptionResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateSuscriptionResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* CreateSuscriptionResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* CreateSuscriptionResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateSuscriptionResponse.customer)
  return _msg;
}
inline void CreateSuscriptionResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateSuscriptionResponse.customer)
}

// string status = 2 [json_name = "status"];
inline void CreateSuscriptionResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateSuscriptionResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateSuscriptionResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSuscriptionResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateSuscriptionResponse.status)
}
inline std::string* CreateSuscriptionResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateSuscriptionResponse.status)
  return _s;
}
inline const std::string& CreateSuscriptionResponse::_internal_status() const {
  return status_.Get();
}
inline void CreateSuscriptionResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSuscriptionResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSuscriptionResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateSuscriptionResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSuscriptionResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateSuscriptionResponse.status)
}

// -------------------------------------------------------------------

// CreateInvoiceRequest

// string invoice_id = 1 [json_name = "invoiceId"];
inline void CreateInvoiceRequest::clear_invoice_id() {
  invoice_id_.ClearToEmpty();
}
inline const std::string& CreateInvoiceRequest::invoice_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceRequest.invoice_id)
  return _internal_invoice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInvoiceRequest::set_invoice_id(ArgT0&& arg0, ArgT... args) {
 
 invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateInvoiceRequest.invoice_id)
}
inline std::string* CreateInvoiceRequest::mutable_invoice_id() {
  std::string* _s = _internal_mutable_invoice_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceRequest.invoice_id)
  return _s;
}
inline const std::string& CreateInvoiceRequest::_internal_invoice_id() const {
  return invoice_id_.Get();
}
inline void CreateInvoiceRequest::_internal_set_invoice_id(const std::string& value) {
  
  invoice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::_internal_mutable_invoice_id() {
  
  return invoice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::release_invoice_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceRequest.invoice_id)
  return invoice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateInvoiceRequest::set_allocated_invoice_id(std::string* invoice_id) {
  if (invoice_id != nullptr) {
    
  } else {
    
  }
  invoice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), invoice_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceRequest.invoice_id)
}

// string status = 2 [json_name = "status"];
inline void CreateInvoiceRequest::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateInvoiceRequest::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceRequest.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInvoiceRequest::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateInvoiceRequest.status)
}
inline std::string* CreateInvoiceRequest::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceRequest.status)
  return _s;
}
inline const std::string& CreateInvoiceRequest::_internal_status() const {
  return status_.Get();
}
inline void CreateInvoiceRequest::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateInvoiceRequest::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceRequest.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateInvoiceRequest::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceRequest.status)
}

// -------------------------------------------------------------------

// CreateInvoiceResponse

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool CreateInvoiceResponse::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool CreateInvoiceResponse::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& CreateInvoiceResponse::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& CreateInvoiceResponse::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceResponse.customer)
  return _internal_customer();
}
inline void CreateInvoiceResponse::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateInvoiceResponse.customer)
}
inline ::payment::v1alpha1::Customer* CreateInvoiceResponse::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* CreateInvoiceResponse::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceResponse.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* CreateInvoiceResponse::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* CreateInvoiceResponse::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceResponse.customer)
  return _msg;
}
inline void CreateInvoiceResponse::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceResponse.customer)
}

// string status = 4 [json_name = "status"];
inline void CreateInvoiceResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateInvoiceResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateInvoiceResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInvoiceResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateInvoiceResponse.status)
}
inline std::string* CreateInvoiceResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateInvoiceResponse.status)
  return _s;
}
inline const std::string& CreateInvoiceResponse::_internal_status() const {
  return status_.Get();
}
inline void CreateInvoiceResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateInvoiceResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateInvoiceResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateInvoiceResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateInvoiceResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateInvoiceResponse.status)
}

// -------------------------------------------------------------------

// CreateCardRequest

// .payment.v1alpha1.Card card = 1 [json_name = "card"];
inline bool CreateCardRequest::_internal_has_card() const {
  return this != internal_default_instance() && card_ != nullptr;
}
inline bool CreateCardRequest::has_card() const {
  return _internal_has_card();
}
inline const ::payment::v1alpha1::Card& CreateCardRequest::_internal_card() const {
  const ::payment::v1alpha1::Card* p = card_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Card&>(
      ::payment::v1alpha1::_Card_default_instance_);
}
inline const ::payment::v1alpha1::Card& CreateCardRequest::card() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCardRequest.card)
  return _internal_card();
}
inline void CreateCardRequest::unsafe_arena_set_allocated_card(
    ::payment::v1alpha1::Card* card) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(card_);
  }
  card_ = card;
  if (card) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateCardRequest.card)
}
inline ::payment::v1alpha1::Card* CreateCardRequest::release_card() {
  
  ::payment::v1alpha1::Card* temp = card_;
  card_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Card* CreateCardRequest::unsafe_arena_release_card() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCardRequest.card)
  
  ::payment::v1alpha1::Card* temp = card_;
  card_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Card* CreateCardRequest::_internal_mutable_card() {
  
  if (card_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Card>(GetArenaForAllocation());
    card_ = p;
  }
  return card_;
}
inline ::payment::v1alpha1::Card* CreateCardRequest::mutable_card() {
  ::payment::v1alpha1::Card* _msg = _internal_mutable_card();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCardRequest.card)
  return _msg;
}
inline void CreateCardRequest::set_allocated_card(::payment::v1alpha1::Card* card) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(card_);
  }
  if (card) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(card));
    if (message_arena != submessage_arena) {
      card = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, card, submessage_arena);
    }
    
  } else {
    
  }
  card_ = card;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCardRequest.card)
}

// -------------------------------------------------------------------

// CreateCardResponse

// string token_id = 1 [json_name = "tokenId"];
inline void CreateCardResponse::clear_token_id() {
  token_id_.ClearToEmpty();
}
inline const std::string& CreateCardResponse::token_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCardResponse.token_id)
  return _internal_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCardResponse::set_token_id(ArgT0&& arg0, ArgT... args) {
 
 token_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCardResponse.token_id)
}
inline std::string* CreateCardResponse::mutable_token_id() {
  std::string* _s = _internal_mutable_token_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCardResponse.token_id)
  return _s;
}
inline const std::string& CreateCardResponse::_internal_token_id() const {
  return token_id_.Get();
}
inline void CreateCardResponse::_internal_set_token_id(const std::string& value) {
  
  token_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCardResponse::_internal_mutable_token_id() {
  
  return token_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCardResponse::release_token_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCardResponse.token_id)
  return token_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCardResponse::set_allocated_token_id(std::string* token_id) {
  if (token_id != nullptr) {
    
  } else {
    
  }
  token_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCardResponse.token_id)
}

// string status = 2 [json_name = "status"];
inline void CreateCardResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateCardResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCardResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCardResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCardResponse.status)
}
inline std::string* CreateCardResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCardResponse.status)
  return _s;
}
inline const std::string& CreateCardResponse::_internal_status() const {
  return status_.Get();
}
inline void CreateCardResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCardResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCardResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCardResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCardResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCardResponse.status)
}

// -------------------------------------------------------------------

// CancelSuscriptionRequest

// string suscription_id = 1 [json_name = "suscriptionId"];
inline void CancelSuscriptionRequest::clear_suscription_id() {
  suscription_id_.ClearToEmpty();
}
inline const std::string& CancelSuscriptionRequest::suscription_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CancelSuscriptionRequest.suscription_id)
  return _internal_suscription_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelSuscriptionRequest::set_suscription_id(ArgT0&& arg0, ArgT... args) {
 
 suscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CancelSuscriptionRequest.suscription_id)
}
inline std::string* CancelSuscriptionRequest::mutable_suscription_id() {
  std::string* _s = _internal_mutable_suscription_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CancelSuscriptionRequest.suscription_id)
  return _s;
}
inline const std::string& CancelSuscriptionRequest::_internal_suscription_id() const {
  return suscription_id_.Get();
}
inline void CancelSuscriptionRequest::_internal_set_suscription_id(const std::string& value) {
  
  suscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelSuscriptionRequest::_internal_mutable_suscription_id() {
  
  return suscription_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelSuscriptionRequest::release_suscription_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CancelSuscriptionRequest.suscription_id)
  return suscription_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelSuscriptionRequest::set_allocated_suscription_id(std::string* suscription_id) {
  if (suscription_id != nullptr) {
    
  } else {
    
  }
  suscription_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), suscription_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CancelSuscriptionRequest.suscription_id)
}

// -------------------------------------------------------------------

// CancelSuscriptionResponse

// string status = 1 [json_name = "status"];
inline void CancelSuscriptionResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CancelSuscriptionResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CancelSuscriptionResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelSuscriptionResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CancelSuscriptionResponse.status)
}
inline std::string* CancelSuscriptionResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CancelSuscriptionResponse.status)
  return _s;
}
inline const std::string& CancelSuscriptionResponse::_internal_status() const {
  return status_.Get();
}
inline void CancelSuscriptionResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelSuscriptionResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelSuscriptionResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CancelSuscriptionResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelSuscriptionResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CancelSuscriptionResponse.status)
}

// -------------------------------------------------------------------

// CreateCustomerRequest

// .payment.v1alpha1.Customer customer = 1 [json_name = "customer"];
inline bool CreateCustomerRequest::_internal_has_customer() const {
  return this != internal_default_instance() && customer_ != nullptr;
}
inline bool CreateCustomerRequest::has_customer() const {
  return _internal_has_customer();
}
inline const ::payment::v1alpha1::Customer& CreateCustomerRequest::_internal_customer() const {
  const ::payment::v1alpha1::Customer* p = customer_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Customer&>(
      ::payment::v1alpha1::_Customer_default_instance_);
}
inline const ::payment::v1alpha1::Customer& CreateCustomerRequest::customer() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCustomerRequest.customer)
  return _internal_customer();
}
inline void CreateCustomerRequest::unsafe_arena_set_allocated_customer(
    ::payment::v1alpha1::Customer* customer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  customer_ = customer;
  if (customer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreateCustomerRequest.customer)
}
inline ::payment::v1alpha1::Customer* CreateCustomerRequest::release_customer() {
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Customer* CreateCustomerRequest::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCustomerRequest.customer)
  
  ::payment::v1alpha1::Customer* temp = customer_;
  customer_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Customer* CreateCustomerRequest::_internal_mutable_customer() {
  
  if (customer_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Customer>(GetArenaForAllocation());
    customer_ = p;
  }
  return customer_;
}
inline ::payment::v1alpha1::Customer* CreateCustomerRequest::mutable_customer() {
  ::payment::v1alpha1::Customer* _msg = _internal_mutable_customer();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCustomerRequest.customer)
  return _msg;
}
inline void CreateCustomerRequest::set_allocated_customer(::payment::v1alpha1::Customer* customer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_);
  }
  if (customer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer));
    if (message_arena != submessage_arena) {
      customer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer, submessage_arena);
    }
    
  } else {
    
  }
  customer_ = customer;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCustomerRequest.customer)
}

// -------------------------------------------------------------------

// CreateCustomerResponse

// string customer_id = 1 [json_name = "customerId"];
inline void CreateCustomerResponse::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& CreateCustomerResponse::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCustomerResponse.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCustomerResponse::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCustomerResponse.customer_id)
}
inline std::string* CreateCustomerResponse::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCustomerResponse.customer_id)
  return _s;
}
inline const std::string& CreateCustomerResponse::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void CreateCustomerResponse::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCustomerResponse::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCustomerResponse::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCustomerResponse.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCustomerResponse::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCustomerResponse.customer_id)
}

// string status = 2 [json_name = "status"];
inline void CreateCustomerResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateCustomerResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreateCustomerResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCustomerResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreateCustomerResponse.status)
}
inline std::string* CreateCustomerResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreateCustomerResponse.status)
  return _s;
}
inline const std::string& CreateCustomerResponse::_internal_status() const {
  return status_.Get();
}
inline void CreateCustomerResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCustomerResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCustomerResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreateCustomerResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateCustomerResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreateCustomerResponse.status)
}

// -------------------------------------------------------------------

// CreatePaymentRequest

// string customer_id = 1 [json_name = "customerId"];
inline void CreatePaymentRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& CreatePaymentRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePaymentRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreatePaymentRequest.customer_id)
}
inline std::string* CreatePaymentRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentRequest.customer_id)
  return _s;
}
inline const std::string& CreatePaymentRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void CreatePaymentRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePaymentRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePaymentRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePaymentRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentRequest.customer_id)
}

// .payment.v1alpha1.Payment payment = 2 [json_name = "payment"];
inline bool CreatePaymentRequest::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool CreatePaymentRequest::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::Payment& CreatePaymentRequest::_internal_payment() const {
  const ::payment::v1alpha1::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Payment&>(
      ::payment::v1alpha1::_Payment_default_instance_);
}
inline const ::payment::v1alpha1::Payment& CreatePaymentRequest::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentRequest.payment)
  return _internal_payment();
}
inline void CreatePaymentRequest::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.CreatePaymentRequest.payment)
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::release_payment() {
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentRequest.payment)
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::Payment* CreatePaymentRequest::mutable_payment() {
  ::payment::v1alpha1::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentRequest.payment)
  return _msg;
}
inline void CreatePaymentRequest::set_allocated_payment(::payment::v1alpha1::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentRequest.payment)
}

// -------------------------------------------------------------------

// CreatePaymentResponse

// string card_id = 1 [json_name = "cardId"];
inline void CreatePaymentResponse::clear_card_id() {
  card_id_.ClearToEmpty();
}
inline const std::string& CreatePaymentResponse::card_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentResponse.card_id)
  return _internal_card_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePaymentResponse::set_card_id(ArgT0&& arg0, ArgT... args) {
 
 card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreatePaymentResponse.card_id)
}
inline std::string* CreatePaymentResponse::mutable_card_id() {
  std::string* _s = _internal_mutable_card_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentResponse.card_id)
  return _s;
}
inline const std::string& CreatePaymentResponse::_internal_card_id() const {
  return card_id_.Get();
}
inline void CreatePaymentResponse::_internal_set_card_id(const std::string& value) {
  
  card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePaymentResponse::_internal_mutable_card_id() {
  
  return card_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePaymentResponse::release_card_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentResponse.card_id)
  return card_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePaymentResponse::set_allocated_card_id(std::string* card_id) {
  if (card_id != nullptr) {
    
  } else {
    
  }
  card_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentResponse.card_id)
}

// string status = 2 [json_name = "status"];
inline void CreatePaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreatePaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.CreatePaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.CreatePaymentResponse.status)
}
inline std::string* CreatePaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.CreatePaymentResponse.status)
  return _s;
}
inline const std::string& CreatePaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void CreatePaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.CreatePaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.CreatePaymentResponse.status)
}

// -------------------------------------------------------------------

// UpdatePaymentRequest

// string customer_id = 1 [json_name = "customerId"];
inline void UpdatePaymentRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& UpdatePaymentRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdatePaymentRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdatePaymentRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.UpdatePaymentRequest.customer_id)
}
inline std::string* UpdatePaymentRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.UpdatePaymentRequest.customer_id)
  return _s;
}
inline const std::string& UpdatePaymentRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void UpdatePaymentRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdatePaymentRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdatePaymentRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.UpdatePaymentRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdatePaymentRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.UpdatePaymentRequest.customer_id)
}

// .payment.v1alpha1.Payment payment = 2 [json_name = "payment"];
inline bool UpdatePaymentRequest::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool UpdatePaymentRequest::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::Payment& UpdatePaymentRequest::_internal_payment() const {
  const ::payment::v1alpha1::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Payment&>(
      ::payment::v1alpha1::_Payment_default_instance_);
}
inline const ::payment::v1alpha1::Payment& UpdatePaymentRequest::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdatePaymentRequest.payment)
  return _internal_payment();
}
inline void UpdatePaymentRequest::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.UpdatePaymentRequest.payment)
}
inline ::payment::v1alpha1::Payment* UpdatePaymentRequest::release_payment() {
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Payment* UpdatePaymentRequest::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.UpdatePaymentRequest.payment)
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Payment* UpdatePaymentRequest::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::Payment* UpdatePaymentRequest::mutable_payment() {
  ::payment::v1alpha1::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.UpdatePaymentRequest.payment)
  return _msg;
}
inline void UpdatePaymentRequest::set_allocated_payment(::payment::v1alpha1::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.UpdatePaymentRequest.payment)
}

// -------------------------------------------------------------------

// UpdatePaymentResponse

// .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
inline bool UpdatePaymentResponse::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool UpdatePaymentResponse::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::Payment& UpdatePaymentResponse::_internal_payment() const {
  const ::payment::v1alpha1::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Payment&>(
      ::payment::v1alpha1::_Payment_default_instance_);
}
inline const ::payment::v1alpha1::Payment& UpdatePaymentResponse::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdatePaymentResponse.payment)
  return _internal_payment();
}
inline void UpdatePaymentResponse::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.UpdatePaymentResponse.payment)
}
inline ::payment::v1alpha1::Payment* UpdatePaymentResponse::release_payment() {
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Payment* UpdatePaymentResponse::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.UpdatePaymentResponse.payment)
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Payment* UpdatePaymentResponse::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::Payment* UpdatePaymentResponse::mutable_payment() {
  ::payment::v1alpha1::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.UpdatePaymentResponse.payment)
  return _msg;
}
inline void UpdatePaymentResponse::set_allocated_payment(::payment::v1alpha1::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.UpdatePaymentResponse.payment)
}

// string status = 2 [json_name = "status"];
inline void UpdatePaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& UpdatePaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.UpdatePaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdatePaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.UpdatePaymentResponse.status)
}
inline std::string* UpdatePaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.UpdatePaymentResponse.status)
  return _s;
}
inline const std::string& UpdatePaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void UpdatePaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdatePaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdatePaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.UpdatePaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdatePaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.UpdatePaymentResponse.status)
}

// -------------------------------------------------------------------

// DeletePaymentRequest

// string card_id = 1 [json_name = "cardId"];
inline void DeletePaymentRequest::clear_card_id() {
  card_id_.ClearToEmpty();
}
inline const std::string& DeletePaymentRequest::card_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentRequest.card_id)
  return _internal_card_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePaymentRequest::set_card_id(ArgT0&& arg0, ArgT... args) {
 
 card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentRequest.card_id)
}
inline std::string* DeletePaymentRequest::mutable_card_id() {
  std::string* _s = _internal_mutable_card_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeletePaymentRequest.card_id)
  return _s;
}
inline const std::string& DeletePaymentRequest::_internal_card_id() const {
  return card_id_.Get();
}
inline void DeletePaymentRequest::_internal_set_card_id(const std::string& value) {
  
  card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::_internal_mutable_card_id() {
  
  return card_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::release_card_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeletePaymentRequest.card_id)
  return card_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePaymentRequest::set_allocated_card_id(std::string* card_id) {
  if (card_id != nullptr) {
    
  } else {
    
  }
  card_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeletePaymentRequest.card_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void DeletePaymentRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& DeletePaymentRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePaymentRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentRequest.customer_id)
}
inline std::string* DeletePaymentRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeletePaymentRequest.customer_id)
  return _s;
}
inline const std::string& DeletePaymentRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void DeletePaymentRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePaymentRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeletePaymentRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePaymentRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeletePaymentRequest.customer_id)
}

// -------------------------------------------------------------------

// DeletePaymentResponse

// string status = 1 [json_name = "status"];
inline void DeletePaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& DeletePaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.DeletePaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.DeletePaymentResponse.status)
}
inline std::string* DeletePaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.DeletePaymentResponse.status)
  return _s;
}
inline const std::string& DeletePaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void DeletePaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.DeletePaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.DeletePaymentResponse.status)
}

// -------------------------------------------------------------------

// GetPaymentRequest

// string card_id = 1 [json_name = "cardId"];
inline void GetPaymentRequest::clear_card_id() {
  card_id_.ClearToEmpty();
}
inline const std::string& GetPaymentRequest::card_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentRequest.card_id)
  return _internal_card_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentRequest::set_card_id(ArgT0&& arg0, ArgT... args) {
 
 card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentRequest.card_id)
}
inline std::string* GetPaymentRequest::mutable_card_id() {
  std::string* _s = _internal_mutable_card_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentRequest.card_id)
  return _s;
}
inline const std::string& GetPaymentRequest::_internal_card_id() const {
  return card_id_.Get();
}
inline void GetPaymentRequest::_internal_set_card_id(const std::string& value) {
  
  card_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentRequest::_internal_mutable_card_id() {
  
  return card_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentRequest::release_card_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentRequest.card_id)
  return card_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentRequest::set_allocated_card_id(std::string* card_id) {
  if (card_id != nullptr) {
    
  } else {
    
  }
  card_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), card_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentRequest.card_id)
}

// string customer_id = 2 [json_name = "customerId"];
inline void GetPaymentRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& GetPaymentRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentRequest.customer_id)
}
inline std::string* GetPaymentRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentRequest.customer_id)
  return _s;
}
inline const std::string& GetPaymentRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void GetPaymentRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentRequest.customer_id)
}

// -------------------------------------------------------------------

// GetPaymentResponse

// .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
inline bool GetPaymentResponse::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool GetPaymentResponse::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::Payment& GetPaymentResponse::_internal_payment() const {
  const ::payment::v1alpha1::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Payment&>(
      ::payment::v1alpha1::_Payment_default_instance_);
}
inline const ::payment::v1alpha1::Payment& GetPaymentResponse::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentResponse.payment)
  return _internal_payment();
}
inline void GetPaymentResponse::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.GetPaymentResponse.payment)
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::release_payment() {
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentResponse.payment)
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::Payment* GetPaymentResponse::mutable_payment() {
  ::payment::v1alpha1::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentResponse.payment)
  return _msg;
}
inline void GetPaymentResponse::set_allocated_payment(::payment::v1alpha1::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentResponse.payment)
}

// string status = 2 [json_name = "status"];
inline void GetPaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetPaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.GetPaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.GetPaymentResponse.status)
}
inline std::string* GetPaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.GetPaymentResponse.status)
  return _s;
}
inline const std::string& GetPaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void GetPaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.GetPaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.GetPaymentResponse.status)
}

// -------------------------------------------------------------------

// ListPaymentRequest

// string customer_id = 1 [json_name = "customerId"];
inline void ListPaymentRequest::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& ListPaymentRequest::customer_id() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentRequest.customer_id)
  return _internal_customer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPaymentRequest::set_customer_id(ArgT0&& arg0, ArgT... args) {
 
 customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListPaymentRequest.customer_id)
}
inline std::string* ListPaymentRequest::mutable_customer_id() {
  std::string* _s = _internal_mutable_customer_id();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListPaymentRequest.customer_id)
  return _s;
}
inline const std::string& ListPaymentRequest::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void ListPaymentRequest::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPaymentRequest::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPaymentRequest::release_customer_id() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListPaymentRequest.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPaymentRequest::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListPaymentRequest.customer_id)
}

// -------------------------------------------------------------------

// ListPaymentResponse

// .payment.v1alpha1.Payment payment = 1 [json_name = "payment"];
inline bool ListPaymentResponse::_internal_has_payment() const {
  return this != internal_default_instance() && payment_ != nullptr;
}
inline bool ListPaymentResponse::has_payment() const {
  return _internal_has_payment();
}
inline const ::payment::v1alpha1::Payment& ListPaymentResponse::_internal_payment() const {
  const ::payment::v1alpha1::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payment::v1alpha1::Payment&>(
      ::payment::v1alpha1::_Payment_default_instance_);
}
inline const ::payment::v1alpha1::Payment& ListPaymentResponse::payment() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentResponse.payment)
  return _internal_payment();
}
inline void ListPaymentResponse::unsafe_arena_set_allocated_payment(
    ::payment::v1alpha1::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payment.v1alpha1.ListPaymentResponse.payment)
}
inline ::payment::v1alpha1::Payment* ListPaymentResponse::release_payment() {
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payment::v1alpha1::Payment* ListPaymentResponse::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListPaymentResponse.payment)
  
  ::payment::v1alpha1::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payment::v1alpha1::Payment* ListPaymentResponse::_internal_mutable_payment() {
  
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payment::v1alpha1::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payment::v1alpha1::Payment* ListPaymentResponse::mutable_payment() {
  ::payment::v1alpha1::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListPaymentResponse.payment)
  return _msg;
}
inline void ListPaymentResponse::set_allocated_payment(::payment::v1alpha1::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment));
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    
  } else {
    
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListPaymentResponse.payment)
}

// string status = 2 [json_name = "status"];
inline void ListPaymentResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& ListPaymentResponse::status() const {
  // @@protoc_insertion_point(field_get:payment.v1alpha1.ListPaymentResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPaymentResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payment.v1alpha1.ListPaymentResponse.status)
}
inline std::string* ListPaymentResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:payment.v1alpha1.ListPaymentResponse.status)
  return _s;
}
inline const std::string& ListPaymentResponse::_internal_status() const {
  return status_.Get();
}
inline void ListPaymentResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPaymentResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPaymentResponse::release_status() {
  // @@protoc_insertion_point(field_release:payment.v1alpha1.ListPaymentResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPaymentResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payment.v1alpha1.ListPaymentResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace payment

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_payment_2fv1alpha1_2fpayment_5fapi_2eproto
