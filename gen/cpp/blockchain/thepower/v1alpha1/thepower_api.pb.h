// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: blockchain/thepower/v1alpha1/thepower_api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "blockchain/thepower/v1alpha1/thepower.pb.h"
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto;
namespace blockchain {
namespace thepower {
namespace v1alpha1 {
class CreateTpChainRequest;
struct CreateTpChainRequestDefaultTypeInternal;
extern CreateTpChainRequestDefaultTypeInternal _CreateTpChainRequest_default_instance_;
class CreateTpChainResponse;
struct CreateTpChainResponseDefaultTypeInternal;
extern CreateTpChainResponseDefaultTypeInternal _CreateTpChainResponse_default_instance_;
class GetTpChainByIdRequest;
struct GetTpChainByIdRequestDefaultTypeInternal;
extern GetTpChainByIdRequestDefaultTypeInternal _GetTpChainByIdRequest_default_instance_;
class GetTpChainByIdResponse;
struct GetTpChainByIdResponseDefaultTypeInternal;
extern GetTpChainByIdResponseDefaultTypeInternal _GetTpChainByIdResponse_default_instance_;
class GetTpChainsByUserIdRequest;
struct GetTpChainsByUserIdRequestDefaultTypeInternal;
extern GetTpChainsByUserIdRequestDefaultTypeInternal _GetTpChainsByUserIdRequest_default_instance_;
class GetTpChainsByUserIdResponse;
struct GetTpChainsByUserIdResponseDefaultTypeInternal;
extern GetTpChainsByUserIdResponseDefaultTypeInternal _GetTpChainsByUserIdResponse_default_instance_;
class GetTpChainsRequest;
struct GetTpChainsRequestDefaultTypeInternal;
extern GetTpChainsRequestDefaultTypeInternal _GetTpChainsRequest_default_instance_;
class GetTpChainsResponse;
struct GetTpChainsResponseDefaultTypeInternal;
extern GetTpChainsResponseDefaultTypeInternal _GetTpChainsResponse_default_instance_;
class UpdateTpChainRequest;
struct UpdateTpChainRequestDefaultTypeInternal;
extern UpdateTpChainRequestDefaultTypeInternal _UpdateTpChainRequest_default_instance_;
class UpdateTpChainResponse;
struct UpdateTpChainResponseDefaultTypeInternal;
extern UpdateTpChainResponseDefaultTypeInternal _UpdateTpChainResponse_default_instance_;
}  // namespace v1alpha1
}  // namespace thepower
}  // namespace blockchain
PROTOBUF_NAMESPACE_OPEN
template<> ::blockchain::thepower::v1alpha1::CreateTpChainRequest* Arena::CreateMaybeMessage<::blockchain::thepower::v1alpha1::CreateTpChainRequest>(Arena*);
template<> ::blockchain::thepower::v1alpha1::CreateTpChainResponse* Arena::CreateMaybeMessage<::blockchain::thepower::v1alpha1::CreateTpChainResponse>(Arena*);
template<> ::blockchain::thepower::v1alpha1::GetTpChainByIdRequest* Arena::CreateMaybeMessage<::blockchain::thepower::v1alpha1::GetTpChainByIdRequest>(Arena*);
template<> ::blockchain::thepower::v1alpha1::GetTpChainByIdResponse* Arena::CreateMaybeMessage<::blockchain::thepower::v1alpha1::GetTpChainByIdResponse>(Arena*);
template<> ::blockchain::thepower::v1alpha1::GetTpChainsByUserIdRequest* Arena::CreateMaybeMessage<::blockchain::thepower::v1alpha1::GetTpChainsByUserIdRequest>(Arena*);
template<> ::blockchain::thepower::v1alpha1::GetTpChainsByUserIdResponse* Arena::CreateMaybeMessage<::blockchain::thepower::v1alpha1::GetTpChainsByUserIdResponse>(Arena*);
template<> ::blockchain::thepower::v1alpha1::GetTpChainsRequest* Arena::CreateMaybeMessage<::blockchain::thepower::v1alpha1::GetTpChainsRequest>(Arena*);
template<> ::blockchain::thepower::v1alpha1::GetTpChainsResponse* Arena::CreateMaybeMessage<::blockchain::thepower::v1alpha1::GetTpChainsResponse>(Arena*);
template<> ::blockchain::thepower::v1alpha1::UpdateTpChainRequest* Arena::CreateMaybeMessage<::blockchain::thepower::v1alpha1::UpdateTpChainRequest>(Arena*);
template<> ::blockchain::thepower::v1alpha1::UpdateTpChainResponse* Arena::CreateMaybeMessage<::blockchain::thepower::v1alpha1::UpdateTpChainResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace blockchain {
namespace thepower {
namespace v1alpha1 {

// ===================================================================

class CreateTpChainRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blockchain.thepower.v1alpha1.CreateTpChainRequest) */ {
 public:
  inline CreateTpChainRequest() : CreateTpChainRequest(nullptr) {}
  ~CreateTpChainRequest() override;
  explicit constexpr CreateTpChainRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTpChainRequest(const CreateTpChainRequest& from);
  CreateTpChainRequest(CreateTpChainRequest&& from) noexcept
    : CreateTpChainRequest() {
    *this = ::std::move(from);
  }

  inline CreateTpChainRequest& operator=(const CreateTpChainRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTpChainRequest& operator=(CreateTpChainRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTpChainRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTpChainRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTpChainRequest*>(
               &_CreateTpChainRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateTpChainRequest& a, CreateTpChainRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTpChainRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTpChainRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTpChainRequest* New() const final {
    return new CreateTpChainRequest();
  }

  CreateTpChainRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTpChainRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTpChainRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateTpChainRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTpChainRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blockchain.thepower.v1alpha1.CreateTpChainRequest";
  }
  protected:
  explicit CreateTpChainRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTpChainFieldNumber = 1,
  };
  // .blockchain.thepower.v1alpha1.TpChain tp_chain = 1 [json_name = "tpChain"];
  bool has_tp_chain() const;
  private:
  bool _internal_has_tp_chain() const;
  public:
  void clear_tp_chain();
  const ::blockchain::thepower::v1alpha1::TpChain& tp_chain() const;
  PROTOBUF_MUST_USE_RESULT ::blockchain::thepower::v1alpha1::TpChain* release_tp_chain();
  ::blockchain::thepower::v1alpha1::TpChain* mutable_tp_chain();
  void set_allocated_tp_chain(::blockchain::thepower::v1alpha1::TpChain* tp_chain);
  private:
  const ::blockchain::thepower::v1alpha1::TpChain& _internal_tp_chain() const;
  ::blockchain::thepower::v1alpha1::TpChain* _internal_mutable_tp_chain();
  public:
  void unsafe_arena_set_allocated_tp_chain(
      ::blockchain::thepower::v1alpha1::TpChain* tp_chain);
  ::blockchain::thepower::v1alpha1::TpChain* unsafe_arena_release_tp_chain();

  // @@protoc_insertion_point(class_scope:blockchain.thepower.v1alpha1.CreateTpChainRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::blockchain::thepower::v1alpha1::TpChain* tp_chain_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetTpChainsByUserIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blockchain.thepower.v1alpha1.GetTpChainsByUserIdRequest) */ {
 public:
  inline GetTpChainsByUserIdRequest() : GetTpChainsByUserIdRequest(nullptr) {}
  ~GetTpChainsByUserIdRequest() override;
  explicit constexpr GetTpChainsByUserIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTpChainsByUserIdRequest(const GetTpChainsByUserIdRequest& from);
  GetTpChainsByUserIdRequest(GetTpChainsByUserIdRequest&& from) noexcept
    : GetTpChainsByUserIdRequest() {
    *this = ::std::move(from);
  }

  inline GetTpChainsByUserIdRequest& operator=(const GetTpChainsByUserIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTpChainsByUserIdRequest& operator=(GetTpChainsByUserIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTpChainsByUserIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTpChainsByUserIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetTpChainsByUserIdRequest*>(
               &_GetTpChainsByUserIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetTpChainsByUserIdRequest& a, GetTpChainsByUserIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTpChainsByUserIdRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTpChainsByUserIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTpChainsByUserIdRequest* New() const final {
    return new GetTpChainsByUserIdRequest();
  }

  GetTpChainsByUserIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTpChainsByUserIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTpChainsByUserIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTpChainsByUserIdRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTpChainsByUserIdRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blockchain.thepower.v1alpha1.GetTpChainsByUserIdRequest";
  }
  protected:
  explicit GetTpChainsByUserIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kLimitFieldNumber = 3,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // int64 offset = 2 [json_name = "offset"];
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 limit = 3 [json_name = "limit"];
  void clear_limit();
  ::PROTOBUF_NAMESPACE_ID::int64 limit() const;
  void set_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_limit() const;
  void _internal_set_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:blockchain.thepower.v1alpha1.GetTpChainsByUserIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  ::PROTOBUF_NAMESPACE_ID::int64 limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetTpChainByIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blockchain.thepower.v1alpha1.GetTpChainByIdRequest) */ {
 public:
  inline GetTpChainByIdRequest() : GetTpChainByIdRequest(nullptr) {}
  ~GetTpChainByIdRequest() override;
  explicit constexpr GetTpChainByIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTpChainByIdRequest(const GetTpChainByIdRequest& from);
  GetTpChainByIdRequest(GetTpChainByIdRequest&& from) noexcept
    : GetTpChainByIdRequest() {
    *this = ::std::move(from);
  }

  inline GetTpChainByIdRequest& operator=(const GetTpChainByIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTpChainByIdRequest& operator=(GetTpChainByIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTpChainByIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTpChainByIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetTpChainByIdRequest*>(
               &_GetTpChainByIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetTpChainByIdRequest& a, GetTpChainByIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTpChainByIdRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTpChainByIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTpChainByIdRequest* New() const final {
    return new GetTpChainByIdRequest();
  }

  GetTpChainByIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTpChainByIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTpChainByIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTpChainByIdRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTpChainByIdRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blockchain.thepower.v1alpha1.GetTpChainByIdRequest";
  }
  protected:
  explicit GetTpChainByIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:blockchain.thepower.v1alpha1.GetTpChainByIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetTpChainsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blockchain.thepower.v1alpha1.GetTpChainsRequest) */ {
 public:
  inline GetTpChainsRequest() : GetTpChainsRequest(nullptr) {}
  ~GetTpChainsRequest() override;
  explicit constexpr GetTpChainsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTpChainsRequest(const GetTpChainsRequest& from);
  GetTpChainsRequest(GetTpChainsRequest&& from) noexcept
    : GetTpChainsRequest() {
    *this = ::std::move(from);
  }

  inline GetTpChainsRequest& operator=(const GetTpChainsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTpChainsRequest& operator=(GetTpChainsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTpChainsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTpChainsRequest* internal_default_instance() {
    return reinterpret_cast<const GetTpChainsRequest*>(
               &_GetTpChainsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetTpChainsRequest& a, GetTpChainsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTpChainsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTpChainsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTpChainsRequest* New() const final {
    return new GetTpChainsRequest();
  }

  GetTpChainsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTpChainsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTpChainsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTpChainsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTpChainsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blockchain.thepower.v1alpha1.GetTpChainsRequest";
  }
  protected:
  explicit GetTpChainsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 1,
    kLimitFieldNumber = 2,
  };
  // int64 offset = 1 [json_name = "offset"];
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 limit = 2 [json_name = "limit"];
  void clear_limit();
  ::PROTOBUF_NAMESPACE_ID::int64 limit() const;
  void set_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_limit() const;
  void _internal_set_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:blockchain.thepower.v1alpha1.GetTpChainsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  ::PROTOBUF_NAMESPACE_ID::int64 limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UpdateTpChainRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blockchain.thepower.v1alpha1.UpdateTpChainRequest) */ {
 public:
  inline UpdateTpChainRequest() : UpdateTpChainRequest(nullptr) {}
  ~UpdateTpChainRequest() override;
  explicit constexpr UpdateTpChainRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateTpChainRequest(const UpdateTpChainRequest& from);
  UpdateTpChainRequest(UpdateTpChainRequest&& from) noexcept
    : UpdateTpChainRequest() {
    *this = ::std::move(from);
  }

  inline UpdateTpChainRequest& operator=(const UpdateTpChainRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTpChainRequest& operator=(UpdateTpChainRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTpChainRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTpChainRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateTpChainRequest*>(
               &_UpdateTpChainRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UpdateTpChainRequest& a, UpdateTpChainRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateTpChainRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTpChainRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateTpChainRequest* New() const final {
    return new UpdateTpChainRequest();
  }

  UpdateTpChainRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateTpChainRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateTpChainRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateTpChainRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateTpChainRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blockchain.thepower.v1alpha1.UpdateTpChainRequest";
  }
  protected:
  explicit UpdateTpChainRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTpChainFieldNumber = 1,
  };
  // .blockchain.thepower.v1alpha1.TpChain tp_chain = 1 [json_name = "tpChain"];
  bool has_tp_chain() const;
  private:
  bool _internal_has_tp_chain() const;
  public:
  void clear_tp_chain();
  const ::blockchain::thepower::v1alpha1::TpChain& tp_chain() const;
  PROTOBUF_MUST_USE_RESULT ::blockchain::thepower::v1alpha1::TpChain* release_tp_chain();
  ::blockchain::thepower::v1alpha1::TpChain* mutable_tp_chain();
  void set_allocated_tp_chain(::blockchain::thepower::v1alpha1::TpChain* tp_chain);
  private:
  const ::blockchain::thepower::v1alpha1::TpChain& _internal_tp_chain() const;
  ::blockchain::thepower::v1alpha1::TpChain* _internal_mutable_tp_chain();
  public:
  void unsafe_arena_set_allocated_tp_chain(
      ::blockchain::thepower::v1alpha1::TpChain* tp_chain);
  ::blockchain::thepower::v1alpha1::TpChain* unsafe_arena_release_tp_chain();

  // @@protoc_insertion_point(class_scope:blockchain.thepower.v1alpha1.UpdateTpChainRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::blockchain::thepower::v1alpha1::TpChain* tp_chain_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateTpChainResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blockchain.thepower.v1alpha1.CreateTpChainResponse) */ {
 public:
  inline CreateTpChainResponse() : CreateTpChainResponse(nullptr) {}
  ~CreateTpChainResponse() override;
  explicit constexpr CreateTpChainResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTpChainResponse(const CreateTpChainResponse& from);
  CreateTpChainResponse(CreateTpChainResponse&& from) noexcept
    : CreateTpChainResponse() {
    *this = ::std::move(from);
  }

  inline CreateTpChainResponse& operator=(const CreateTpChainResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTpChainResponse& operator=(CreateTpChainResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTpChainResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTpChainResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTpChainResponse*>(
               &_CreateTpChainResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateTpChainResponse& a, CreateTpChainResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTpChainResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTpChainResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTpChainResponse* New() const final {
    return new CreateTpChainResponse();
  }

  CreateTpChainResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTpChainResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTpChainResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateTpChainResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTpChainResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blockchain.thepower.v1alpha1.CreateTpChainResponse";
  }
  protected:
  explicit CreateTpChainResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTpChainFieldNumber = 1,
  };
  // .blockchain.thepower.v1alpha1.TpChain tp_chain = 1 [json_name = "tpChain"];
  bool has_tp_chain() const;
  private:
  bool _internal_has_tp_chain() const;
  public:
  void clear_tp_chain();
  const ::blockchain::thepower::v1alpha1::TpChain& tp_chain() const;
  PROTOBUF_MUST_USE_RESULT ::blockchain::thepower::v1alpha1::TpChain* release_tp_chain();
  ::blockchain::thepower::v1alpha1::TpChain* mutable_tp_chain();
  void set_allocated_tp_chain(::blockchain::thepower::v1alpha1::TpChain* tp_chain);
  private:
  const ::blockchain::thepower::v1alpha1::TpChain& _internal_tp_chain() const;
  ::blockchain::thepower::v1alpha1::TpChain* _internal_mutable_tp_chain();
  public:
  void unsafe_arena_set_allocated_tp_chain(
      ::blockchain::thepower::v1alpha1::TpChain* tp_chain);
  ::blockchain::thepower::v1alpha1::TpChain* unsafe_arena_release_tp_chain();

  // @@protoc_insertion_point(class_scope:blockchain.thepower.v1alpha1.CreateTpChainResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::blockchain::thepower::v1alpha1::TpChain* tp_chain_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetTpChainsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blockchain.thepower.v1alpha1.GetTpChainsResponse) */ {
 public:
  inline GetTpChainsResponse() : GetTpChainsResponse(nullptr) {}
  ~GetTpChainsResponse() override;
  explicit constexpr GetTpChainsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTpChainsResponse(const GetTpChainsResponse& from);
  GetTpChainsResponse(GetTpChainsResponse&& from) noexcept
    : GetTpChainsResponse() {
    *this = ::std::move(from);
  }

  inline GetTpChainsResponse& operator=(const GetTpChainsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTpChainsResponse& operator=(GetTpChainsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTpChainsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTpChainsResponse* internal_default_instance() {
    return reinterpret_cast<const GetTpChainsResponse*>(
               &_GetTpChainsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetTpChainsResponse& a, GetTpChainsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTpChainsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTpChainsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTpChainsResponse* New() const final {
    return new GetTpChainsResponse();
  }

  GetTpChainsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTpChainsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTpChainsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTpChainsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTpChainsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blockchain.thepower.v1alpha1.GetTpChainsResponse";
  }
  protected:
  explicit GetTpChainsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTpChainsFieldNumber = 1,
    kNextUrlFieldNumber = 3,
    kPreviousUrlFieldNumber = 4,
    kTotalFieldNumber = 2,
  };
  // repeated .blockchain.thepower.v1alpha1.TpChain tp_chains = 1 [json_name = "tpChains"];
  int tp_chains_size() const;
  private:
  int _internal_tp_chains_size() const;
  public:
  void clear_tp_chains();
  ::blockchain::thepower::v1alpha1::TpChain* mutable_tp_chains(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blockchain::thepower::v1alpha1::TpChain >*
      mutable_tp_chains();
  private:
  const ::blockchain::thepower::v1alpha1::TpChain& _internal_tp_chains(int index) const;
  ::blockchain::thepower::v1alpha1::TpChain* _internal_add_tp_chains();
  public:
  const ::blockchain::thepower::v1alpha1::TpChain& tp_chains(int index) const;
  ::blockchain::thepower::v1alpha1::TpChain* add_tp_chains();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blockchain::thepower::v1alpha1::TpChain >&
      tp_chains() const;

  // string next_url = 3 [json_name = "nextUrl"];
  void clear_next_url();
  const std::string& next_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_url();
  PROTOBUF_MUST_USE_RESULT std::string* release_next_url();
  void set_allocated_next_url(std::string* next_url);
  private:
  const std::string& _internal_next_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_url(const std::string& value);
  std::string* _internal_mutable_next_url();
  public:

  // string previous_url = 4 [json_name = "previousUrl"];
  void clear_previous_url();
  const std::string& previous_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_previous_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_previous_url();
  PROTOBUF_MUST_USE_RESULT std::string* release_previous_url();
  void set_allocated_previous_url(std::string* previous_url);
  private:
  const std::string& _internal_previous_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_previous_url(const std::string& value);
  std::string* _internal_mutable_previous_url();
  public:

  // int64 total = 2 [json_name = "total"];
  void clear_total();
  ::PROTOBUF_NAMESPACE_ID::int64 total() const;
  void set_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_total() const;
  void _internal_set_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:blockchain.thepower.v1alpha1.GetTpChainsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blockchain::thepower::v1alpha1::TpChain > tp_chains_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr previous_url_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetTpChainsByUserIdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse) */ {
 public:
  inline GetTpChainsByUserIdResponse() : GetTpChainsByUserIdResponse(nullptr) {}
  ~GetTpChainsByUserIdResponse() override;
  explicit constexpr GetTpChainsByUserIdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTpChainsByUserIdResponse(const GetTpChainsByUserIdResponse& from);
  GetTpChainsByUserIdResponse(GetTpChainsByUserIdResponse&& from) noexcept
    : GetTpChainsByUserIdResponse() {
    *this = ::std::move(from);
  }

  inline GetTpChainsByUserIdResponse& operator=(const GetTpChainsByUserIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTpChainsByUserIdResponse& operator=(GetTpChainsByUserIdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTpChainsByUserIdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTpChainsByUserIdResponse* internal_default_instance() {
    return reinterpret_cast<const GetTpChainsByUserIdResponse*>(
               &_GetTpChainsByUserIdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetTpChainsByUserIdResponse& a, GetTpChainsByUserIdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTpChainsByUserIdResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTpChainsByUserIdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTpChainsByUserIdResponse* New() const final {
    return new GetTpChainsByUserIdResponse();
  }

  GetTpChainsByUserIdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTpChainsByUserIdResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTpChainsByUserIdResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTpChainsByUserIdResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTpChainsByUserIdResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse";
  }
  protected:
  explicit GetTpChainsByUserIdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTpChainsFieldNumber = 1,
    kNextUrlFieldNumber = 3,
    kPreviousUrlFieldNumber = 4,
    kTotalFieldNumber = 2,
  };
  // repeated .blockchain.thepower.v1alpha1.TpChain tp_chains = 1 [json_name = "tpChains"];
  int tp_chains_size() const;
  private:
  int _internal_tp_chains_size() const;
  public:
  void clear_tp_chains();
  ::blockchain::thepower::v1alpha1::TpChain* mutable_tp_chains(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blockchain::thepower::v1alpha1::TpChain >*
      mutable_tp_chains();
  private:
  const ::blockchain::thepower::v1alpha1::TpChain& _internal_tp_chains(int index) const;
  ::blockchain::thepower::v1alpha1::TpChain* _internal_add_tp_chains();
  public:
  const ::blockchain::thepower::v1alpha1::TpChain& tp_chains(int index) const;
  ::blockchain::thepower::v1alpha1::TpChain* add_tp_chains();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blockchain::thepower::v1alpha1::TpChain >&
      tp_chains() const;

  // string next_url = 3 [json_name = "nextUrl"];
  void clear_next_url();
  const std::string& next_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_url();
  PROTOBUF_MUST_USE_RESULT std::string* release_next_url();
  void set_allocated_next_url(std::string* next_url);
  private:
  const std::string& _internal_next_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_url(const std::string& value);
  std::string* _internal_mutable_next_url();
  public:

  // string previous_url = 4 [json_name = "previousUrl"];
  void clear_previous_url();
  const std::string& previous_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_previous_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_previous_url();
  PROTOBUF_MUST_USE_RESULT std::string* release_previous_url();
  void set_allocated_previous_url(std::string* previous_url);
  private:
  const std::string& _internal_previous_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_previous_url(const std::string& value);
  std::string* _internal_mutable_previous_url();
  public:

  // int64 total = 2 [json_name = "total"];
  void clear_total();
  ::PROTOBUF_NAMESPACE_ID::int64 total() const;
  void set_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_total() const;
  void _internal_set_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blockchain::thepower::v1alpha1::TpChain > tp_chains_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr previous_url_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetTpChainByIdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blockchain.thepower.v1alpha1.GetTpChainByIdResponse) */ {
 public:
  inline GetTpChainByIdResponse() : GetTpChainByIdResponse(nullptr) {}
  ~GetTpChainByIdResponse() override;
  explicit constexpr GetTpChainByIdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTpChainByIdResponse(const GetTpChainByIdResponse& from);
  GetTpChainByIdResponse(GetTpChainByIdResponse&& from) noexcept
    : GetTpChainByIdResponse() {
    *this = ::std::move(from);
  }

  inline GetTpChainByIdResponse& operator=(const GetTpChainByIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTpChainByIdResponse& operator=(GetTpChainByIdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTpChainByIdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTpChainByIdResponse* internal_default_instance() {
    return reinterpret_cast<const GetTpChainByIdResponse*>(
               &_GetTpChainByIdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetTpChainByIdResponse& a, GetTpChainByIdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTpChainByIdResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTpChainByIdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTpChainByIdResponse* New() const final {
    return new GetTpChainByIdResponse();
  }

  GetTpChainByIdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTpChainByIdResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTpChainByIdResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTpChainByIdResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTpChainByIdResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blockchain.thepower.v1alpha1.GetTpChainByIdResponse";
  }
  protected:
  explicit GetTpChainByIdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTpChainFieldNumber = 1,
  };
  // .blockchain.thepower.v1alpha1.TpChain tp_chain = 1 [json_name = "tpChain"];
  bool has_tp_chain() const;
  private:
  bool _internal_has_tp_chain() const;
  public:
  void clear_tp_chain();
  const ::blockchain::thepower::v1alpha1::TpChain& tp_chain() const;
  PROTOBUF_MUST_USE_RESULT ::blockchain::thepower::v1alpha1::TpChain* release_tp_chain();
  ::blockchain::thepower::v1alpha1::TpChain* mutable_tp_chain();
  void set_allocated_tp_chain(::blockchain::thepower::v1alpha1::TpChain* tp_chain);
  private:
  const ::blockchain::thepower::v1alpha1::TpChain& _internal_tp_chain() const;
  ::blockchain::thepower::v1alpha1::TpChain* _internal_mutable_tp_chain();
  public:
  void unsafe_arena_set_allocated_tp_chain(
      ::blockchain::thepower::v1alpha1::TpChain* tp_chain);
  ::blockchain::thepower::v1alpha1::TpChain* unsafe_arena_release_tp_chain();

  // @@protoc_insertion_point(class_scope:blockchain.thepower.v1alpha1.GetTpChainByIdResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::blockchain::thepower::v1alpha1::TpChain* tp_chain_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto;
};
// -------------------------------------------------------------------

class UpdateTpChainResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blockchain.thepower.v1alpha1.UpdateTpChainResponse) */ {
 public:
  inline UpdateTpChainResponse() : UpdateTpChainResponse(nullptr) {}
  ~UpdateTpChainResponse() override;
  explicit constexpr UpdateTpChainResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateTpChainResponse(const UpdateTpChainResponse& from);
  UpdateTpChainResponse(UpdateTpChainResponse&& from) noexcept
    : UpdateTpChainResponse() {
    *this = ::std::move(from);
  }

  inline UpdateTpChainResponse& operator=(const UpdateTpChainResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTpChainResponse& operator=(UpdateTpChainResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTpChainResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTpChainResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateTpChainResponse*>(
               &_UpdateTpChainResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UpdateTpChainResponse& a, UpdateTpChainResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateTpChainResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTpChainResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateTpChainResponse* New() const final {
    return new UpdateTpChainResponse();
  }

  UpdateTpChainResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateTpChainResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateTpChainResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateTpChainResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateTpChainResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blockchain.thepower.v1alpha1.UpdateTpChainResponse";
  }
  protected:
  explicit UpdateTpChainResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTpChainFieldNumber = 1,
  };
  // .blockchain.thepower.v1alpha1.TpChain tp_chain = 1 [json_name = "tpChain"];
  bool has_tp_chain() const;
  private:
  bool _internal_has_tp_chain() const;
  public:
  void clear_tp_chain();
  const ::blockchain::thepower::v1alpha1::TpChain& tp_chain() const;
  PROTOBUF_MUST_USE_RESULT ::blockchain::thepower::v1alpha1::TpChain* release_tp_chain();
  ::blockchain::thepower::v1alpha1::TpChain* mutable_tp_chain();
  void set_allocated_tp_chain(::blockchain::thepower::v1alpha1::TpChain* tp_chain);
  private:
  const ::blockchain::thepower::v1alpha1::TpChain& _internal_tp_chain() const;
  ::blockchain::thepower::v1alpha1::TpChain* _internal_mutable_tp_chain();
  public:
  void unsafe_arena_set_allocated_tp_chain(
      ::blockchain::thepower::v1alpha1::TpChain* tp_chain);
  ::blockchain::thepower::v1alpha1::TpChain* unsafe_arena_release_tp_chain();

  // @@protoc_insertion_point(class_scope:blockchain.thepower.v1alpha1.UpdateTpChainResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::blockchain::thepower::v1alpha1::TpChain* tp_chain_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateTpChainRequest

// .blockchain.thepower.v1alpha1.TpChain tp_chain = 1 [json_name = "tpChain"];
inline bool CreateTpChainRequest::_internal_has_tp_chain() const {
  return this != internal_default_instance() && tp_chain_ != nullptr;
}
inline bool CreateTpChainRequest::has_tp_chain() const {
  return _internal_has_tp_chain();
}
inline const ::blockchain::thepower::v1alpha1::TpChain& CreateTpChainRequest::_internal_tp_chain() const {
  const ::blockchain::thepower::v1alpha1::TpChain* p = tp_chain_;
  return p != nullptr ? *p : reinterpret_cast<const ::blockchain::thepower::v1alpha1::TpChain&>(
      ::blockchain::thepower::v1alpha1::_TpChain_default_instance_);
}
inline const ::blockchain::thepower::v1alpha1::TpChain& CreateTpChainRequest::tp_chain() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.CreateTpChainRequest.tp_chain)
  return _internal_tp_chain();
}
inline void CreateTpChainRequest::unsafe_arena_set_allocated_tp_chain(
    ::blockchain::thepower::v1alpha1::TpChain* tp_chain) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tp_chain_);
  }
  tp_chain_ = tp_chain;
  if (tp_chain) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blockchain.thepower.v1alpha1.CreateTpChainRequest.tp_chain)
}
inline ::blockchain::thepower::v1alpha1::TpChain* CreateTpChainRequest::release_tp_chain() {
  
  ::blockchain::thepower::v1alpha1::TpChain* temp = tp_chain_;
  tp_chain_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::blockchain::thepower::v1alpha1::TpChain* CreateTpChainRequest::unsafe_arena_release_tp_chain() {
  // @@protoc_insertion_point(field_release:blockchain.thepower.v1alpha1.CreateTpChainRequest.tp_chain)
  
  ::blockchain::thepower::v1alpha1::TpChain* temp = tp_chain_;
  tp_chain_ = nullptr;
  return temp;
}
inline ::blockchain::thepower::v1alpha1::TpChain* CreateTpChainRequest::_internal_mutable_tp_chain() {
  
  if (tp_chain_ == nullptr) {
    auto* p = CreateMaybeMessage<::blockchain::thepower::v1alpha1::TpChain>(GetArenaForAllocation());
    tp_chain_ = p;
  }
  return tp_chain_;
}
inline ::blockchain::thepower::v1alpha1::TpChain* CreateTpChainRequest::mutable_tp_chain() {
  ::blockchain::thepower::v1alpha1::TpChain* _msg = _internal_mutable_tp_chain();
  // @@protoc_insertion_point(field_mutable:blockchain.thepower.v1alpha1.CreateTpChainRequest.tp_chain)
  return _msg;
}
inline void CreateTpChainRequest::set_allocated_tp_chain(::blockchain::thepower::v1alpha1::TpChain* tp_chain) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tp_chain_);
  }
  if (tp_chain) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tp_chain));
    if (message_arena != submessage_arena) {
      tp_chain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tp_chain, submessage_arena);
    }
    
  } else {
    
  }
  tp_chain_ = tp_chain;
  // @@protoc_insertion_point(field_set_allocated:blockchain.thepower.v1alpha1.CreateTpChainRequest.tp_chain)
}

// -------------------------------------------------------------------

// GetTpChainsByUserIdRequest

// string user_id = 1 [json_name = "userId"];
inline void GetTpChainsByUserIdRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& GetTpChainsByUserIdRequest::user_id() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.GetTpChainsByUserIdRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTpChainsByUserIdRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:blockchain.thepower.v1alpha1.GetTpChainsByUserIdRequest.user_id)
}
inline std::string* GetTpChainsByUserIdRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:blockchain.thepower.v1alpha1.GetTpChainsByUserIdRequest.user_id)
  return _s;
}
inline const std::string& GetTpChainsByUserIdRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void GetTpChainsByUserIdRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetTpChainsByUserIdRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetTpChainsByUserIdRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:blockchain.thepower.v1alpha1.GetTpChainsByUserIdRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetTpChainsByUserIdRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:blockchain.thepower.v1alpha1.GetTpChainsByUserIdRequest.user_id)
}

// int64 offset = 2 [json_name = "offset"];
inline void GetTpChainsByUserIdRequest::clear_offset() {
  offset_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTpChainsByUserIdRequest::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTpChainsByUserIdRequest::offset() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.GetTpChainsByUserIdRequest.offset)
  return _internal_offset();
}
inline void GetTpChainsByUserIdRequest::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_ = value;
}
inline void GetTpChainsByUserIdRequest::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:blockchain.thepower.v1alpha1.GetTpChainsByUserIdRequest.offset)
}

// int64 limit = 3 [json_name = "limit"];
inline void GetTpChainsByUserIdRequest::clear_limit() {
  limit_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTpChainsByUserIdRequest::_internal_limit() const {
  return limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTpChainsByUserIdRequest::limit() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.GetTpChainsByUserIdRequest.limit)
  return _internal_limit();
}
inline void GetTpChainsByUserIdRequest::_internal_set_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  limit_ = value;
}
inline void GetTpChainsByUserIdRequest::set_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:blockchain.thepower.v1alpha1.GetTpChainsByUserIdRequest.limit)
}

// -------------------------------------------------------------------

// GetTpChainByIdRequest

// string id = 1 [json_name = "id"];
inline void GetTpChainByIdRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetTpChainByIdRequest::id() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.GetTpChainByIdRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTpChainByIdRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:blockchain.thepower.v1alpha1.GetTpChainByIdRequest.id)
}
inline std::string* GetTpChainByIdRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:blockchain.thepower.v1alpha1.GetTpChainByIdRequest.id)
  return _s;
}
inline const std::string& GetTpChainByIdRequest::_internal_id() const {
  return id_.Get();
}
inline void GetTpChainByIdRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetTpChainByIdRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetTpChainByIdRequest::release_id() {
  // @@protoc_insertion_point(field_release:blockchain.thepower.v1alpha1.GetTpChainByIdRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetTpChainByIdRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:blockchain.thepower.v1alpha1.GetTpChainByIdRequest.id)
}

// -------------------------------------------------------------------

// GetTpChainsRequest

// int64 offset = 1 [json_name = "offset"];
inline void GetTpChainsRequest::clear_offset() {
  offset_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTpChainsRequest::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTpChainsRequest::offset() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.GetTpChainsRequest.offset)
  return _internal_offset();
}
inline void GetTpChainsRequest::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_ = value;
}
inline void GetTpChainsRequest::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:blockchain.thepower.v1alpha1.GetTpChainsRequest.offset)
}

// int64 limit = 2 [json_name = "limit"];
inline void GetTpChainsRequest::clear_limit() {
  limit_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTpChainsRequest::_internal_limit() const {
  return limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTpChainsRequest::limit() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.GetTpChainsRequest.limit)
  return _internal_limit();
}
inline void GetTpChainsRequest::_internal_set_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  limit_ = value;
}
inline void GetTpChainsRequest::set_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:blockchain.thepower.v1alpha1.GetTpChainsRequest.limit)
}

// -------------------------------------------------------------------

// UpdateTpChainRequest

// .blockchain.thepower.v1alpha1.TpChain tp_chain = 1 [json_name = "tpChain"];
inline bool UpdateTpChainRequest::_internal_has_tp_chain() const {
  return this != internal_default_instance() && tp_chain_ != nullptr;
}
inline bool UpdateTpChainRequest::has_tp_chain() const {
  return _internal_has_tp_chain();
}
inline const ::blockchain::thepower::v1alpha1::TpChain& UpdateTpChainRequest::_internal_tp_chain() const {
  const ::blockchain::thepower::v1alpha1::TpChain* p = tp_chain_;
  return p != nullptr ? *p : reinterpret_cast<const ::blockchain::thepower::v1alpha1::TpChain&>(
      ::blockchain::thepower::v1alpha1::_TpChain_default_instance_);
}
inline const ::blockchain::thepower::v1alpha1::TpChain& UpdateTpChainRequest::tp_chain() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.UpdateTpChainRequest.tp_chain)
  return _internal_tp_chain();
}
inline void UpdateTpChainRequest::unsafe_arena_set_allocated_tp_chain(
    ::blockchain::thepower::v1alpha1::TpChain* tp_chain) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tp_chain_);
  }
  tp_chain_ = tp_chain;
  if (tp_chain) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blockchain.thepower.v1alpha1.UpdateTpChainRequest.tp_chain)
}
inline ::blockchain::thepower::v1alpha1::TpChain* UpdateTpChainRequest::release_tp_chain() {
  
  ::blockchain::thepower::v1alpha1::TpChain* temp = tp_chain_;
  tp_chain_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::blockchain::thepower::v1alpha1::TpChain* UpdateTpChainRequest::unsafe_arena_release_tp_chain() {
  // @@protoc_insertion_point(field_release:blockchain.thepower.v1alpha1.UpdateTpChainRequest.tp_chain)
  
  ::blockchain::thepower::v1alpha1::TpChain* temp = tp_chain_;
  tp_chain_ = nullptr;
  return temp;
}
inline ::blockchain::thepower::v1alpha1::TpChain* UpdateTpChainRequest::_internal_mutable_tp_chain() {
  
  if (tp_chain_ == nullptr) {
    auto* p = CreateMaybeMessage<::blockchain::thepower::v1alpha1::TpChain>(GetArenaForAllocation());
    tp_chain_ = p;
  }
  return tp_chain_;
}
inline ::blockchain::thepower::v1alpha1::TpChain* UpdateTpChainRequest::mutable_tp_chain() {
  ::blockchain::thepower::v1alpha1::TpChain* _msg = _internal_mutable_tp_chain();
  // @@protoc_insertion_point(field_mutable:blockchain.thepower.v1alpha1.UpdateTpChainRequest.tp_chain)
  return _msg;
}
inline void UpdateTpChainRequest::set_allocated_tp_chain(::blockchain::thepower::v1alpha1::TpChain* tp_chain) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tp_chain_);
  }
  if (tp_chain) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tp_chain));
    if (message_arena != submessage_arena) {
      tp_chain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tp_chain, submessage_arena);
    }
    
  } else {
    
  }
  tp_chain_ = tp_chain;
  // @@protoc_insertion_point(field_set_allocated:blockchain.thepower.v1alpha1.UpdateTpChainRequest.tp_chain)
}

// -------------------------------------------------------------------

// CreateTpChainResponse

// .blockchain.thepower.v1alpha1.TpChain tp_chain = 1 [json_name = "tpChain"];
inline bool CreateTpChainResponse::_internal_has_tp_chain() const {
  return this != internal_default_instance() && tp_chain_ != nullptr;
}
inline bool CreateTpChainResponse::has_tp_chain() const {
  return _internal_has_tp_chain();
}
inline const ::blockchain::thepower::v1alpha1::TpChain& CreateTpChainResponse::_internal_tp_chain() const {
  const ::blockchain::thepower::v1alpha1::TpChain* p = tp_chain_;
  return p != nullptr ? *p : reinterpret_cast<const ::blockchain::thepower::v1alpha1::TpChain&>(
      ::blockchain::thepower::v1alpha1::_TpChain_default_instance_);
}
inline const ::blockchain::thepower::v1alpha1::TpChain& CreateTpChainResponse::tp_chain() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.CreateTpChainResponse.tp_chain)
  return _internal_tp_chain();
}
inline void CreateTpChainResponse::unsafe_arena_set_allocated_tp_chain(
    ::blockchain::thepower::v1alpha1::TpChain* tp_chain) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tp_chain_);
  }
  tp_chain_ = tp_chain;
  if (tp_chain) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blockchain.thepower.v1alpha1.CreateTpChainResponse.tp_chain)
}
inline ::blockchain::thepower::v1alpha1::TpChain* CreateTpChainResponse::release_tp_chain() {
  
  ::blockchain::thepower::v1alpha1::TpChain* temp = tp_chain_;
  tp_chain_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::blockchain::thepower::v1alpha1::TpChain* CreateTpChainResponse::unsafe_arena_release_tp_chain() {
  // @@protoc_insertion_point(field_release:blockchain.thepower.v1alpha1.CreateTpChainResponse.tp_chain)
  
  ::blockchain::thepower::v1alpha1::TpChain* temp = tp_chain_;
  tp_chain_ = nullptr;
  return temp;
}
inline ::blockchain::thepower::v1alpha1::TpChain* CreateTpChainResponse::_internal_mutable_tp_chain() {
  
  if (tp_chain_ == nullptr) {
    auto* p = CreateMaybeMessage<::blockchain::thepower::v1alpha1::TpChain>(GetArenaForAllocation());
    tp_chain_ = p;
  }
  return tp_chain_;
}
inline ::blockchain::thepower::v1alpha1::TpChain* CreateTpChainResponse::mutable_tp_chain() {
  ::blockchain::thepower::v1alpha1::TpChain* _msg = _internal_mutable_tp_chain();
  // @@protoc_insertion_point(field_mutable:blockchain.thepower.v1alpha1.CreateTpChainResponse.tp_chain)
  return _msg;
}
inline void CreateTpChainResponse::set_allocated_tp_chain(::blockchain::thepower::v1alpha1::TpChain* tp_chain) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tp_chain_);
  }
  if (tp_chain) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tp_chain));
    if (message_arena != submessage_arena) {
      tp_chain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tp_chain, submessage_arena);
    }
    
  } else {
    
  }
  tp_chain_ = tp_chain;
  // @@protoc_insertion_point(field_set_allocated:blockchain.thepower.v1alpha1.CreateTpChainResponse.tp_chain)
}

// -------------------------------------------------------------------

// GetTpChainsResponse

// repeated .blockchain.thepower.v1alpha1.TpChain tp_chains = 1 [json_name = "tpChains"];
inline int GetTpChainsResponse::_internal_tp_chains_size() const {
  return tp_chains_.size();
}
inline int GetTpChainsResponse::tp_chains_size() const {
  return _internal_tp_chains_size();
}
inline ::blockchain::thepower::v1alpha1::TpChain* GetTpChainsResponse::mutable_tp_chains(int index) {
  // @@protoc_insertion_point(field_mutable:blockchain.thepower.v1alpha1.GetTpChainsResponse.tp_chains)
  return tp_chains_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blockchain::thepower::v1alpha1::TpChain >*
GetTpChainsResponse::mutable_tp_chains() {
  // @@protoc_insertion_point(field_mutable_list:blockchain.thepower.v1alpha1.GetTpChainsResponse.tp_chains)
  return &tp_chains_;
}
inline const ::blockchain::thepower::v1alpha1::TpChain& GetTpChainsResponse::_internal_tp_chains(int index) const {
  return tp_chains_.Get(index);
}
inline const ::blockchain::thepower::v1alpha1::TpChain& GetTpChainsResponse::tp_chains(int index) const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.GetTpChainsResponse.tp_chains)
  return _internal_tp_chains(index);
}
inline ::blockchain::thepower::v1alpha1::TpChain* GetTpChainsResponse::_internal_add_tp_chains() {
  return tp_chains_.Add();
}
inline ::blockchain::thepower::v1alpha1::TpChain* GetTpChainsResponse::add_tp_chains() {
  ::blockchain::thepower::v1alpha1::TpChain* _add = _internal_add_tp_chains();
  // @@protoc_insertion_point(field_add:blockchain.thepower.v1alpha1.GetTpChainsResponse.tp_chains)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blockchain::thepower::v1alpha1::TpChain >&
GetTpChainsResponse::tp_chains() const {
  // @@protoc_insertion_point(field_list:blockchain.thepower.v1alpha1.GetTpChainsResponse.tp_chains)
  return tp_chains_;
}

// int64 total = 2 [json_name = "total"];
inline void GetTpChainsResponse::clear_total() {
  total_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTpChainsResponse::_internal_total() const {
  return total_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTpChainsResponse::total() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.GetTpChainsResponse.total)
  return _internal_total();
}
inline void GetTpChainsResponse::_internal_set_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  total_ = value;
}
inline void GetTpChainsResponse::set_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:blockchain.thepower.v1alpha1.GetTpChainsResponse.total)
}

// string next_url = 3 [json_name = "nextUrl"];
inline void GetTpChainsResponse::clear_next_url() {
  next_url_.ClearToEmpty();
}
inline const std::string& GetTpChainsResponse::next_url() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.GetTpChainsResponse.next_url)
  return _internal_next_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTpChainsResponse::set_next_url(ArgT0&& arg0, ArgT... args) {
 
 next_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:blockchain.thepower.v1alpha1.GetTpChainsResponse.next_url)
}
inline std::string* GetTpChainsResponse::mutable_next_url() {
  std::string* _s = _internal_mutable_next_url();
  // @@protoc_insertion_point(field_mutable:blockchain.thepower.v1alpha1.GetTpChainsResponse.next_url)
  return _s;
}
inline const std::string& GetTpChainsResponse::_internal_next_url() const {
  return next_url_.Get();
}
inline void GetTpChainsResponse::_internal_set_next_url(const std::string& value) {
  
  next_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetTpChainsResponse::_internal_mutable_next_url() {
  
  return next_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetTpChainsResponse::release_next_url() {
  // @@protoc_insertion_point(field_release:blockchain.thepower.v1alpha1.GetTpChainsResponse.next_url)
  return next_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetTpChainsResponse::set_allocated_next_url(std::string* next_url) {
  if (next_url != nullptr) {
    
  } else {
    
  }
  next_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_url,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:blockchain.thepower.v1alpha1.GetTpChainsResponse.next_url)
}

// string previous_url = 4 [json_name = "previousUrl"];
inline void GetTpChainsResponse::clear_previous_url() {
  previous_url_.ClearToEmpty();
}
inline const std::string& GetTpChainsResponse::previous_url() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.GetTpChainsResponse.previous_url)
  return _internal_previous_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTpChainsResponse::set_previous_url(ArgT0&& arg0, ArgT... args) {
 
 previous_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:blockchain.thepower.v1alpha1.GetTpChainsResponse.previous_url)
}
inline std::string* GetTpChainsResponse::mutable_previous_url() {
  std::string* _s = _internal_mutable_previous_url();
  // @@protoc_insertion_point(field_mutable:blockchain.thepower.v1alpha1.GetTpChainsResponse.previous_url)
  return _s;
}
inline const std::string& GetTpChainsResponse::_internal_previous_url() const {
  return previous_url_.Get();
}
inline void GetTpChainsResponse::_internal_set_previous_url(const std::string& value) {
  
  previous_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetTpChainsResponse::_internal_mutable_previous_url() {
  
  return previous_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetTpChainsResponse::release_previous_url() {
  // @@protoc_insertion_point(field_release:blockchain.thepower.v1alpha1.GetTpChainsResponse.previous_url)
  return previous_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetTpChainsResponse::set_allocated_previous_url(std::string* previous_url) {
  if (previous_url != nullptr) {
    
  } else {
    
  }
  previous_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), previous_url,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:blockchain.thepower.v1alpha1.GetTpChainsResponse.previous_url)
}

// -------------------------------------------------------------------

// GetTpChainsByUserIdResponse

// repeated .blockchain.thepower.v1alpha1.TpChain tp_chains = 1 [json_name = "tpChains"];
inline int GetTpChainsByUserIdResponse::_internal_tp_chains_size() const {
  return tp_chains_.size();
}
inline int GetTpChainsByUserIdResponse::tp_chains_size() const {
  return _internal_tp_chains_size();
}
inline ::blockchain::thepower::v1alpha1::TpChain* GetTpChainsByUserIdResponse::mutable_tp_chains(int index) {
  // @@protoc_insertion_point(field_mutable:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.tp_chains)
  return tp_chains_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blockchain::thepower::v1alpha1::TpChain >*
GetTpChainsByUserIdResponse::mutable_tp_chains() {
  // @@protoc_insertion_point(field_mutable_list:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.tp_chains)
  return &tp_chains_;
}
inline const ::blockchain::thepower::v1alpha1::TpChain& GetTpChainsByUserIdResponse::_internal_tp_chains(int index) const {
  return tp_chains_.Get(index);
}
inline const ::blockchain::thepower::v1alpha1::TpChain& GetTpChainsByUserIdResponse::tp_chains(int index) const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.tp_chains)
  return _internal_tp_chains(index);
}
inline ::blockchain::thepower::v1alpha1::TpChain* GetTpChainsByUserIdResponse::_internal_add_tp_chains() {
  return tp_chains_.Add();
}
inline ::blockchain::thepower::v1alpha1::TpChain* GetTpChainsByUserIdResponse::add_tp_chains() {
  ::blockchain::thepower::v1alpha1::TpChain* _add = _internal_add_tp_chains();
  // @@protoc_insertion_point(field_add:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.tp_chains)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blockchain::thepower::v1alpha1::TpChain >&
GetTpChainsByUserIdResponse::tp_chains() const {
  // @@protoc_insertion_point(field_list:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.tp_chains)
  return tp_chains_;
}

// int64 total = 2 [json_name = "total"];
inline void GetTpChainsByUserIdResponse::clear_total() {
  total_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTpChainsByUserIdResponse::_internal_total() const {
  return total_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetTpChainsByUserIdResponse::total() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.total)
  return _internal_total();
}
inline void GetTpChainsByUserIdResponse::_internal_set_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  total_ = value;
}
inline void GetTpChainsByUserIdResponse::set_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.total)
}

// string next_url = 3 [json_name = "nextUrl"];
inline void GetTpChainsByUserIdResponse::clear_next_url() {
  next_url_.ClearToEmpty();
}
inline const std::string& GetTpChainsByUserIdResponse::next_url() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.next_url)
  return _internal_next_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTpChainsByUserIdResponse::set_next_url(ArgT0&& arg0, ArgT... args) {
 
 next_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.next_url)
}
inline std::string* GetTpChainsByUserIdResponse::mutable_next_url() {
  std::string* _s = _internal_mutable_next_url();
  // @@protoc_insertion_point(field_mutable:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.next_url)
  return _s;
}
inline const std::string& GetTpChainsByUserIdResponse::_internal_next_url() const {
  return next_url_.Get();
}
inline void GetTpChainsByUserIdResponse::_internal_set_next_url(const std::string& value) {
  
  next_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetTpChainsByUserIdResponse::_internal_mutable_next_url() {
  
  return next_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetTpChainsByUserIdResponse::release_next_url() {
  // @@protoc_insertion_point(field_release:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.next_url)
  return next_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetTpChainsByUserIdResponse::set_allocated_next_url(std::string* next_url) {
  if (next_url != nullptr) {
    
  } else {
    
  }
  next_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_url,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.next_url)
}

// string previous_url = 4 [json_name = "previousUrl"];
inline void GetTpChainsByUserIdResponse::clear_previous_url() {
  previous_url_.ClearToEmpty();
}
inline const std::string& GetTpChainsByUserIdResponse::previous_url() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.previous_url)
  return _internal_previous_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTpChainsByUserIdResponse::set_previous_url(ArgT0&& arg0, ArgT... args) {
 
 previous_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.previous_url)
}
inline std::string* GetTpChainsByUserIdResponse::mutable_previous_url() {
  std::string* _s = _internal_mutable_previous_url();
  // @@protoc_insertion_point(field_mutable:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.previous_url)
  return _s;
}
inline const std::string& GetTpChainsByUserIdResponse::_internal_previous_url() const {
  return previous_url_.Get();
}
inline void GetTpChainsByUserIdResponse::_internal_set_previous_url(const std::string& value) {
  
  previous_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetTpChainsByUserIdResponse::_internal_mutable_previous_url() {
  
  return previous_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetTpChainsByUserIdResponse::release_previous_url() {
  // @@protoc_insertion_point(field_release:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.previous_url)
  return previous_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetTpChainsByUserIdResponse::set_allocated_previous_url(std::string* previous_url) {
  if (previous_url != nullptr) {
    
  } else {
    
  }
  previous_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), previous_url,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:blockchain.thepower.v1alpha1.GetTpChainsByUserIdResponse.previous_url)
}

// -------------------------------------------------------------------

// GetTpChainByIdResponse

// .blockchain.thepower.v1alpha1.TpChain tp_chain = 1 [json_name = "tpChain"];
inline bool GetTpChainByIdResponse::_internal_has_tp_chain() const {
  return this != internal_default_instance() && tp_chain_ != nullptr;
}
inline bool GetTpChainByIdResponse::has_tp_chain() const {
  return _internal_has_tp_chain();
}
inline const ::blockchain::thepower::v1alpha1::TpChain& GetTpChainByIdResponse::_internal_tp_chain() const {
  const ::blockchain::thepower::v1alpha1::TpChain* p = tp_chain_;
  return p != nullptr ? *p : reinterpret_cast<const ::blockchain::thepower::v1alpha1::TpChain&>(
      ::blockchain::thepower::v1alpha1::_TpChain_default_instance_);
}
inline const ::blockchain::thepower::v1alpha1::TpChain& GetTpChainByIdResponse::tp_chain() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.GetTpChainByIdResponse.tp_chain)
  return _internal_tp_chain();
}
inline void GetTpChainByIdResponse::unsafe_arena_set_allocated_tp_chain(
    ::blockchain::thepower::v1alpha1::TpChain* tp_chain) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tp_chain_);
  }
  tp_chain_ = tp_chain;
  if (tp_chain) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blockchain.thepower.v1alpha1.GetTpChainByIdResponse.tp_chain)
}
inline ::blockchain::thepower::v1alpha1::TpChain* GetTpChainByIdResponse::release_tp_chain() {
  
  ::blockchain::thepower::v1alpha1::TpChain* temp = tp_chain_;
  tp_chain_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::blockchain::thepower::v1alpha1::TpChain* GetTpChainByIdResponse::unsafe_arena_release_tp_chain() {
  // @@protoc_insertion_point(field_release:blockchain.thepower.v1alpha1.GetTpChainByIdResponse.tp_chain)
  
  ::blockchain::thepower::v1alpha1::TpChain* temp = tp_chain_;
  tp_chain_ = nullptr;
  return temp;
}
inline ::blockchain::thepower::v1alpha1::TpChain* GetTpChainByIdResponse::_internal_mutable_tp_chain() {
  
  if (tp_chain_ == nullptr) {
    auto* p = CreateMaybeMessage<::blockchain::thepower::v1alpha1::TpChain>(GetArenaForAllocation());
    tp_chain_ = p;
  }
  return tp_chain_;
}
inline ::blockchain::thepower::v1alpha1::TpChain* GetTpChainByIdResponse::mutable_tp_chain() {
  ::blockchain::thepower::v1alpha1::TpChain* _msg = _internal_mutable_tp_chain();
  // @@protoc_insertion_point(field_mutable:blockchain.thepower.v1alpha1.GetTpChainByIdResponse.tp_chain)
  return _msg;
}
inline void GetTpChainByIdResponse::set_allocated_tp_chain(::blockchain::thepower::v1alpha1::TpChain* tp_chain) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tp_chain_);
  }
  if (tp_chain) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tp_chain));
    if (message_arena != submessage_arena) {
      tp_chain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tp_chain, submessage_arena);
    }
    
  } else {
    
  }
  tp_chain_ = tp_chain;
  // @@protoc_insertion_point(field_set_allocated:blockchain.thepower.v1alpha1.GetTpChainByIdResponse.tp_chain)
}

// -------------------------------------------------------------------

// UpdateTpChainResponse

// .blockchain.thepower.v1alpha1.TpChain tp_chain = 1 [json_name = "tpChain"];
inline bool UpdateTpChainResponse::_internal_has_tp_chain() const {
  return this != internal_default_instance() && tp_chain_ != nullptr;
}
inline bool UpdateTpChainResponse::has_tp_chain() const {
  return _internal_has_tp_chain();
}
inline const ::blockchain::thepower::v1alpha1::TpChain& UpdateTpChainResponse::_internal_tp_chain() const {
  const ::blockchain::thepower::v1alpha1::TpChain* p = tp_chain_;
  return p != nullptr ? *p : reinterpret_cast<const ::blockchain::thepower::v1alpha1::TpChain&>(
      ::blockchain::thepower::v1alpha1::_TpChain_default_instance_);
}
inline const ::blockchain::thepower::v1alpha1::TpChain& UpdateTpChainResponse::tp_chain() const {
  // @@protoc_insertion_point(field_get:blockchain.thepower.v1alpha1.UpdateTpChainResponse.tp_chain)
  return _internal_tp_chain();
}
inline void UpdateTpChainResponse::unsafe_arena_set_allocated_tp_chain(
    ::blockchain::thepower::v1alpha1::TpChain* tp_chain) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tp_chain_);
  }
  tp_chain_ = tp_chain;
  if (tp_chain) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blockchain.thepower.v1alpha1.UpdateTpChainResponse.tp_chain)
}
inline ::blockchain::thepower::v1alpha1::TpChain* UpdateTpChainResponse::release_tp_chain() {
  
  ::blockchain::thepower::v1alpha1::TpChain* temp = tp_chain_;
  tp_chain_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::blockchain::thepower::v1alpha1::TpChain* UpdateTpChainResponse::unsafe_arena_release_tp_chain() {
  // @@protoc_insertion_point(field_release:blockchain.thepower.v1alpha1.UpdateTpChainResponse.tp_chain)
  
  ::blockchain::thepower::v1alpha1::TpChain* temp = tp_chain_;
  tp_chain_ = nullptr;
  return temp;
}
inline ::blockchain::thepower::v1alpha1::TpChain* UpdateTpChainResponse::_internal_mutable_tp_chain() {
  
  if (tp_chain_ == nullptr) {
    auto* p = CreateMaybeMessage<::blockchain::thepower::v1alpha1::TpChain>(GetArenaForAllocation());
    tp_chain_ = p;
  }
  return tp_chain_;
}
inline ::blockchain::thepower::v1alpha1::TpChain* UpdateTpChainResponse::mutable_tp_chain() {
  ::blockchain::thepower::v1alpha1::TpChain* _msg = _internal_mutable_tp_chain();
  // @@protoc_insertion_point(field_mutable:blockchain.thepower.v1alpha1.UpdateTpChainResponse.tp_chain)
  return _msg;
}
inline void UpdateTpChainResponse::set_allocated_tp_chain(::blockchain::thepower::v1alpha1::TpChain* tp_chain) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tp_chain_);
  }
  if (tp_chain) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tp_chain));
    if (message_arena != submessage_arena) {
      tp_chain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tp_chain, submessage_arena);
    }
    
  } else {
    
  }
  tp_chain_ = tp_chain;
  // @@protoc_insertion_point(field_set_allocated:blockchain.thepower.v1alpha1.UpdateTpChainResponse.tp_chain)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace thepower
}  // namespace blockchain

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_blockchain_2fthepower_2fv1alpha1_2fthepower_5fapi_2eproto
