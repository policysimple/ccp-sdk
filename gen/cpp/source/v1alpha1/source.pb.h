// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: source/v1alpha1/source.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_source_2fv1alpha1_2fsource_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_source_2fv1alpha1_2fsource_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_source_2fv1alpha1_2fsource_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_source_2fv1alpha1_2fsource_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[57]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_source_2fv1alpha1_2fsource_2eproto;
namespace source {
namespace v1alpha1 {
class AccountIntegration;
struct AccountIntegrationDefaultTypeInternal;
extern AccountIntegrationDefaultTypeInternal _AccountIntegration_default_instance_;
class AccountProvider;
struct AccountProviderDefaultTypeInternal;
extern AccountProviderDefaultTypeInternal _AccountProvider_default_instance_;
class AccountsProvidersRequest;
struct AccountsProvidersRequestDefaultTypeInternal;
extern AccountsProvidersRequestDefaultTypeInternal _AccountsProvidersRequest_default_instance_;
class AccountsProvidersResponse;
struct AccountsProvidersResponseDefaultTypeInternal;
extern AccountsProvidersResponseDefaultTypeInternal _AccountsProvidersResponse_default_instance_;
class Branch;
struct BranchDefaultTypeInternal;
extern BranchDefaultTypeInternal _Branch_default_instance_;
class CreateDetailRepository;
struct CreateDetailRepositoryDefaultTypeInternal;
extern CreateDetailRepositoryDefaultTypeInternal _CreateDetailRepository_default_instance_;
class CreateIntegrationRequest;
struct CreateIntegrationRequestDefaultTypeInternal;
extern CreateIntegrationRequestDefaultTypeInternal _CreateIntegrationRequest_default_instance_;
class CreateIntegrationRequest_DataEntry_DoNotUse;
struct CreateIntegrationRequest_DataEntry_DoNotUseDefaultTypeInternal;
extern CreateIntegrationRequest_DataEntry_DoNotUseDefaultTypeInternal _CreateIntegrationRequest_DataEntry_DoNotUse_default_instance_;
class CreateIntegrationRequest_MetadataEntry_DoNotUse;
struct CreateIntegrationRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern CreateIntegrationRequest_MetadataEntry_DoNotUseDefaultTypeInternal _CreateIntegrationRequest_MetadataEntry_DoNotUse_default_instance_;
class CreateIntegrationResponse;
struct CreateIntegrationResponseDefaultTypeInternal;
extern CreateIntegrationResponseDefaultTypeInternal _CreateIntegrationResponse_default_instance_;
class CreateProviderRequest;
struct CreateProviderRequestDefaultTypeInternal;
extern CreateProviderRequestDefaultTypeInternal _CreateProviderRequest_default_instance_;
class CreateProviderRequest_DataEntry_DoNotUse;
struct CreateProviderRequest_DataEntry_DoNotUseDefaultTypeInternal;
extern CreateProviderRequest_DataEntry_DoNotUseDefaultTypeInternal _CreateProviderRequest_DataEntry_DoNotUse_default_instance_;
class CreateProviderRequest_MetadataEntry_DoNotUse;
struct CreateProviderRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern CreateProviderRequest_MetadataEntry_DoNotUseDefaultTypeInternal _CreateProviderRequest_MetadataEntry_DoNotUse_default_instance_;
class CreateProviderResponse;
struct CreateProviderResponseDefaultTypeInternal;
extern CreateProviderResponseDefaultTypeInternal _CreateProviderResponse_default_instance_;
class CreateRepositoryRequest;
struct CreateRepositoryRequestDefaultTypeInternal;
extern CreateRepositoryRequestDefaultTypeInternal _CreateRepositoryRequest_default_instance_;
class CreateRepositoryResponse;
struct CreateRepositoryResponseDefaultTypeInternal;
extern CreateRepositoryResponseDefaultTypeInternal _CreateRepositoryResponse_default_instance_;
class DeleteIntegrationRequest;
struct DeleteIntegrationRequestDefaultTypeInternal;
extern DeleteIntegrationRequestDefaultTypeInternal _DeleteIntegrationRequest_default_instance_;
class DeleteIntegrationResponse;
struct DeleteIntegrationResponseDefaultTypeInternal;
extern DeleteIntegrationResponseDefaultTypeInternal _DeleteIntegrationResponse_default_instance_;
class DeleteIntegrationsByOrganizationRequest;
struct DeleteIntegrationsByOrganizationRequestDefaultTypeInternal;
extern DeleteIntegrationsByOrganizationRequestDefaultTypeInternal _DeleteIntegrationsByOrganizationRequest_default_instance_;
class DeleteIntegrationsByOrganizationResponse;
struct DeleteIntegrationsByOrganizationResponseDefaultTypeInternal;
extern DeleteIntegrationsByOrganizationResponseDefaultTypeInternal _DeleteIntegrationsByOrganizationResponse_default_instance_;
class DeleteProviderRequest;
struct DeleteProviderRequestDefaultTypeInternal;
extern DeleteProviderRequestDefaultTypeInternal _DeleteProviderRequest_default_instance_;
class DeleteProviderResponse;
struct DeleteProviderResponseDefaultTypeInternal;
extern DeleteProviderResponseDefaultTypeInternal _DeleteProviderResponse_default_instance_;
class DeleteRepositoryRequest;
struct DeleteRepositoryRequestDefaultTypeInternal;
extern DeleteRepositoryRequestDefaultTypeInternal _DeleteRepositoryRequest_default_instance_;
class DeleteRepositoryResponse;
struct DeleteRepositoryResponseDefaultTypeInternal;
extern DeleteRepositoryResponseDefaultTypeInternal _DeleteRepositoryResponse_default_instance_;
class DetailRepository;
struct DetailRepositoryDefaultTypeInternal;
extern DetailRepositoryDefaultTypeInternal _DetailRepository_default_instance_;
class GetIntegrationRequest;
struct GetIntegrationRequestDefaultTypeInternal;
extern GetIntegrationRequestDefaultTypeInternal _GetIntegrationRequest_default_instance_;
class GetIntegrationResponse;
struct GetIntegrationResponseDefaultTypeInternal;
extern GetIntegrationResponseDefaultTypeInternal _GetIntegrationResponse_default_instance_;
class GetOneProviderByNameRequest;
struct GetOneProviderByNameRequestDefaultTypeInternal;
extern GetOneProviderByNameRequestDefaultTypeInternal _GetOneProviderByNameRequest_default_instance_;
class GetOneProviderByNameResponse;
struct GetOneProviderByNameResponseDefaultTypeInternal;
extern GetOneProviderByNameResponseDefaultTypeInternal _GetOneProviderByNameResponse_default_instance_;
class GetProviderRequest;
struct GetProviderRequestDefaultTypeInternal;
extern GetProviderRequestDefaultTypeInternal _GetProviderRequest_default_instance_;
class GetProviderResponse;
struct GetProviderResponseDefaultTypeInternal;
extern GetProviderResponseDefaultTypeInternal _GetProviderResponse_default_instance_;
class GetRepositoryProviderRequest;
struct GetRepositoryProviderRequestDefaultTypeInternal;
extern GetRepositoryProviderRequestDefaultTypeInternal _GetRepositoryProviderRequest_default_instance_;
class GetRepositoryProviderResponse;
struct GetRepositoryProviderResponseDefaultTypeInternal;
extern GetRepositoryProviderResponseDefaultTypeInternal _GetRepositoryProviderResponse_default_instance_;
class GetRepositoryRequest;
struct GetRepositoryRequestDefaultTypeInternal;
extern GetRepositoryRequestDefaultTypeInternal _GetRepositoryRequest_default_instance_;
class GetRepositoryResponse;
struct GetRepositoryResponseDefaultTypeInternal;
extern GetRepositoryResponseDefaultTypeInternal _GetRepositoryResponse_default_instance_;
class Integration;
struct IntegrationDefaultTypeInternal;
extern IntegrationDefaultTypeInternal _Integration_default_instance_;
class Integration_DataEntry_DoNotUse;
struct Integration_DataEntry_DoNotUseDefaultTypeInternal;
extern Integration_DataEntry_DoNotUseDefaultTypeInternal _Integration_DataEntry_DoNotUse_default_instance_;
class Integration_MetadataEntry_DoNotUse;
struct Integration_MetadataEntry_DoNotUseDefaultTypeInternal;
extern Integration_MetadataEntry_DoNotUseDefaultTypeInternal _Integration_MetadataEntry_DoNotUse_default_instance_;
class ListIntegrationsRequest;
struct ListIntegrationsRequestDefaultTypeInternal;
extern ListIntegrationsRequestDefaultTypeInternal _ListIntegrationsRequest_default_instance_;
class ListIntegrationsResponse;
struct ListIntegrationsResponseDefaultTypeInternal;
extern ListIntegrationsResponseDefaultTypeInternal _ListIntegrationsResponse_default_instance_;
class ListProvidersRequest;
struct ListProvidersRequestDefaultTypeInternal;
extern ListProvidersRequestDefaultTypeInternal _ListProvidersRequest_default_instance_;
class ListProvidersResponse;
struct ListProvidersResponseDefaultTypeInternal;
extern ListProvidersResponseDefaultTypeInternal _ListProvidersResponse_default_instance_;
class ListRepositoriesProviderRequest;
struct ListRepositoriesProviderRequestDefaultTypeInternal;
extern ListRepositoriesProviderRequestDefaultTypeInternal _ListRepositoriesProviderRequest_default_instance_;
class ListRepositoriesProviderResponse;
struct ListRepositoriesProviderResponseDefaultTypeInternal;
extern ListRepositoriesProviderResponseDefaultTypeInternal _ListRepositoriesProviderResponse_default_instance_;
class ListRepositoriesRequest;
struct ListRepositoriesRequestDefaultTypeInternal;
extern ListRepositoriesRequestDefaultTypeInternal _ListRepositoriesRequest_default_instance_;
class ListRepositoriesResponse;
struct ListRepositoriesResponseDefaultTypeInternal;
extern ListRepositoriesResponseDefaultTypeInternal _ListRepositoriesResponse_default_instance_;
class ListRepository;
struct ListRepositoryDefaultTypeInternal;
extern ListRepositoryDefaultTypeInternal _ListRepository_default_instance_;
class Provider;
struct ProviderDefaultTypeInternal;
extern ProviderDefaultTypeInternal _Provider_default_instance_;
class Provider_DataEntry_DoNotUse;
struct Provider_DataEntry_DoNotUseDefaultTypeInternal;
extern Provider_DataEntry_DoNotUseDefaultTypeInternal _Provider_DataEntry_DoNotUse_default_instance_;
class Provider_MetadataEntry_DoNotUse;
struct Provider_MetadataEntry_DoNotUseDefaultTypeInternal;
extern Provider_MetadataEntry_DoNotUseDefaultTypeInternal _Provider_MetadataEntry_DoNotUse_default_instance_;
class Repository;
struct RepositoryDefaultTypeInternal;
extern RepositoryDefaultTypeInternal _Repository_default_instance_;
class UpdateIntegrationRequest;
struct UpdateIntegrationRequestDefaultTypeInternal;
extern UpdateIntegrationRequestDefaultTypeInternal _UpdateIntegrationRequest_default_instance_;
class UpdateIntegrationResponse;
struct UpdateIntegrationResponseDefaultTypeInternal;
extern UpdateIntegrationResponseDefaultTypeInternal _UpdateIntegrationResponse_default_instance_;
class UpdateProviderRequest;
struct UpdateProviderRequestDefaultTypeInternal;
extern UpdateProviderRequestDefaultTypeInternal _UpdateProviderRequest_default_instance_;
class UpdateProviderResponse;
struct UpdateProviderResponseDefaultTypeInternal;
extern UpdateProviderResponseDefaultTypeInternal _UpdateProviderResponse_default_instance_;
class UpdateRepositoryRequest;
struct UpdateRepositoryRequestDefaultTypeInternal;
extern UpdateRepositoryRequestDefaultTypeInternal _UpdateRepositoryRequest_default_instance_;
class UpdateRepositoryResponse;
struct UpdateRepositoryResponseDefaultTypeInternal;
extern UpdateRepositoryResponseDefaultTypeInternal _UpdateRepositoryResponse_default_instance_;
}  // namespace v1alpha1
}  // namespace source
PROTOBUF_NAMESPACE_OPEN
template<> ::source::v1alpha1::AccountIntegration* Arena::CreateMaybeMessage<::source::v1alpha1::AccountIntegration>(Arena*);
template<> ::source::v1alpha1::AccountProvider* Arena::CreateMaybeMessage<::source::v1alpha1::AccountProvider>(Arena*);
template<> ::source::v1alpha1::AccountsProvidersRequest* Arena::CreateMaybeMessage<::source::v1alpha1::AccountsProvidersRequest>(Arena*);
template<> ::source::v1alpha1::AccountsProvidersResponse* Arena::CreateMaybeMessage<::source::v1alpha1::AccountsProvidersResponse>(Arena*);
template<> ::source::v1alpha1::Branch* Arena::CreateMaybeMessage<::source::v1alpha1::Branch>(Arena*);
template<> ::source::v1alpha1::CreateDetailRepository* Arena::CreateMaybeMessage<::source::v1alpha1::CreateDetailRepository>(Arena*);
template<> ::source::v1alpha1::CreateIntegrationRequest* Arena::CreateMaybeMessage<::source::v1alpha1::CreateIntegrationRequest>(Arena*);
template<> ::source::v1alpha1::CreateIntegrationRequest_DataEntry_DoNotUse* Arena::CreateMaybeMessage<::source::v1alpha1::CreateIntegrationRequest_DataEntry_DoNotUse>(Arena*);
template<> ::source::v1alpha1::CreateIntegrationRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::source::v1alpha1::CreateIntegrationRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::source::v1alpha1::CreateIntegrationResponse* Arena::CreateMaybeMessage<::source::v1alpha1::CreateIntegrationResponse>(Arena*);
template<> ::source::v1alpha1::CreateProviderRequest* Arena::CreateMaybeMessage<::source::v1alpha1::CreateProviderRequest>(Arena*);
template<> ::source::v1alpha1::CreateProviderRequest_DataEntry_DoNotUse* Arena::CreateMaybeMessage<::source::v1alpha1::CreateProviderRequest_DataEntry_DoNotUse>(Arena*);
template<> ::source::v1alpha1::CreateProviderRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::source::v1alpha1::CreateProviderRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::source::v1alpha1::CreateProviderResponse* Arena::CreateMaybeMessage<::source::v1alpha1::CreateProviderResponse>(Arena*);
template<> ::source::v1alpha1::CreateRepositoryRequest* Arena::CreateMaybeMessage<::source::v1alpha1::CreateRepositoryRequest>(Arena*);
template<> ::source::v1alpha1::CreateRepositoryResponse* Arena::CreateMaybeMessage<::source::v1alpha1::CreateRepositoryResponse>(Arena*);
template<> ::source::v1alpha1::DeleteIntegrationRequest* Arena::CreateMaybeMessage<::source::v1alpha1::DeleteIntegrationRequest>(Arena*);
template<> ::source::v1alpha1::DeleteIntegrationResponse* Arena::CreateMaybeMessage<::source::v1alpha1::DeleteIntegrationResponse>(Arena*);
template<> ::source::v1alpha1::DeleteIntegrationsByOrganizationRequest* Arena::CreateMaybeMessage<::source::v1alpha1::DeleteIntegrationsByOrganizationRequest>(Arena*);
template<> ::source::v1alpha1::DeleteIntegrationsByOrganizationResponse* Arena::CreateMaybeMessage<::source::v1alpha1::DeleteIntegrationsByOrganizationResponse>(Arena*);
template<> ::source::v1alpha1::DeleteProviderRequest* Arena::CreateMaybeMessage<::source::v1alpha1::DeleteProviderRequest>(Arena*);
template<> ::source::v1alpha1::DeleteProviderResponse* Arena::CreateMaybeMessage<::source::v1alpha1::DeleteProviderResponse>(Arena*);
template<> ::source::v1alpha1::DeleteRepositoryRequest* Arena::CreateMaybeMessage<::source::v1alpha1::DeleteRepositoryRequest>(Arena*);
template<> ::source::v1alpha1::DeleteRepositoryResponse* Arena::CreateMaybeMessage<::source::v1alpha1::DeleteRepositoryResponse>(Arena*);
template<> ::source::v1alpha1::DetailRepository* Arena::CreateMaybeMessage<::source::v1alpha1::DetailRepository>(Arena*);
template<> ::source::v1alpha1::GetIntegrationRequest* Arena::CreateMaybeMessage<::source::v1alpha1::GetIntegrationRequest>(Arena*);
template<> ::source::v1alpha1::GetIntegrationResponse* Arena::CreateMaybeMessage<::source::v1alpha1::GetIntegrationResponse>(Arena*);
template<> ::source::v1alpha1::GetOneProviderByNameRequest* Arena::CreateMaybeMessage<::source::v1alpha1::GetOneProviderByNameRequest>(Arena*);
template<> ::source::v1alpha1::GetOneProviderByNameResponse* Arena::CreateMaybeMessage<::source::v1alpha1::GetOneProviderByNameResponse>(Arena*);
template<> ::source::v1alpha1::GetProviderRequest* Arena::CreateMaybeMessage<::source::v1alpha1::GetProviderRequest>(Arena*);
template<> ::source::v1alpha1::GetProviderResponse* Arena::CreateMaybeMessage<::source::v1alpha1::GetProviderResponse>(Arena*);
template<> ::source::v1alpha1::GetRepositoryProviderRequest* Arena::CreateMaybeMessage<::source::v1alpha1::GetRepositoryProviderRequest>(Arena*);
template<> ::source::v1alpha1::GetRepositoryProviderResponse* Arena::CreateMaybeMessage<::source::v1alpha1::GetRepositoryProviderResponse>(Arena*);
template<> ::source::v1alpha1::GetRepositoryRequest* Arena::CreateMaybeMessage<::source::v1alpha1::GetRepositoryRequest>(Arena*);
template<> ::source::v1alpha1::GetRepositoryResponse* Arena::CreateMaybeMessage<::source::v1alpha1::GetRepositoryResponse>(Arena*);
template<> ::source::v1alpha1::Integration* Arena::CreateMaybeMessage<::source::v1alpha1::Integration>(Arena*);
template<> ::source::v1alpha1::Integration_DataEntry_DoNotUse* Arena::CreateMaybeMessage<::source::v1alpha1::Integration_DataEntry_DoNotUse>(Arena*);
template<> ::source::v1alpha1::Integration_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::source::v1alpha1::Integration_MetadataEntry_DoNotUse>(Arena*);
template<> ::source::v1alpha1::ListIntegrationsRequest* Arena::CreateMaybeMessage<::source::v1alpha1::ListIntegrationsRequest>(Arena*);
template<> ::source::v1alpha1::ListIntegrationsResponse* Arena::CreateMaybeMessage<::source::v1alpha1::ListIntegrationsResponse>(Arena*);
template<> ::source::v1alpha1::ListProvidersRequest* Arena::CreateMaybeMessage<::source::v1alpha1::ListProvidersRequest>(Arena*);
template<> ::source::v1alpha1::ListProvidersResponse* Arena::CreateMaybeMessage<::source::v1alpha1::ListProvidersResponse>(Arena*);
template<> ::source::v1alpha1::ListRepositoriesProviderRequest* Arena::CreateMaybeMessage<::source::v1alpha1::ListRepositoriesProviderRequest>(Arena*);
template<> ::source::v1alpha1::ListRepositoriesProviderResponse* Arena::CreateMaybeMessage<::source::v1alpha1::ListRepositoriesProviderResponse>(Arena*);
template<> ::source::v1alpha1::ListRepositoriesRequest* Arena::CreateMaybeMessage<::source::v1alpha1::ListRepositoriesRequest>(Arena*);
template<> ::source::v1alpha1::ListRepositoriesResponse* Arena::CreateMaybeMessage<::source::v1alpha1::ListRepositoriesResponse>(Arena*);
template<> ::source::v1alpha1::ListRepository* Arena::CreateMaybeMessage<::source::v1alpha1::ListRepository>(Arena*);
template<> ::source::v1alpha1::Provider* Arena::CreateMaybeMessage<::source::v1alpha1::Provider>(Arena*);
template<> ::source::v1alpha1::Provider_DataEntry_DoNotUse* Arena::CreateMaybeMessage<::source::v1alpha1::Provider_DataEntry_DoNotUse>(Arena*);
template<> ::source::v1alpha1::Provider_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::source::v1alpha1::Provider_MetadataEntry_DoNotUse>(Arena*);
template<> ::source::v1alpha1::Repository* Arena::CreateMaybeMessage<::source::v1alpha1::Repository>(Arena*);
template<> ::source::v1alpha1::UpdateIntegrationRequest* Arena::CreateMaybeMessage<::source::v1alpha1::UpdateIntegrationRequest>(Arena*);
template<> ::source::v1alpha1::UpdateIntegrationResponse* Arena::CreateMaybeMessage<::source::v1alpha1::UpdateIntegrationResponse>(Arena*);
template<> ::source::v1alpha1::UpdateProviderRequest* Arena::CreateMaybeMessage<::source::v1alpha1::UpdateProviderRequest>(Arena*);
template<> ::source::v1alpha1::UpdateProviderResponse* Arena::CreateMaybeMessage<::source::v1alpha1::UpdateProviderResponse>(Arena*);
template<> ::source::v1alpha1::UpdateRepositoryRequest* Arena::CreateMaybeMessage<::source::v1alpha1::UpdateRepositoryRequest>(Arena*);
template<> ::source::v1alpha1::UpdateRepositoryResponse* Arena::CreateMaybeMessage<::source::v1alpha1::UpdateRepositoryResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace source {
namespace v1alpha1 {

// ===================================================================

class AccountProvider final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.AccountProvider) */ {
 public:
  inline AccountProvider() : AccountProvider(nullptr) {}
  ~AccountProvider() override;
  explicit constexpr AccountProvider(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountProvider(const AccountProvider& from);
  AccountProvider(AccountProvider&& from) noexcept
    : AccountProvider() {
    *this = ::std::move(from);
  }

  inline AccountProvider& operator=(const AccountProvider& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountProvider& operator=(AccountProvider&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountProvider& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountProvider* internal_default_instance() {
    return reinterpret_cast<const AccountProvider*>(
               &_AccountProvider_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AccountProvider& a, AccountProvider& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountProvider* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountProvider* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccountProvider* New() const final {
    return new AccountProvider();
  }

  AccountProvider* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountProvider>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountProvider& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountProvider& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountProvider* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.AccountProvider";
  }
  protected:
  explicit AccountProvider(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string type = 2 [json_name = "type"];
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.AccountProvider)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class AccountsProvidersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.AccountsProvidersRequest) */ {
 public:
  inline AccountsProvidersRequest() : AccountsProvidersRequest(nullptr) {}
  ~AccountsProvidersRequest() override;
  explicit constexpr AccountsProvidersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountsProvidersRequest(const AccountsProvidersRequest& from);
  AccountsProvidersRequest(AccountsProvidersRequest&& from) noexcept
    : AccountsProvidersRequest() {
    *this = ::std::move(from);
  }

  inline AccountsProvidersRequest& operator=(const AccountsProvidersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountsProvidersRequest& operator=(AccountsProvidersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountsProvidersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountsProvidersRequest* internal_default_instance() {
    return reinterpret_cast<const AccountsProvidersRequest*>(
               &_AccountsProvidersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AccountsProvidersRequest& a, AccountsProvidersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountsProvidersRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountsProvidersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccountsProvidersRequest* New() const final {
    return new AccountsProvidersRequest();
  }

  AccountsProvidersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountsProvidersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountsProvidersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountsProvidersRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountsProvidersRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.AccountsProvidersRequest";
  }
  protected:
  explicit AccountsProvidersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntegrationIdFieldNumber = 1,
    kPageFieldNumber = 2,
  };
  // string integration_id = 1 [json_name = "integrationId"];
  void clear_integration_id();
  const std::string& integration_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_integration_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_integration_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_integration_id();
  void set_allocated_integration_id(std::string* integration_id);
  private:
  const std::string& _internal_integration_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integration_id(const std::string& value);
  std::string* _internal_mutable_integration_id();
  public:

  // uint32 page = 2 [json_name = "page"];
  void clear_page();
  ::PROTOBUF_NAMESPACE_ID::uint32 page() const;
  void set_page(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_page() const;
  void _internal_set_page(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.AccountsProvidersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integration_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 page_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class AccountsProvidersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.AccountsProvidersResponse) */ {
 public:
  inline AccountsProvidersResponse() : AccountsProvidersResponse(nullptr) {}
  ~AccountsProvidersResponse() override;
  explicit constexpr AccountsProvidersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountsProvidersResponse(const AccountsProvidersResponse& from);
  AccountsProvidersResponse(AccountsProvidersResponse&& from) noexcept
    : AccountsProvidersResponse() {
    *this = ::std::move(from);
  }

  inline AccountsProvidersResponse& operator=(const AccountsProvidersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountsProvidersResponse& operator=(AccountsProvidersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountsProvidersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountsProvidersResponse* internal_default_instance() {
    return reinterpret_cast<const AccountsProvidersResponse*>(
               &_AccountsProvidersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AccountsProvidersResponse& a, AccountsProvidersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountsProvidersResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountsProvidersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccountsProvidersResponse* New() const final {
    return new AccountsProvidersResponse();
  }

  AccountsProvidersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountsProvidersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountsProvidersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountsProvidersResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountsProvidersResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.AccountsProvidersResponse";
  }
  protected:
  explicit AccountsProvidersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountsFieldNumber = 1,
    kCountFieldNumber = 2,
    kTotalPagesFieldNumber = 3,
  };
  // repeated .source.v1alpha1.AccountProvider accounts = 1 [json_name = "accounts"];
  int accounts_size() const;
  private:
  int _internal_accounts_size() const;
  public:
  void clear_accounts();
  ::source::v1alpha1::AccountProvider* mutable_accounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::AccountProvider >*
      mutable_accounts();
  private:
  const ::source::v1alpha1::AccountProvider& _internal_accounts(int index) const;
  ::source::v1alpha1::AccountProvider* _internal_add_accounts();
  public:
  const ::source::v1alpha1::AccountProvider& accounts(int index) const;
  ::source::v1alpha1::AccountProvider* add_accounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::AccountProvider >&
      accounts() const;

  // uint32 count = 2 [json_name = "count"];
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 total_pages = 3 [json_name = "totalPages"];
  void clear_total_pages();
  ::PROTOBUF_NAMESPACE_ID::uint32 total_pages() const;
  void set_total_pages(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_total_pages() const;
  void _internal_set_total_pages(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.AccountsProvidersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::AccountProvider > accounts_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  ::PROTOBUF_NAMESPACE_ID::uint32 total_pages_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class DeleteIntegrationsByOrganizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.DeleteIntegrationsByOrganizationRequest) */ {
 public:
  inline DeleteIntegrationsByOrganizationRequest() : DeleteIntegrationsByOrganizationRequest(nullptr) {}
  ~DeleteIntegrationsByOrganizationRequest() override;
  explicit constexpr DeleteIntegrationsByOrganizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteIntegrationsByOrganizationRequest(const DeleteIntegrationsByOrganizationRequest& from);
  DeleteIntegrationsByOrganizationRequest(DeleteIntegrationsByOrganizationRequest&& from) noexcept
    : DeleteIntegrationsByOrganizationRequest() {
    *this = ::std::move(from);
  }

  inline DeleteIntegrationsByOrganizationRequest& operator=(const DeleteIntegrationsByOrganizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteIntegrationsByOrganizationRequest& operator=(DeleteIntegrationsByOrganizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteIntegrationsByOrganizationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteIntegrationsByOrganizationRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteIntegrationsByOrganizationRequest*>(
               &_DeleteIntegrationsByOrganizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeleteIntegrationsByOrganizationRequest& a, DeleteIntegrationsByOrganizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteIntegrationsByOrganizationRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteIntegrationsByOrganizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteIntegrationsByOrganizationRequest* New() const final {
    return new DeleteIntegrationsByOrganizationRequest();
  }

  DeleteIntegrationsByOrganizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteIntegrationsByOrganizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteIntegrationsByOrganizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteIntegrationsByOrganizationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteIntegrationsByOrganizationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.DeleteIntegrationsByOrganizationRequest";
  }
  protected:
  explicit DeleteIntegrationsByOrganizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrganizationIdFieldNumber = 1,
  };
  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.DeleteIntegrationsByOrganizationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class DeleteIntegrationsByOrganizationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.DeleteIntegrationsByOrganizationResponse) */ {
 public:
  inline DeleteIntegrationsByOrganizationResponse() : DeleteIntegrationsByOrganizationResponse(nullptr) {}
  ~DeleteIntegrationsByOrganizationResponse() override;
  explicit constexpr DeleteIntegrationsByOrganizationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteIntegrationsByOrganizationResponse(const DeleteIntegrationsByOrganizationResponse& from);
  DeleteIntegrationsByOrganizationResponse(DeleteIntegrationsByOrganizationResponse&& from) noexcept
    : DeleteIntegrationsByOrganizationResponse() {
    *this = ::std::move(from);
  }

  inline DeleteIntegrationsByOrganizationResponse& operator=(const DeleteIntegrationsByOrganizationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteIntegrationsByOrganizationResponse& operator=(DeleteIntegrationsByOrganizationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteIntegrationsByOrganizationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteIntegrationsByOrganizationResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteIntegrationsByOrganizationResponse*>(
               &_DeleteIntegrationsByOrganizationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeleteIntegrationsByOrganizationResponse& a, DeleteIntegrationsByOrganizationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteIntegrationsByOrganizationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteIntegrationsByOrganizationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteIntegrationsByOrganizationResponse* New() const final {
    return new DeleteIntegrationsByOrganizationResponse();
  }

  DeleteIntegrationsByOrganizationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteIntegrationsByOrganizationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteIntegrationsByOrganizationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteIntegrationsByOrganizationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteIntegrationsByOrganizationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.DeleteIntegrationsByOrganizationResponse";
  }
  protected:
  explicit DeleteIntegrationsByOrganizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.DeleteIntegrationsByOrganizationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class GetOneProviderByNameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.GetOneProviderByNameRequest) */ {
 public:
  inline GetOneProviderByNameRequest() : GetOneProviderByNameRequest(nullptr) {}
  ~GetOneProviderByNameRequest() override;
  explicit constexpr GetOneProviderByNameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOneProviderByNameRequest(const GetOneProviderByNameRequest& from);
  GetOneProviderByNameRequest(GetOneProviderByNameRequest&& from) noexcept
    : GetOneProviderByNameRequest() {
    *this = ::std::move(from);
  }

  inline GetOneProviderByNameRequest& operator=(const GetOneProviderByNameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOneProviderByNameRequest& operator=(GetOneProviderByNameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOneProviderByNameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOneProviderByNameRequest* internal_default_instance() {
    return reinterpret_cast<const GetOneProviderByNameRequest*>(
               &_GetOneProviderByNameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetOneProviderByNameRequest& a, GetOneProviderByNameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOneProviderByNameRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOneProviderByNameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetOneProviderByNameRequest* New() const final {
    return new GetOneProviderByNameRequest();
  }

  GetOneProviderByNameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOneProviderByNameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOneProviderByNameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOneProviderByNameRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOneProviderByNameRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.GetOneProviderByNameRequest";
  }
  protected:
  explicit GetOneProviderByNameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.GetOneProviderByNameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class GetOneProviderByNameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.GetOneProviderByNameResponse) */ {
 public:
  inline GetOneProviderByNameResponse() : GetOneProviderByNameResponse(nullptr) {}
  ~GetOneProviderByNameResponse() override;
  explicit constexpr GetOneProviderByNameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOneProviderByNameResponse(const GetOneProviderByNameResponse& from);
  GetOneProviderByNameResponse(GetOneProviderByNameResponse&& from) noexcept
    : GetOneProviderByNameResponse() {
    *this = ::std::move(from);
  }

  inline GetOneProviderByNameResponse& operator=(const GetOneProviderByNameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOneProviderByNameResponse& operator=(GetOneProviderByNameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOneProviderByNameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOneProviderByNameResponse* internal_default_instance() {
    return reinterpret_cast<const GetOneProviderByNameResponse*>(
               &_GetOneProviderByNameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetOneProviderByNameResponse& a, GetOneProviderByNameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOneProviderByNameResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOneProviderByNameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetOneProviderByNameResponse* New() const final {
    return new GetOneProviderByNameResponse();
  }

  GetOneProviderByNameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOneProviderByNameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOneProviderByNameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOneProviderByNameResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOneProviderByNameResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.GetOneProviderByNameResponse";
  }
  protected:
  explicit GetOneProviderByNameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProviderFieldNumber = 1,
  };
  // .source.v1alpha1.Provider provider = 1 [json_name = "provider"];
  bool has_provider() const;
  private:
  bool _internal_has_provider() const;
  public:
  void clear_provider();
  const ::source::v1alpha1::Provider& provider() const;
  PROTOBUF_MUST_USE_RESULT ::source::v1alpha1::Provider* release_provider();
  ::source::v1alpha1::Provider* mutable_provider();
  void set_allocated_provider(::source::v1alpha1::Provider* provider);
  private:
  const ::source::v1alpha1::Provider& _internal_provider() const;
  ::source::v1alpha1::Provider* _internal_mutable_provider();
  public:
  void unsafe_arena_set_allocated_provider(
      ::source::v1alpha1::Provider* provider);
  ::source::v1alpha1::Provider* unsafe_arena_release_provider();

  // @@protoc_insertion_point(class_scope:source.v1alpha1.GetOneProviderByNameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::source::v1alpha1::Provider* provider_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class Branch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.Branch) */ {
 public:
  inline Branch() : Branch(nullptr) {}
  ~Branch() override;
  explicit constexpr Branch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Branch(const Branch& from);
  Branch(Branch&& from) noexcept
    : Branch() {
    *this = ::std::move(from);
  }

  inline Branch& operator=(const Branch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Branch& operator=(Branch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Branch& default_instance() {
    return *internal_default_instance();
  }
  static inline const Branch* internal_default_instance() {
    return reinterpret_cast<const Branch*>(
               &_Branch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Branch& a, Branch& b) {
    a.Swap(&b);
  }
  inline void Swap(Branch* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Branch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Branch* New() const final {
    return new Branch();
  }

  Branch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Branch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Branch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Branch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Branch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.Branch";
  }
  protected:
  explicit Branch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kShaFieldNumber = 2,
    kUrlFieldNumber = 3,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string sha = 2 [json_name = "sha"];
  void clear_sha();
  const std::string& sha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sha();
  PROTOBUF_MUST_USE_RESULT std::string* release_sha();
  void set_allocated_sha(std::string* sha);
  private:
  const std::string& _internal_sha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sha(const std::string& value);
  std::string* _internal_mutable_sha();
  public:

  // string url = 3 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_MUST_USE_RESULT std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.Branch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class ListRepositoriesProviderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.ListRepositoriesProviderRequest) */ {
 public:
  inline ListRepositoriesProviderRequest() : ListRepositoriesProviderRequest(nullptr) {}
  ~ListRepositoriesProviderRequest() override;
  explicit constexpr ListRepositoriesProviderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRepositoriesProviderRequest(const ListRepositoriesProviderRequest& from);
  ListRepositoriesProviderRequest(ListRepositoriesProviderRequest&& from) noexcept
    : ListRepositoriesProviderRequest() {
    *this = ::std::move(from);
  }

  inline ListRepositoriesProviderRequest& operator=(const ListRepositoriesProviderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRepositoriesProviderRequest& operator=(ListRepositoriesProviderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRepositoriesProviderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRepositoriesProviderRequest* internal_default_instance() {
    return reinterpret_cast<const ListRepositoriesProviderRequest*>(
               &_ListRepositoriesProviderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ListRepositoriesProviderRequest& a, ListRepositoriesProviderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRepositoriesProviderRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRepositoriesProviderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListRepositoriesProviderRequest* New() const final {
    return new ListRepositoriesProviderRequest();
  }

  ListRepositoriesProviderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListRepositoriesProviderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRepositoriesProviderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRepositoriesProviderRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRepositoriesProviderRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.ListRepositoriesProviderRequest";
  }
  protected:
  explicit ListRepositoriesProviderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntegrationIdFieldNumber = 1,
    kPageFieldNumber = 2,
  };
  // string integration_id = 1 [json_name = "integrationId"];
  void clear_integration_id();
  const std::string& integration_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_integration_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_integration_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_integration_id();
  void set_allocated_integration_id(std::string* integration_id);
  private:
  const std::string& _internal_integration_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integration_id(const std::string& value);
  std::string* _internal_mutable_integration_id();
  public:

  // uint32 page = 2 [json_name = "page"];
  void clear_page();
  ::PROTOBUF_NAMESPACE_ID::uint32 page() const;
  void set_page(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_page() const;
  void _internal_set_page(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.ListRepositoriesProviderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integration_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 page_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class ListRepositoriesProviderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.ListRepositoriesProviderResponse) */ {
 public:
  inline ListRepositoriesProviderResponse() : ListRepositoriesProviderResponse(nullptr) {}
  ~ListRepositoriesProviderResponse() override;
  explicit constexpr ListRepositoriesProviderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRepositoriesProviderResponse(const ListRepositoriesProviderResponse& from);
  ListRepositoriesProviderResponse(ListRepositoriesProviderResponse&& from) noexcept
    : ListRepositoriesProviderResponse() {
    *this = ::std::move(from);
  }

  inline ListRepositoriesProviderResponse& operator=(const ListRepositoriesProviderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRepositoriesProviderResponse& operator=(ListRepositoriesProviderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRepositoriesProviderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRepositoriesProviderResponse* internal_default_instance() {
    return reinterpret_cast<const ListRepositoriesProviderResponse*>(
               &_ListRepositoriesProviderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListRepositoriesProviderResponse& a, ListRepositoriesProviderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRepositoriesProviderResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRepositoriesProviderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListRepositoriesProviderResponse* New() const final {
    return new ListRepositoriesProviderResponse();
  }

  ListRepositoriesProviderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListRepositoriesProviderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRepositoriesProviderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRepositoriesProviderResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRepositoriesProviderResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.ListRepositoriesProviderResponse";
  }
  protected:
  explicit ListRepositoriesProviderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepositoriesFieldNumber = 1,
    kTotalPagesFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // repeated .source.v1alpha1.Repository repositories = 1 [json_name = "repositories"];
  int repositories_size() const;
  private:
  int _internal_repositories_size() const;
  public:
  void clear_repositories();
  ::source::v1alpha1::Repository* mutable_repositories(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Repository >*
      mutable_repositories();
  private:
  const ::source::v1alpha1::Repository& _internal_repositories(int index) const;
  ::source::v1alpha1::Repository* _internal_add_repositories();
  public:
  const ::source::v1alpha1::Repository& repositories(int index) const;
  ::source::v1alpha1::Repository* add_repositories();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Repository >&
      repositories() const;

  // uint32 total_pages = 2 [json_name = "totalPages"];
  void clear_total_pages();
  ::PROTOBUF_NAMESPACE_ID::uint32 total_pages() const;
  void set_total_pages(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_total_pages() const;
  void _internal_set_total_pages(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 count = 3 [json_name = "count"];
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.ListRepositoriesProviderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Repository > repositories_;
  ::PROTOBUF_NAMESPACE_ID::uint32 total_pages_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class GetRepositoryProviderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.GetRepositoryProviderRequest) */ {
 public:
  inline GetRepositoryProviderRequest() : GetRepositoryProviderRequest(nullptr) {}
  ~GetRepositoryProviderRequest() override;
  explicit constexpr GetRepositoryProviderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRepositoryProviderRequest(const GetRepositoryProviderRequest& from);
  GetRepositoryProviderRequest(GetRepositoryProviderRequest&& from) noexcept
    : GetRepositoryProviderRequest() {
    *this = ::std::move(from);
  }

  inline GetRepositoryProviderRequest& operator=(const GetRepositoryProviderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRepositoryProviderRequest& operator=(GetRepositoryProviderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRepositoryProviderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRepositoryProviderRequest* internal_default_instance() {
    return reinterpret_cast<const GetRepositoryProviderRequest*>(
               &_GetRepositoryProviderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetRepositoryProviderRequest& a, GetRepositoryProviderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRepositoryProviderRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRepositoryProviderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRepositoryProviderRequest* New() const final {
    return new GetRepositoryProviderRequest();
  }

  GetRepositoryProviderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRepositoryProviderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRepositoryProviderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRepositoryProviderRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRepositoryProviderRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.GetRepositoryProviderRequest";
  }
  protected:
  explicit GetRepositoryProviderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntegrationIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string integration_id = 1 [json_name = "integrationId"];
  void clear_integration_id();
  const std::string& integration_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_integration_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_integration_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_integration_id();
  void set_allocated_integration_id(std::string* integration_id);
  private:
  const std::string& _internal_integration_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integration_id(const std::string& value);
  std::string* _internal_mutable_integration_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.GetRepositoryProviderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integration_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class GetRepositoryProviderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.GetRepositoryProviderResponse) */ {
 public:
  inline GetRepositoryProviderResponse() : GetRepositoryProviderResponse(nullptr) {}
  ~GetRepositoryProviderResponse() override;
  explicit constexpr GetRepositoryProviderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRepositoryProviderResponse(const GetRepositoryProviderResponse& from);
  GetRepositoryProviderResponse(GetRepositoryProviderResponse&& from) noexcept
    : GetRepositoryProviderResponse() {
    *this = ::std::move(from);
  }

  inline GetRepositoryProviderResponse& operator=(const GetRepositoryProviderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRepositoryProviderResponse& operator=(GetRepositoryProviderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRepositoryProviderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRepositoryProviderResponse* internal_default_instance() {
    return reinterpret_cast<const GetRepositoryProviderResponse*>(
               &_GetRepositoryProviderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetRepositoryProviderResponse& a, GetRepositoryProviderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRepositoryProviderResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRepositoryProviderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRepositoryProviderResponse* New() const final {
    return new GetRepositoryProviderResponse();
  }

  GetRepositoryProviderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRepositoryProviderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRepositoryProviderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRepositoryProviderResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRepositoryProviderResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.GetRepositoryProviderResponse";
  }
  protected:
  explicit GetRepositoryProviderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBranchsFieldNumber = 1,
  };
  // repeated .source.v1alpha1.Branch branchs = 1 [json_name = "branchs"];
  int branchs_size() const;
  private:
  int _internal_branchs_size() const;
  public:
  void clear_branchs();
  ::source::v1alpha1::Branch* mutable_branchs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Branch >*
      mutable_branchs();
  private:
  const ::source::v1alpha1::Branch& _internal_branchs(int index) const;
  ::source::v1alpha1::Branch* _internal_add_branchs();
  public:
  const ::source::v1alpha1::Branch& branchs(int index) const;
  ::source::v1alpha1::Branch* add_branchs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Branch >&
      branchs() const;

  // @@protoc_insertion_point(class_scope:source.v1alpha1.GetRepositoryProviderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Branch > branchs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class DetailRepository final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.DetailRepository) */ {
 public:
  inline DetailRepository() : DetailRepository(nullptr) {}
  ~DetailRepository() override;
  explicit constexpr DetailRepository(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetailRepository(const DetailRepository& from);
  DetailRepository(DetailRepository&& from) noexcept
    : DetailRepository() {
    *this = ::std::move(from);
  }

  inline DetailRepository& operator=(const DetailRepository& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetailRepository& operator=(DetailRepository&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetailRepository& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetailRepository* internal_default_instance() {
    return reinterpret_cast<const DetailRepository*>(
               &_DetailRepository_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DetailRepository& a, DetailRepository& b) {
    a.Swap(&b);
  }
  inline void Swap(DetailRepository* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetailRepository* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DetailRepository* New() const final {
    return new DetailRepository();
  }

  DetailRepository* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DetailRepository>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetailRepository& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DetailRepository& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetailRepository* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.DetailRepository";
  }
  protected:
  explicit DetailRepository(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBranchsFieldNumber = 10,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kFullnameFieldNumber = 4,
    kDescriptionFieldNumber = 5,
    kCloneUrlFieldNumber = 7,
    kIntegrationIdFieldNumber = 11,
    kPrivateFieldNumber = 3,
    kForkFieldNumber = 6,
    kProjectIdFieldNumber = 8,
    kOrganizationIdFieldNumber = 9,
  };
  // repeated string branchs = 10 [json_name = "branchs"];
  int branchs_size() const;
  private:
  int _internal_branchs_size() const;
  public:
  void clear_branchs();
  const std::string& branchs(int index) const;
  std::string* mutable_branchs(int index);
  void set_branchs(int index, const std::string& value);
  void set_branchs(int index, std::string&& value);
  void set_branchs(int index, const char* value);
  void set_branchs(int index, const char* value, size_t size);
  std::string* add_branchs();
  void add_branchs(const std::string& value);
  void add_branchs(std::string&& value);
  void add_branchs(const char* value);
  void add_branchs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& branchs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_branchs();
  private:
  const std::string& _internal_branchs(int index) const;
  std::string* _internal_add_branchs();
  public:

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string fullname = 4 [json_name = "fullname"];
  void clear_fullname();
  const std::string& fullname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fullname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fullname();
  PROTOBUF_MUST_USE_RESULT std::string* release_fullname();
  void set_allocated_fullname(std::string* fullname);
  private:
  const std::string& _internal_fullname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fullname(const std::string& value);
  std::string* _internal_mutable_fullname();
  public:

  // string description = 5 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string clone_url = 7 [json_name = "cloneUrl"];
  void clear_clone_url();
  const std::string& clone_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clone_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clone_url();
  PROTOBUF_MUST_USE_RESULT std::string* release_clone_url();
  void set_allocated_clone_url(std::string* clone_url);
  private:
  const std::string& _internal_clone_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clone_url(const std::string& value);
  std::string* _internal_mutable_clone_url();
  public:

  // string integration_id = 11 [json_name = "integrationId"];
  void clear_integration_id();
  const std::string& integration_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_integration_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_integration_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_integration_id();
  void set_allocated_integration_id(std::string* integration_id);
  private:
  const std::string& _internal_integration_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integration_id(const std::string& value);
  std::string* _internal_mutable_integration_id();
  public:

  // bool private = 3 [json_name = "private"];
  void clear_private_();
  bool private_() const;
  void set_private_(bool value);
  private:
  bool _internal_private_() const;
  void _internal_set_private_(bool value);
  public:

  // bool fork = 6 [json_name = "fork"];
  void clear_fork();
  bool fork() const;
  void set_fork(bool value);
  private:
  bool _internal_fork() const;
  void _internal_set_fork(bool value);
  public:

  // uint32 project_id = 8 [json_name = "projectId"];
  void clear_project_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id() const;
  void set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_project_id() const;
  void _internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 organization_id = 9 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.DetailRepository)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> branchs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fullname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clone_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integration_id_;
  bool private__;
  bool fork_;
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class ListRepository final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.ListRepository) */ {
 public:
  inline ListRepository() : ListRepository(nullptr) {}
  ~ListRepository() override;
  explicit constexpr ListRepository(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRepository(const ListRepository& from);
  ListRepository(ListRepository&& from) noexcept
    : ListRepository() {
    *this = ::std::move(from);
  }

  inline ListRepository& operator=(const ListRepository& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRepository& operator=(ListRepository&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRepository& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRepository* internal_default_instance() {
    return reinterpret_cast<const ListRepository*>(
               &_ListRepository_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListRepository& a, ListRepository& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRepository* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRepository* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListRepository* New() const final {
    return new ListRepository();
  }

  ListRepository* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListRepository>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRepository& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRepository& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRepository* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.ListRepository";
  }
  protected:
  explicit ListRepository(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kFullnameFieldNumber = 4,
    kDescriptionFieldNumber = 5,
    kCloneUrlFieldNumber = 7,
    kIntegrationIdFieldNumber = 11,
    kPrivateFieldNumber = 3,
    kProjectIdFieldNumber = 8,
    kOrganizationIdFieldNumber = 9,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string fullname = 4 [json_name = "fullname"];
  void clear_fullname();
  const std::string& fullname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fullname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fullname();
  PROTOBUF_MUST_USE_RESULT std::string* release_fullname();
  void set_allocated_fullname(std::string* fullname);
  private:
  const std::string& _internal_fullname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fullname(const std::string& value);
  std::string* _internal_mutable_fullname();
  public:

  // string description = 5 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string clone_url = 7 [json_name = "cloneUrl"];
  void clear_clone_url();
  const std::string& clone_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clone_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clone_url();
  PROTOBUF_MUST_USE_RESULT std::string* release_clone_url();
  void set_allocated_clone_url(std::string* clone_url);
  private:
  const std::string& _internal_clone_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clone_url(const std::string& value);
  std::string* _internal_mutable_clone_url();
  public:

  // string integration_id = 11 [json_name = "integrationId"];
  void clear_integration_id();
  const std::string& integration_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_integration_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_integration_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_integration_id();
  void set_allocated_integration_id(std::string* integration_id);
  private:
  const std::string& _internal_integration_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integration_id(const std::string& value);
  std::string* _internal_mutable_integration_id();
  public:

  // bool private = 3 [json_name = "private"];
  void clear_private_();
  bool private_() const;
  void set_private_(bool value);
  private:
  bool _internal_private_() const;
  void _internal_set_private_(bool value);
  public:

  // uint32 project_id = 8 [json_name = "projectId"];
  void clear_project_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id() const;
  void set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_project_id() const;
  void _internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 organization_id = 9 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.ListRepository)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fullname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clone_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integration_id_;
  bool private__;
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class CreateDetailRepository final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.CreateDetailRepository) */ {
 public:
  inline CreateDetailRepository() : CreateDetailRepository(nullptr) {}
  ~CreateDetailRepository() override;
  explicit constexpr CreateDetailRepository(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDetailRepository(const CreateDetailRepository& from);
  CreateDetailRepository(CreateDetailRepository&& from) noexcept
    : CreateDetailRepository() {
    *this = ::std::move(from);
  }

  inline CreateDetailRepository& operator=(const CreateDetailRepository& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDetailRepository& operator=(CreateDetailRepository&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDetailRepository& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDetailRepository* internal_default_instance() {
    return reinterpret_cast<const CreateDetailRepository*>(
               &_CreateDetailRepository_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CreateDetailRepository& a, CreateDetailRepository& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDetailRepository* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDetailRepository* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateDetailRepository* New() const final {
    return new CreateDetailRepository();
  }

  CreateDetailRepository* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateDetailRepository>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateDetailRepository& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateDetailRepository& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateDetailRepository* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.CreateDetailRepository";
  }
  protected:
  explicit CreateDetailRepository(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFullnameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kCloneUrlFieldNumber = 6,
    kIntegrationIdFieldNumber = 9,
    kPrivateFieldNumber = 2,
    kForkFieldNumber = 5,
    kProjectIdFieldNumber = 7,
    kOrganizationIdFieldNumber = 8,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string fullname = 3 [json_name = "fullname"];
  void clear_fullname();
  const std::string& fullname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fullname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fullname();
  PROTOBUF_MUST_USE_RESULT std::string* release_fullname();
  void set_allocated_fullname(std::string* fullname);
  private:
  const std::string& _internal_fullname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fullname(const std::string& value);
  std::string* _internal_mutable_fullname();
  public:

  // string description = 4 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string clone_url = 6 [json_name = "cloneUrl"];
  void clear_clone_url();
  const std::string& clone_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clone_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clone_url();
  PROTOBUF_MUST_USE_RESULT std::string* release_clone_url();
  void set_allocated_clone_url(std::string* clone_url);
  private:
  const std::string& _internal_clone_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clone_url(const std::string& value);
  std::string* _internal_mutable_clone_url();
  public:

  // string integration_id = 9 [json_name = "integrationId"];
  void clear_integration_id();
  const std::string& integration_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_integration_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_integration_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_integration_id();
  void set_allocated_integration_id(std::string* integration_id);
  private:
  const std::string& _internal_integration_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integration_id(const std::string& value);
  std::string* _internal_mutable_integration_id();
  public:

  // bool private = 2 [json_name = "private"];
  void clear_private_();
  bool private_() const;
  void set_private_(bool value);
  private:
  bool _internal_private_() const;
  void _internal_set_private_(bool value);
  public:

  // bool fork = 5 [json_name = "fork"];
  void clear_fork();
  bool fork() const;
  void set_fork(bool value);
  private:
  bool _internal_fork() const;
  void _internal_set_fork(bool value);
  public:

  // uint32 project_id = 7 [json_name = "projectId"];
  void clear_project_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id() const;
  void set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_project_id() const;
  void _internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 organization_id = 8 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.CreateDetailRepository)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fullname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clone_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integration_id_;
  bool private__;
  bool fork_;
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class CreateRepositoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.CreateRepositoryRequest) */ {
 public:
  inline CreateRepositoryRequest() : CreateRepositoryRequest(nullptr) {}
  ~CreateRepositoryRequest() override;
  explicit constexpr CreateRepositoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRepositoryRequest(const CreateRepositoryRequest& from);
  CreateRepositoryRequest(CreateRepositoryRequest&& from) noexcept
    : CreateRepositoryRequest() {
    *this = ::std::move(from);
  }

  inline CreateRepositoryRequest& operator=(const CreateRepositoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRepositoryRequest& operator=(CreateRepositoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRepositoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRepositoryRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRepositoryRequest*>(
               &_CreateRepositoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CreateRepositoryRequest& a, CreateRepositoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRepositoryRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRepositoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateRepositoryRequest* New() const final {
    return new CreateRepositoryRequest();
  }

  CreateRepositoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateRepositoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRepositoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateRepositoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRepositoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.CreateRepositoryRequest";
  }
  protected:
  explicit CreateRepositoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepositoryFieldNumber = 1,
    kProjectIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 3,
  };
  // .source.v1alpha1.CreateDetailRepository repository = 1 [json_name = "repository"];
  bool has_repository() const;
  private:
  bool _internal_has_repository() const;
  public:
  void clear_repository();
  const ::source::v1alpha1::CreateDetailRepository& repository() const;
  PROTOBUF_MUST_USE_RESULT ::source::v1alpha1::CreateDetailRepository* release_repository();
  ::source::v1alpha1::CreateDetailRepository* mutable_repository();
  void set_allocated_repository(::source::v1alpha1::CreateDetailRepository* repository);
  private:
  const ::source::v1alpha1::CreateDetailRepository& _internal_repository() const;
  ::source::v1alpha1::CreateDetailRepository* _internal_mutable_repository();
  public:
  void unsafe_arena_set_allocated_repository(
      ::source::v1alpha1::CreateDetailRepository* repository);
  ::source::v1alpha1::CreateDetailRepository* unsafe_arena_release_repository();

  // uint32 project_id = 2 [json_name = "projectId"];
  void clear_project_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id() const;
  void set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_project_id() const;
  void _internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 organization_id = 3 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.CreateRepositoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::source::v1alpha1::CreateDetailRepository* repository_;
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class CreateRepositoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.CreateRepositoryResponse) */ {
 public:
  inline CreateRepositoryResponse() : CreateRepositoryResponse(nullptr) {}
  ~CreateRepositoryResponse() override;
  explicit constexpr CreateRepositoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRepositoryResponse(const CreateRepositoryResponse& from);
  CreateRepositoryResponse(CreateRepositoryResponse&& from) noexcept
    : CreateRepositoryResponse() {
    *this = ::std::move(from);
  }

  inline CreateRepositoryResponse& operator=(const CreateRepositoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRepositoryResponse& operator=(CreateRepositoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRepositoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRepositoryResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRepositoryResponse*>(
               &_CreateRepositoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CreateRepositoryResponse& a, CreateRepositoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRepositoryResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRepositoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateRepositoryResponse* New() const final {
    return new CreateRepositoryResponse();
  }

  CreateRepositoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateRepositoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRepositoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateRepositoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRepositoryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.CreateRepositoryResponse";
  }
  protected:
  explicit CreateRepositoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.CreateRepositoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class ListRepositoriesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.ListRepositoriesRequest) */ {
 public:
  inline ListRepositoriesRequest() : ListRepositoriesRequest(nullptr) {}
  ~ListRepositoriesRequest() override;
  explicit constexpr ListRepositoriesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRepositoriesRequest(const ListRepositoriesRequest& from);
  ListRepositoriesRequest(ListRepositoriesRequest&& from) noexcept
    : ListRepositoriesRequest() {
    *this = ::std::move(from);
  }

  inline ListRepositoriesRequest& operator=(const ListRepositoriesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRepositoriesRequest& operator=(ListRepositoriesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRepositoriesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRepositoriesRequest* internal_default_instance() {
    return reinterpret_cast<const ListRepositoriesRequest*>(
               &_ListRepositoriesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ListRepositoriesRequest& a, ListRepositoriesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRepositoriesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRepositoriesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListRepositoriesRequest* New() const final {
    return new ListRepositoriesRequest();
  }

  ListRepositoriesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListRepositoriesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRepositoriesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRepositoriesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRepositoriesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.ListRepositoriesRequest";
  }
  protected:
  explicit ListRepositoriesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectIdFieldNumber = 1,
    kOrganizationIdFieldNumber = 2,
  };
  // uint32 project_id = 1 [json_name = "projectId"];
  void clear_project_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id() const;
  void set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_project_id() const;
  void _internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 organization_id = 2 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.ListRepositoriesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class ListRepositoriesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.ListRepositoriesResponse) */ {
 public:
  inline ListRepositoriesResponse() : ListRepositoriesResponse(nullptr) {}
  ~ListRepositoriesResponse() override;
  explicit constexpr ListRepositoriesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRepositoriesResponse(const ListRepositoriesResponse& from);
  ListRepositoriesResponse(ListRepositoriesResponse&& from) noexcept
    : ListRepositoriesResponse() {
    *this = ::std::move(from);
  }

  inline ListRepositoriesResponse& operator=(const ListRepositoriesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRepositoriesResponse& operator=(ListRepositoriesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRepositoriesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRepositoriesResponse* internal_default_instance() {
    return reinterpret_cast<const ListRepositoriesResponse*>(
               &_ListRepositoriesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ListRepositoriesResponse& a, ListRepositoriesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRepositoriesResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRepositoriesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListRepositoriesResponse* New() const final {
    return new ListRepositoriesResponse();
  }

  ListRepositoriesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListRepositoriesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRepositoriesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRepositoriesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRepositoriesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.ListRepositoriesResponse";
  }
  protected:
  explicit ListRepositoriesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepositoriesFieldNumber = 1,
  };
  // repeated .source.v1alpha1.ListRepository repositories = 1 [json_name = "repositories"];
  int repositories_size() const;
  private:
  int _internal_repositories_size() const;
  public:
  void clear_repositories();
  ::source::v1alpha1::ListRepository* mutable_repositories(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::ListRepository >*
      mutable_repositories();
  private:
  const ::source::v1alpha1::ListRepository& _internal_repositories(int index) const;
  ::source::v1alpha1::ListRepository* _internal_add_repositories();
  public:
  const ::source::v1alpha1::ListRepository& repositories(int index) const;
  ::source::v1alpha1::ListRepository* add_repositories();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::ListRepository >&
      repositories() const;

  // @@protoc_insertion_point(class_scope:source.v1alpha1.ListRepositoriesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::ListRepository > repositories_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class GetRepositoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.GetRepositoryRequest) */ {
 public:
  inline GetRepositoryRequest() : GetRepositoryRequest(nullptr) {}
  ~GetRepositoryRequest() override;
  explicit constexpr GetRepositoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRepositoryRequest(const GetRepositoryRequest& from);
  GetRepositoryRequest(GetRepositoryRequest&& from) noexcept
    : GetRepositoryRequest() {
    *this = ::std::move(from);
  }

  inline GetRepositoryRequest& operator=(const GetRepositoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRepositoryRequest& operator=(GetRepositoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRepositoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRepositoryRequest* internal_default_instance() {
    return reinterpret_cast<const GetRepositoryRequest*>(
               &_GetRepositoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetRepositoryRequest& a, GetRepositoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRepositoryRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRepositoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRepositoryRequest* New() const final {
    return new GetRepositoryRequest();
  }

  GetRepositoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRepositoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRepositoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRepositoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRepositoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.GetRepositoryRequest";
  }
  protected:
  explicit GetRepositoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepositoryIdFieldNumber = 1,
  };
  // string repository_id = 1 [json_name = "repositoryId"];
  void clear_repository_id();
  const std::string& repository_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_repository_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_repository_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_repository_id();
  void set_allocated_repository_id(std::string* repository_id);
  private:
  const std::string& _internal_repository_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repository_id(const std::string& value);
  std::string* _internal_mutable_repository_id();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.GetRepositoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr repository_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class GetRepositoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.GetRepositoryResponse) */ {
 public:
  inline GetRepositoryResponse() : GetRepositoryResponse(nullptr) {}
  ~GetRepositoryResponse() override;
  explicit constexpr GetRepositoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRepositoryResponse(const GetRepositoryResponse& from);
  GetRepositoryResponse(GetRepositoryResponse&& from) noexcept
    : GetRepositoryResponse() {
    *this = ::std::move(from);
  }

  inline GetRepositoryResponse& operator=(const GetRepositoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRepositoryResponse& operator=(GetRepositoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRepositoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRepositoryResponse* internal_default_instance() {
    return reinterpret_cast<const GetRepositoryResponse*>(
               &_GetRepositoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetRepositoryResponse& a, GetRepositoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRepositoryResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRepositoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRepositoryResponse* New() const final {
    return new GetRepositoryResponse();
  }

  GetRepositoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRepositoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRepositoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRepositoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRepositoryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.GetRepositoryResponse";
  }
  protected:
  explicit GetRepositoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepositoryFieldNumber = 1,
  };
  // .source.v1alpha1.DetailRepository repository = 1 [json_name = "repository"];
  bool has_repository() const;
  private:
  bool _internal_has_repository() const;
  public:
  void clear_repository();
  const ::source::v1alpha1::DetailRepository& repository() const;
  PROTOBUF_MUST_USE_RESULT ::source::v1alpha1::DetailRepository* release_repository();
  ::source::v1alpha1::DetailRepository* mutable_repository();
  void set_allocated_repository(::source::v1alpha1::DetailRepository* repository);
  private:
  const ::source::v1alpha1::DetailRepository& _internal_repository() const;
  ::source::v1alpha1::DetailRepository* _internal_mutable_repository();
  public:
  void unsafe_arena_set_allocated_repository(
      ::source::v1alpha1::DetailRepository* repository);
  ::source::v1alpha1::DetailRepository* unsafe_arena_release_repository();

  // @@protoc_insertion_point(class_scope:source.v1alpha1.GetRepositoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::source::v1alpha1::DetailRepository* repository_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class DeleteRepositoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.DeleteRepositoryRequest) */ {
 public:
  inline DeleteRepositoryRequest() : DeleteRepositoryRequest(nullptr) {}
  ~DeleteRepositoryRequest() override;
  explicit constexpr DeleteRepositoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRepositoryRequest(const DeleteRepositoryRequest& from);
  DeleteRepositoryRequest(DeleteRepositoryRequest&& from) noexcept
    : DeleteRepositoryRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRepositoryRequest& operator=(const DeleteRepositoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRepositoryRequest& operator=(DeleteRepositoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRepositoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRepositoryRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRepositoryRequest*>(
               &_DeleteRepositoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DeleteRepositoryRequest& a, DeleteRepositoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRepositoryRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRepositoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteRepositoryRequest* New() const final {
    return new DeleteRepositoryRequest();
  }

  DeleteRepositoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRepositoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRepositoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRepositoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRepositoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.DeleteRepositoryRequest";
  }
  protected:
  explicit DeleteRepositoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepositoryIdFieldNumber = 1,
  };
  // string repository_id = 1 [json_name = "repositoryId"];
  void clear_repository_id();
  const std::string& repository_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_repository_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_repository_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_repository_id();
  void set_allocated_repository_id(std::string* repository_id);
  private:
  const std::string& _internal_repository_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repository_id(const std::string& value);
  std::string* _internal_mutable_repository_id();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.DeleteRepositoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr repository_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class DeleteRepositoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.DeleteRepositoryResponse) */ {
 public:
  inline DeleteRepositoryResponse() : DeleteRepositoryResponse(nullptr) {}
  ~DeleteRepositoryResponse() override;
  explicit constexpr DeleteRepositoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRepositoryResponse(const DeleteRepositoryResponse& from);
  DeleteRepositoryResponse(DeleteRepositoryResponse&& from) noexcept
    : DeleteRepositoryResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRepositoryResponse& operator=(const DeleteRepositoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRepositoryResponse& operator=(DeleteRepositoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRepositoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRepositoryResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRepositoryResponse*>(
               &_DeleteRepositoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DeleteRepositoryResponse& a, DeleteRepositoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRepositoryResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRepositoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteRepositoryResponse* New() const final {
    return new DeleteRepositoryResponse();
  }

  DeleteRepositoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRepositoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRepositoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRepositoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRepositoryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.DeleteRepositoryResponse";
  }
  protected:
  explicit DeleteRepositoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.DeleteRepositoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class UpdateRepositoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.UpdateRepositoryRequest) */ {
 public:
  inline UpdateRepositoryRequest() : UpdateRepositoryRequest(nullptr) {}
  ~UpdateRepositoryRequest() override;
  explicit constexpr UpdateRepositoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRepositoryRequest(const UpdateRepositoryRequest& from);
  UpdateRepositoryRequest(UpdateRepositoryRequest&& from) noexcept
    : UpdateRepositoryRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRepositoryRequest& operator=(const UpdateRepositoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRepositoryRequest& operator=(UpdateRepositoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRepositoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRepositoryRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRepositoryRequest*>(
               &_UpdateRepositoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(UpdateRepositoryRequest& a, UpdateRepositoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRepositoryRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRepositoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateRepositoryRequest* New() const final {
    return new UpdateRepositoryRequest();
  }

  UpdateRepositoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateRepositoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRepositoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRepositoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRepositoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.UpdateRepositoryRequest";
  }
  protected:
  explicit UpdateRepositoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepositoryIdFieldNumber = 1,
    kRepositoryFieldNumber = 2,
  };
  // string repository_id = 1 [json_name = "repositoryId"];
  void clear_repository_id();
  const std::string& repository_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_repository_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_repository_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_repository_id();
  void set_allocated_repository_id(std::string* repository_id);
  private:
  const std::string& _internal_repository_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repository_id(const std::string& value);
  std::string* _internal_mutable_repository_id();
  public:

  // .source.v1alpha1.DetailRepository repository = 2 [json_name = "repository"];
  bool has_repository() const;
  private:
  bool _internal_has_repository() const;
  public:
  void clear_repository();
  const ::source::v1alpha1::DetailRepository& repository() const;
  PROTOBUF_MUST_USE_RESULT ::source::v1alpha1::DetailRepository* release_repository();
  ::source::v1alpha1::DetailRepository* mutable_repository();
  void set_allocated_repository(::source::v1alpha1::DetailRepository* repository);
  private:
  const ::source::v1alpha1::DetailRepository& _internal_repository() const;
  ::source::v1alpha1::DetailRepository* _internal_mutable_repository();
  public:
  void unsafe_arena_set_allocated_repository(
      ::source::v1alpha1::DetailRepository* repository);
  ::source::v1alpha1::DetailRepository* unsafe_arena_release_repository();

  // @@protoc_insertion_point(class_scope:source.v1alpha1.UpdateRepositoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr repository_id_;
  ::source::v1alpha1::DetailRepository* repository_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class UpdateRepositoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.UpdateRepositoryResponse) */ {
 public:
  inline UpdateRepositoryResponse() : UpdateRepositoryResponse(nullptr) {}
  ~UpdateRepositoryResponse() override;
  explicit constexpr UpdateRepositoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRepositoryResponse(const UpdateRepositoryResponse& from);
  UpdateRepositoryResponse(UpdateRepositoryResponse&& from) noexcept
    : UpdateRepositoryResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRepositoryResponse& operator=(const UpdateRepositoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRepositoryResponse& operator=(UpdateRepositoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRepositoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRepositoryResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRepositoryResponse*>(
               &_UpdateRepositoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(UpdateRepositoryResponse& a, UpdateRepositoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRepositoryResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRepositoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateRepositoryResponse* New() const final {
    return new UpdateRepositoryResponse();
  }

  UpdateRepositoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateRepositoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRepositoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRepositoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRepositoryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.UpdateRepositoryResponse";
  }
  protected:
  explicit UpdateRepositoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.UpdateRepositoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class Integration_DataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Integration_DataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Integration_DataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Integration_DataEntry_DoNotUse();
  explicit constexpr Integration_DataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Integration_DataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Integration_DataEntry_DoNotUse& other);
  static const Integration_DataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Integration_DataEntry_DoNotUse*>(&_Integration_DataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.Integration.DataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.Integration.DataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Integration_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Integration_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Integration_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Integration_MetadataEntry_DoNotUse();
  explicit constexpr Integration_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Integration_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Integration_MetadataEntry_DoNotUse& other);
  static const Integration_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Integration_MetadataEntry_DoNotUse*>(&_Integration_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.Integration.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.Integration.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Integration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.Integration) */ {
 public:
  inline Integration() : Integration(nullptr) {}
  ~Integration() override;
  explicit constexpr Integration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Integration(const Integration& from);
  Integration(Integration&& from) noexcept
    : Integration() {
    *this = ::std::move(from);
  }

  inline Integration& operator=(const Integration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Integration& operator=(Integration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Integration& default_instance() {
    return *internal_default_instance();
  }
  static inline const Integration* internal_default_instance() {
    return reinterpret_cast<const Integration*>(
               &_Integration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Integration& a, Integration& b) {
    a.Swap(&b);
  }
  inline void Swap(Integration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Integration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Integration* New() const final {
    return new Integration();
  }

  Integration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Integration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Integration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Integration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Integration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.Integration";
  }
  protected:
  explicit Integration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kMetadataFieldNumber = 6,
    kIdFieldNumber = 1,
    kNameFieldNumber = 3,
    kUserIdFieldNumber = 7,
    kProviderFieldNumber = 4,
    kAccountFieldNumber = 8,
    kOrganizationIdFieldNumber = 2,
  };
  // map<string, string> data = 5 [json_name = "data"];
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_data();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_data();

  // map<string, string> metadata = 6 [json_name = "metadata"];
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 3 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string user_id = 7 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .source.v1alpha1.Provider provider = 4 [json_name = "provider"];
  bool has_provider() const;
  private:
  bool _internal_has_provider() const;
  public:
  void clear_provider();
  const ::source::v1alpha1::Provider& provider() const;
  PROTOBUF_MUST_USE_RESULT ::source::v1alpha1::Provider* release_provider();
  ::source::v1alpha1::Provider* mutable_provider();
  void set_allocated_provider(::source::v1alpha1::Provider* provider);
  private:
  const ::source::v1alpha1::Provider& _internal_provider() const;
  ::source::v1alpha1::Provider* _internal_mutable_provider();
  public:
  void unsafe_arena_set_allocated_provider(
      ::source::v1alpha1::Provider* provider);
  ::source::v1alpha1::Provider* unsafe_arena_release_provider();

  // .source.v1alpha1.AccountIntegration account = 8 [json_name = "account"];
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  const ::source::v1alpha1::AccountIntegration& account() const;
  PROTOBUF_MUST_USE_RESULT ::source::v1alpha1::AccountIntegration* release_account();
  ::source::v1alpha1::AccountIntegration* mutable_account();
  void set_allocated_account(::source::v1alpha1::AccountIntegration* account);
  private:
  const ::source::v1alpha1::AccountIntegration& _internal_account() const;
  ::source::v1alpha1::AccountIntegration* _internal_mutable_account();
  public:
  void unsafe_arena_set_allocated_account(
      ::source::v1alpha1::AccountIntegration* account);
  ::source::v1alpha1::AccountIntegration* unsafe_arena_release_account();

  // uint32 organization_id = 2 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.Integration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Integration_DataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> data_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Integration_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::source::v1alpha1::Provider* provider_;
  ::source::v1alpha1::AccountIntegration* account_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class Repository final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.Repository) */ {
 public:
  inline Repository() : Repository(nullptr) {}
  ~Repository() override;
  explicit constexpr Repository(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Repository(const Repository& from);
  Repository(Repository&& from) noexcept
    : Repository() {
    *this = ::std::move(from);
  }

  inline Repository& operator=(const Repository& from) {
    CopyFrom(from);
    return *this;
  }
  inline Repository& operator=(Repository&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Repository& default_instance() {
    return *internal_default_instance();
  }
  static inline const Repository* internal_default_instance() {
    return reinterpret_cast<const Repository*>(
               &_Repository_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Repository& a, Repository& b) {
    a.Swap(&b);
  }
  inline void Swap(Repository* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Repository* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Repository* New() const final {
    return new Repository();
  }

  Repository* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Repository>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Repository& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Repository& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Repository* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.Repository";
  }
  protected:
  explicit Repository(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFullnameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kCloneUrlFieldNumber = 6,
    kBranchFieldNumber = 7,
    kPrivateFieldNumber = 2,
    kForkFieldNumber = 5,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string fullname = 3 [json_name = "fullname"];
  void clear_fullname();
  const std::string& fullname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fullname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fullname();
  PROTOBUF_MUST_USE_RESULT std::string* release_fullname();
  void set_allocated_fullname(std::string* fullname);
  private:
  const std::string& _internal_fullname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fullname(const std::string& value);
  std::string* _internal_mutable_fullname();
  public:

  // string description = 4 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string clone_url = 6 [json_name = "cloneUrl"];
  void clear_clone_url();
  const std::string& clone_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clone_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clone_url();
  PROTOBUF_MUST_USE_RESULT std::string* release_clone_url();
  void set_allocated_clone_url(std::string* clone_url);
  private:
  const std::string& _internal_clone_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clone_url(const std::string& value);
  std::string* _internal_mutable_clone_url();
  public:

  // string branch = 7 [json_name = "branch"];
  void clear_branch();
  const std::string& branch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_branch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_branch();
  PROTOBUF_MUST_USE_RESULT std::string* release_branch();
  void set_allocated_branch(std::string* branch);
  private:
  const std::string& _internal_branch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_branch(const std::string& value);
  std::string* _internal_mutable_branch();
  public:

  // bool private = 2 [json_name = "private"];
  void clear_private_();
  bool private_() const;
  void set_private_(bool value);
  private:
  bool _internal_private_() const;
  void _internal_set_private_(bool value);
  public:

  // bool fork = 5 [json_name = "fork"];
  void clear_fork();
  bool fork() const;
  void set_fork(bool value);
  private:
  bool _internal_fork() const;
  void _internal_set_fork(bool value);
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.Repository)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fullname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clone_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr branch_;
  bool private__;
  bool fork_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class AccountIntegration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.AccountIntegration) */ {
 public:
  inline AccountIntegration() : AccountIntegration(nullptr) {}
  ~AccountIntegration() override;
  explicit constexpr AccountIntegration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountIntegration(const AccountIntegration& from);
  AccountIntegration(AccountIntegration&& from) noexcept
    : AccountIntegration() {
    *this = ::std::move(from);
  }

  inline AccountIntegration& operator=(const AccountIntegration& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountIntegration& operator=(AccountIntegration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountIntegration& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountIntegration* internal_default_instance() {
    return reinterpret_cast<const AccountIntegration*>(
               &_AccountIntegration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(AccountIntegration& a, AccountIntegration& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountIntegration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountIntegration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccountIntegration* New() const final {
    return new AccountIntegration();
  }

  AccountIntegration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountIntegration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountIntegration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountIntegration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountIntegration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.AccountIntegration";
  }
  protected:
  explicit AccountIntegration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string type = 2 [json_name = "type"];
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.AccountIntegration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class CreateIntegrationRequest_DataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateIntegrationRequest_DataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateIntegrationRequest_DataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateIntegrationRequest_DataEntry_DoNotUse();
  explicit constexpr CreateIntegrationRequest_DataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateIntegrationRequest_DataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateIntegrationRequest_DataEntry_DoNotUse& other);
  static const CreateIntegrationRequest_DataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateIntegrationRequest_DataEntry_DoNotUse*>(&_CreateIntegrationRequest_DataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.CreateIntegrationRequest.DataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.CreateIntegrationRequest.DataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class CreateIntegrationRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateIntegrationRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateIntegrationRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateIntegrationRequest_MetadataEntry_DoNotUse();
  explicit constexpr CreateIntegrationRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateIntegrationRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateIntegrationRequest_MetadataEntry_DoNotUse& other);
  static const CreateIntegrationRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateIntegrationRequest_MetadataEntry_DoNotUse*>(&_CreateIntegrationRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.CreateIntegrationRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.CreateIntegrationRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class CreateIntegrationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.CreateIntegrationRequest) */ {
 public:
  inline CreateIntegrationRequest() : CreateIntegrationRequest(nullptr) {}
  ~CreateIntegrationRequest() override;
  explicit constexpr CreateIntegrationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateIntegrationRequest(const CreateIntegrationRequest& from);
  CreateIntegrationRequest(CreateIntegrationRequest&& from) noexcept
    : CreateIntegrationRequest() {
    *this = ::std::move(from);
  }

  inline CreateIntegrationRequest& operator=(const CreateIntegrationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateIntegrationRequest& operator=(CreateIntegrationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateIntegrationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateIntegrationRequest* internal_default_instance() {
    return reinterpret_cast<const CreateIntegrationRequest*>(
               &_CreateIntegrationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CreateIntegrationRequest& a, CreateIntegrationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateIntegrationRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateIntegrationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateIntegrationRequest* New() const final {
    return new CreateIntegrationRequest();
  }

  CreateIntegrationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateIntegrationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateIntegrationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateIntegrationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateIntegrationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.CreateIntegrationRequest";
  }
  protected:
  explicit CreateIntegrationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kMetadataFieldNumber = 6,
    kNameFieldNumber = 3,
    kUserIdFieldNumber = 7,
    kProviderIdFieldNumber = 8,
    kAccountFieldNumber = 9,
    kOrganizationIdFieldNumber = 2,
  };
  // map<string, string> data = 5 [json_name = "data"];
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_data();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_data();

  // map<string, string> metadata = 6 [json_name = "metadata"];
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string name = 3 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string user_id = 7 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string provider_id = 8 [json_name = "providerId"];
  void clear_provider_id();
  const std::string& provider_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_provider_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_provider_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_provider_id();
  void set_allocated_provider_id(std::string* provider_id);
  private:
  const std::string& _internal_provider_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provider_id(const std::string& value);
  std::string* _internal_mutable_provider_id();
  public:

  // .source.v1alpha1.AccountIntegration account = 9 [json_name = "account"];
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  const ::source::v1alpha1::AccountIntegration& account() const;
  PROTOBUF_MUST_USE_RESULT ::source::v1alpha1::AccountIntegration* release_account();
  ::source::v1alpha1::AccountIntegration* mutable_account();
  void set_allocated_account(::source::v1alpha1::AccountIntegration* account);
  private:
  const ::source::v1alpha1::AccountIntegration& _internal_account() const;
  ::source::v1alpha1::AccountIntegration* _internal_mutable_account();
  public:
  void unsafe_arena_set_allocated_account(
      ::source::v1alpha1::AccountIntegration* account);
  ::source::v1alpha1::AccountIntegration* unsafe_arena_release_account();

  // uint32 organization_id = 2 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.CreateIntegrationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CreateIntegrationRequest_DataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> data_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CreateIntegrationRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provider_id_;
  ::source::v1alpha1::AccountIntegration* account_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class CreateIntegrationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.CreateIntegrationResponse) */ {
 public:
  inline CreateIntegrationResponse() : CreateIntegrationResponse(nullptr) {}
  ~CreateIntegrationResponse() override;
  explicit constexpr CreateIntegrationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateIntegrationResponse(const CreateIntegrationResponse& from);
  CreateIntegrationResponse(CreateIntegrationResponse&& from) noexcept
    : CreateIntegrationResponse() {
    *this = ::std::move(from);
  }

  inline CreateIntegrationResponse& operator=(const CreateIntegrationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateIntegrationResponse& operator=(CreateIntegrationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateIntegrationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateIntegrationResponse* internal_default_instance() {
    return reinterpret_cast<const CreateIntegrationResponse*>(
               &_CreateIntegrationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CreateIntegrationResponse& a, CreateIntegrationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateIntegrationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateIntegrationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateIntegrationResponse* New() const final {
    return new CreateIntegrationResponse();
  }

  CreateIntegrationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateIntegrationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateIntegrationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateIntegrationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateIntegrationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.CreateIntegrationResponse";
  }
  protected:
  explicit CreateIntegrationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
    kIntegrationIdFieldNumber = 3,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // string integration_id = 3 [json_name = "integrationId"];
  void clear_integration_id();
  const std::string& integration_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_integration_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_integration_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_integration_id();
  void set_allocated_integration_id(std::string* integration_id);
  private:
  const std::string& _internal_integration_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integration_id(const std::string& value);
  std::string* _internal_mutable_integration_id();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.CreateIntegrationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integration_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class ListIntegrationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.ListIntegrationsRequest) */ {
 public:
  inline ListIntegrationsRequest() : ListIntegrationsRequest(nullptr) {}
  ~ListIntegrationsRequest() override;
  explicit constexpr ListIntegrationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListIntegrationsRequest(const ListIntegrationsRequest& from);
  ListIntegrationsRequest(ListIntegrationsRequest&& from) noexcept
    : ListIntegrationsRequest() {
    *this = ::std::move(from);
  }

  inline ListIntegrationsRequest& operator=(const ListIntegrationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListIntegrationsRequest& operator=(ListIntegrationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListIntegrationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListIntegrationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListIntegrationsRequest*>(
               &_ListIntegrationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ListIntegrationsRequest& a, ListIntegrationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListIntegrationsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListIntegrationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListIntegrationsRequest* New() const final {
    return new ListIntegrationsRequest();
  }

  ListIntegrationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListIntegrationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListIntegrationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListIntegrationsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListIntegrationsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.ListIntegrationsRequest";
  }
  protected:
  explicit ListIntegrationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 1,
  };
  // string user_id = 2 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // uint32 organization_id = 1 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.ListIntegrationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class ListIntegrationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.ListIntegrationsResponse) */ {
 public:
  inline ListIntegrationsResponse() : ListIntegrationsResponse(nullptr) {}
  ~ListIntegrationsResponse() override;
  explicit constexpr ListIntegrationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListIntegrationsResponse(const ListIntegrationsResponse& from);
  ListIntegrationsResponse(ListIntegrationsResponse&& from) noexcept
    : ListIntegrationsResponse() {
    *this = ::std::move(from);
  }

  inline ListIntegrationsResponse& operator=(const ListIntegrationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListIntegrationsResponse& operator=(ListIntegrationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListIntegrationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListIntegrationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListIntegrationsResponse*>(
               &_ListIntegrationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ListIntegrationsResponse& a, ListIntegrationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListIntegrationsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListIntegrationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListIntegrationsResponse* New() const final {
    return new ListIntegrationsResponse();
  }

  ListIntegrationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListIntegrationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListIntegrationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListIntegrationsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListIntegrationsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.ListIntegrationsResponse";
  }
  protected:
  explicit ListIntegrationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntegrationsFieldNumber = 1,
  };
  // repeated .source.v1alpha1.Integration integrations = 1 [json_name = "integrations"];
  int integrations_size() const;
  private:
  int _internal_integrations_size() const;
  public:
  void clear_integrations();
  ::source::v1alpha1::Integration* mutable_integrations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Integration >*
      mutable_integrations();
  private:
  const ::source::v1alpha1::Integration& _internal_integrations(int index) const;
  ::source::v1alpha1::Integration* _internal_add_integrations();
  public:
  const ::source::v1alpha1::Integration& integrations(int index) const;
  ::source::v1alpha1::Integration* add_integrations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Integration >&
      integrations() const;

  // @@protoc_insertion_point(class_scope:source.v1alpha1.ListIntegrationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Integration > integrations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class GetIntegrationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.GetIntegrationRequest) */ {
 public:
  inline GetIntegrationRequest() : GetIntegrationRequest(nullptr) {}
  ~GetIntegrationRequest() override;
  explicit constexpr GetIntegrationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetIntegrationRequest(const GetIntegrationRequest& from);
  GetIntegrationRequest(GetIntegrationRequest&& from) noexcept
    : GetIntegrationRequest() {
    *this = ::std::move(from);
  }

  inline GetIntegrationRequest& operator=(const GetIntegrationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetIntegrationRequest& operator=(GetIntegrationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetIntegrationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetIntegrationRequest* internal_default_instance() {
    return reinterpret_cast<const GetIntegrationRequest*>(
               &_GetIntegrationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GetIntegrationRequest& a, GetIntegrationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetIntegrationRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetIntegrationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetIntegrationRequest* New() const final {
    return new GetIntegrationRequest();
  }

  GetIntegrationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetIntegrationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetIntegrationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetIntegrationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetIntegrationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.GetIntegrationRequest";
  }
  protected:
  explicit GetIntegrationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.GetIntegrationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class GetIntegrationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.GetIntegrationResponse) */ {
 public:
  inline GetIntegrationResponse() : GetIntegrationResponse(nullptr) {}
  ~GetIntegrationResponse() override;
  explicit constexpr GetIntegrationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetIntegrationResponse(const GetIntegrationResponse& from);
  GetIntegrationResponse(GetIntegrationResponse&& from) noexcept
    : GetIntegrationResponse() {
    *this = ::std::move(from);
  }

  inline GetIntegrationResponse& operator=(const GetIntegrationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetIntegrationResponse& operator=(GetIntegrationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetIntegrationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetIntegrationResponse* internal_default_instance() {
    return reinterpret_cast<const GetIntegrationResponse*>(
               &_GetIntegrationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GetIntegrationResponse& a, GetIntegrationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetIntegrationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetIntegrationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetIntegrationResponse* New() const final {
    return new GetIntegrationResponse();
  }

  GetIntegrationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetIntegrationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetIntegrationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetIntegrationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetIntegrationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.GetIntegrationResponse";
  }
  protected:
  explicit GetIntegrationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntegrationFieldNumber = 1,
  };
  // .source.v1alpha1.Integration integration = 1 [json_name = "integration"];
  bool has_integration() const;
  private:
  bool _internal_has_integration() const;
  public:
  void clear_integration();
  const ::source::v1alpha1::Integration& integration() const;
  PROTOBUF_MUST_USE_RESULT ::source::v1alpha1::Integration* release_integration();
  ::source::v1alpha1::Integration* mutable_integration();
  void set_allocated_integration(::source::v1alpha1::Integration* integration);
  private:
  const ::source::v1alpha1::Integration& _internal_integration() const;
  ::source::v1alpha1::Integration* _internal_mutable_integration();
  public:
  void unsafe_arena_set_allocated_integration(
      ::source::v1alpha1::Integration* integration);
  ::source::v1alpha1::Integration* unsafe_arena_release_integration();

  // @@protoc_insertion_point(class_scope:source.v1alpha1.GetIntegrationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::source::v1alpha1::Integration* integration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class UpdateIntegrationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.UpdateIntegrationRequest) */ {
 public:
  inline UpdateIntegrationRequest() : UpdateIntegrationRequest(nullptr) {}
  ~UpdateIntegrationRequest() override;
  explicit constexpr UpdateIntegrationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateIntegrationRequest(const UpdateIntegrationRequest& from);
  UpdateIntegrationRequest(UpdateIntegrationRequest&& from) noexcept
    : UpdateIntegrationRequest() {
    *this = ::std::move(from);
  }

  inline UpdateIntegrationRequest& operator=(const UpdateIntegrationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateIntegrationRequest& operator=(UpdateIntegrationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateIntegrationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateIntegrationRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateIntegrationRequest*>(
               &_UpdateIntegrationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(UpdateIntegrationRequest& a, UpdateIntegrationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateIntegrationRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateIntegrationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateIntegrationRequest* New() const final {
    return new UpdateIntegrationRequest();
  }

  UpdateIntegrationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateIntegrationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateIntegrationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateIntegrationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateIntegrationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.UpdateIntegrationRequest";
  }
  protected:
  explicit UpdateIntegrationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kIntegrationsFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .source.v1alpha1.CreateIntegrationRequest integrations = 2 [json_name = "integrations"];
  bool has_integrations() const;
  private:
  bool _internal_has_integrations() const;
  public:
  void clear_integrations();
  const ::source::v1alpha1::CreateIntegrationRequest& integrations() const;
  PROTOBUF_MUST_USE_RESULT ::source::v1alpha1::CreateIntegrationRequest* release_integrations();
  ::source::v1alpha1::CreateIntegrationRequest* mutable_integrations();
  void set_allocated_integrations(::source::v1alpha1::CreateIntegrationRequest* integrations);
  private:
  const ::source::v1alpha1::CreateIntegrationRequest& _internal_integrations() const;
  ::source::v1alpha1::CreateIntegrationRequest* _internal_mutable_integrations();
  public:
  void unsafe_arena_set_allocated_integrations(
      ::source::v1alpha1::CreateIntegrationRequest* integrations);
  ::source::v1alpha1::CreateIntegrationRequest* unsafe_arena_release_integrations();

  // @@protoc_insertion_point(class_scope:source.v1alpha1.UpdateIntegrationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::source::v1alpha1::CreateIntegrationRequest* integrations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class UpdateIntegrationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.UpdateIntegrationResponse) */ {
 public:
  inline UpdateIntegrationResponse() : UpdateIntegrationResponse(nullptr) {}
  ~UpdateIntegrationResponse() override;
  explicit constexpr UpdateIntegrationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateIntegrationResponse(const UpdateIntegrationResponse& from);
  UpdateIntegrationResponse(UpdateIntegrationResponse&& from) noexcept
    : UpdateIntegrationResponse() {
    *this = ::std::move(from);
  }

  inline UpdateIntegrationResponse& operator=(const UpdateIntegrationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateIntegrationResponse& operator=(UpdateIntegrationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateIntegrationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateIntegrationResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateIntegrationResponse*>(
               &_UpdateIntegrationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(UpdateIntegrationResponse& a, UpdateIntegrationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateIntegrationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateIntegrationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateIntegrationResponse* New() const final {
    return new UpdateIntegrationResponse();
  }

  UpdateIntegrationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateIntegrationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateIntegrationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateIntegrationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateIntegrationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.UpdateIntegrationResponse";
  }
  protected:
  explicit UpdateIntegrationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.UpdateIntegrationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class DeleteIntegrationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.DeleteIntegrationRequest) */ {
 public:
  inline DeleteIntegrationRequest() : DeleteIntegrationRequest(nullptr) {}
  ~DeleteIntegrationRequest() override;
  explicit constexpr DeleteIntegrationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteIntegrationRequest(const DeleteIntegrationRequest& from);
  DeleteIntegrationRequest(DeleteIntegrationRequest&& from) noexcept
    : DeleteIntegrationRequest() {
    *this = ::std::move(from);
  }

  inline DeleteIntegrationRequest& operator=(const DeleteIntegrationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteIntegrationRequest& operator=(DeleteIntegrationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteIntegrationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteIntegrationRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteIntegrationRequest*>(
               &_DeleteIntegrationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(DeleteIntegrationRequest& a, DeleteIntegrationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteIntegrationRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteIntegrationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteIntegrationRequest* New() const final {
    return new DeleteIntegrationRequest();
  }

  DeleteIntegrationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteIntegrationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteIntegrationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteIntegrationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteIntegrationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.DeleteIntegrationRequest";
  }
  protected:
  explicit DeleteIntegrationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.DeleteIntegrationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class DeleteIntegrationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.DeleteIntegrationResponse) */ {
 public:
  inline DeleteIntegrationResponse() : DeleteIntegrationResponse(nullptr) {}
  ~DeleteIntegrationResponse() override;
  explicit constexpr DeleteIntegrationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteIntegrationResponse(const DeleteIntegrationResponse& from);
  DeleteIntegrationResponse(DeleteIntegrationResponse&& from) noexcept
    : DeleteIntegrationResponse() {
    *this = ::std::move(from);
  }

  inline DeleteIntegrationResponse& operator=(const DeleteIntegrationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteIntegrationResponse& operator=(DeleteIntegrationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteIntegrationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteIntegrationResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteIntegrationResponse*>(
               &_DeleteIntegrationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(DeleteIntegrationResponse& a, DeleteIntegrationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteIntegrationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteIntegrationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteIntegrationResponse* New() const final {
    return new DeleteIntegrationResponse();
  }

  DeleteIntegrationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteIntegrationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteIntegrationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteIntegrationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteIntegrationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.DeleteIntegrationResponse";
  }
  protected:
  explicit DeleteIntegrationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.DeleteIntegrationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class Provider_DataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Provider_DataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Provider_DataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Provider_DataEntry_DoNotUse();
  explicit constexpr Provider_DataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Provider_DataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Provider_DataEntry_DoNotUse& other);
  static const Provider_DataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Provider_DataEntry_DoNotUse*>(&_Provider_DataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.Provider.DataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.Provider.DataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Provider_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Provider_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Provider_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Provider_MetadataEntry_DoNotUse();
  explicit constexpr Provider_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Provider_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Provider_MetadataEntry_DoNotUse& other);
  static const Provider_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Provider_MetadataEntry_DoNotUse*>(&_Provider_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.Provider.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.Provider.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Provider final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.Provider) */ {
 public:
  inline Provider() : Provider(nullptr) {}
  ~Provider() override;
  explicit constexpr Provider(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Provider(const Provider& from);
  Provider(Provider&& from) noexcept
    : Provider() {
    *this = ::std::move(from);
  }

  inline Provider& operator=(const Provider& from) {
    CopyFrom(from);
    return *this;
  }
  inline Provider& operator=(Provider&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Provider& default_instance() {
    return *internal_default_instance();
  }
  static inline const Provider* internal_default_instance() {
    return reinterpret_cast<const Provider*>(
               &_Provider_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(Provider& a, Provider& b) {
    a.Swap(&b);
  }
  inline void Swap(Provider* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Provider* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Provider* New() const final {
    return new Provider();
  }

  Provider* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Provider>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Provider& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Provider& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Provider* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.Provider";
  }
  protected:
  explicit Provider(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kMetadataFieldNumber = 6,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kLogoFieldNumber = 4,
  };
  // map<string, string> data = 5 [json_name = "data"];
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_data();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_data();

  // map<string, string> metadata = 6 [json_name = "metadata"];
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string logo = 4 [json_name = "logo"];
  void clear_logo();
  const std::string& logo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logo();
  PROTOBUF_MUST_USE_RESULT std::string* release_logo();
  void set_allocated_logo(std::string* logo);
  private:
  const std::string& _internal_logo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logo(const std::string& value);
  std::string* _internal_mutable_logo();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.Provider)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Provider_DataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> data_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Provider_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class DeleteProviderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.DeleteProviderRequest) */ {
 public:
  inline DeleteProviderRequest() : DeleteProviderRequest(nullptr) {}
  ~DeleteProviderRequest() override;
  explicit constexpr DeleteProviderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteProviderRequest(const DeleteProviderRequest& from);
  DeleteProviderRequest(DeleteProviderRequest&& from) noexcept
    : DeleteProviderRequest() {
    *this = ::std::move(from);
  }

  inline DeleteProviderRequest& operator=(const DeleteProviderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteProviderRequest& operator=(DeleteProviderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteProviderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteProviderRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteProviderRequest*>(
               &_DeleteProviderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(DeleteProviderRequest& a, DeleteProviderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteProviderRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteProviderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteProviderRequest* New() const final {
    return new DeleteProviderRequest();
  }

  DeleteProviderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteProviderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteProviderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteProviderRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteProviderRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.DeleteProviderRequest";
  }
  protected:
  explicit DeleteProviderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.DeleteProviderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class DeleteProviderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.DeleteProviderResponse) */ {
 public:
  inline DeleteProviderResponse() : DeleteProviderResponse(nullptr) {}
  ~DeleteProviderResponse() override;
  explicit constexpr DeleteProviderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteProviderResponse(const DeleteProviderResponse& from);
  DeleteProviderResponse(DeleteProviderResponse&& from) noexcept
    : DeleteProviderResponse() {
    *this = ::std::move(from);
  }

  inline DeleteProviderResponse& operator=(const DeleteProviderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteProviderResponse& operator=(DeleteProviderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteProviderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteProviderResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteProviderResponse*>(
               &_DeleteProviderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(DeleteProviderResponse& a, DeleteProviderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteProviderResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteProviderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteProviderResponse* New() const final {
    return new DeleteProviderResponse();
  }

  DeleteProviderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteProviderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteProviderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteProviderResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteProviderResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.DeleteProviderResponse";
  }
  protected:
  explicit DeleteProviderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.DeleteProviderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class UpdateProviderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.UpdateProviderRequest) */ {
 public:
  inline UpdateProviderRequest() : UpdateProviderRequest(nullptr) {}
  ~UpdateProviderRequest() override;
  explicit constexpr UpdateProviderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateProviderRequest(const UpdateProviderRequest& from);
  UpdateProviderRequest(UpdateProviderRequest&& from) noexcept
    : UpdateProviderRequest() {
    *this = ::std::move(from);
  }

  inline UpdateProviderRequest& operator=(const UpdateProviderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateProviderRequest& operator=(UpdateProviderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateProviderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateProviderRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateProviderRequest*>(
               &_UpdateProviderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(UpdateProviderRequest& a, UpdateProviderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateProviderRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateProviderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateProviderRequest* New() const final {
    return new UpdateProviderRequest();
  }

  UpdateProviderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateProviderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateProviderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateProviderRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateProviderRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.UpdateProviderRequest";
  }
  protected:
  explicit UpdateProviderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kProviderFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .source.v1alpha1.CreateProviderRequest provider = 2 [json_name = "provider"];
  bool has_provider() const;
  private:
  bool _internal_has_provider() const;
  public:
  void clear_provider();
  const ::source::v1alpha1::CreateProviderRequest& provider() const;
  PROTOBUF_MUST_USE_RESULT ::source::v1alpha1::CreateProviderRequest* release_provider();
  ::source::v1alpha1::CreateProviderRequest* mutable_provider();
  void set_allocated_provider(::source::v1alpha1::CreateProviderRequest* provider);
  private:
  const ::source::v1alpha1::CreateProviderRequest& _internal_provider() const;
  ::source::v1alpha1::CreateProviderRequest* _internal_mutable_provider();
  public:
  void unsafe_arena_set_allocated_provider(
      ::source::v1alpha1::CreateProviderRequest* provider);
  ::source::v1alpha1::CreateProviderRequest* unsafe_arena_release_provider();

  // @@protoc_insertion_point(class_scope:source.v1alpha1.UpdateProviderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::source::v1alpha1::CreateProviderRequest* provider_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class UpdateProviderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.UpdateProviderResponse) */ {
 public:
  inline UpdateProviderResponse() : UpdateProviderResponse(nullptr) {}
  ~UpdateProviderResponse() override;
  explicit constexpr UpdateProviderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateProviderResponse(const UpdateProviderResponse& from);
  UpdateProviderResponse(UpdateProviderResponse&& from) noexcept
    : UpdateProviderResponse() {
    *this = ::std::move(from);
  }

  inline UpdateProviderResponse& operator=(const UpdateProviderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateProviderResponse& operator=(UpdateProviderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateProviderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateProviderResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateProviderResponse*>(
               &_UpdateProviderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(UpdateProviderResponse& a, UpdateProviderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateProviderResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateProviderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateProviderResponse* New() const final {
    return new UpdateProviderResponse();
  }

  UpdateProviderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateProviderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateProviderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateProviderResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateProviderResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.UpdateProviderResponse";
  }
  protected:
  explicit UpdateProviderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.UpdateProviderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class GetProviderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.GetProviderRequest) */ {
 public:
  inline GetProviderRequest() : GetProviderRequest(nullptr) {}
  ~GetProviderRequest() override;
  explicit constexpr GetProviderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProviderRequest(const GetProviderRequest& from);
  GetProviderRequest(GetProviderRequest&& from) noexcept
    : GetProviderRequest() {
    *this = ::std::move(from);
  }

  inline GetProviderRequest& operator=(const GetProviderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProviderRequest& operator=(GetProviderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProviderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProviderRequest* internal_default_instance() {
    return reinterpret_cast<const GetProviderRequest*>(
               &_GetProviderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(GetProviderRequest& a, GetProviderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProviderRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProviderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProviderRequest* New() const final {
    return new GetProviderRequest();
  }

  GetProviderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProviderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProviderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetProviderRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProviderRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.GetProviderRequest";
  }
  protected:
  explicit GetProviderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.GetProviderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class GetProviderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.GetProviderResponse) */ {
 public:
  inline GetProviderResponse() : GetProviderResponse(nullptr) {}
  ~GetProviderResponse() override;
  explicit constexpr GetProviderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProviderResponse(const GetProviderResponse& from);
  GetProviderResponse(GetProviderResponse&& from) noexcept
    : GetProviderResponse() {
    *this = ::std::move(from);
  }

  inline GetProviderResponse& operator=(const GetProviderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProviderResponse& operator=(GetProviderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProviderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProviderResponse* internal_default_instance() {
    return reinterpret_cast<const GetProviderResponse*>(
               &_GetProviderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(GetProviderResponse& a, GetProviderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProviderResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProviderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProviderResponse* New() const final {
    return new GetProviderResponse();
  }

  GetProviderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProviderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProviderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetProviderResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProviderResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.GetProviderResponse";
  }
  protected:
  explicit GetProviderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProviderFieldNumber = 1,
  };
  // .source.v1alpha1.Provider provider = 1 [json_name = "provider"];
  bool has_provider() const;
  private:
  bool _internal_has_provider() const;
  public:
  void clear_provider();
  const ::source::v1alpha1::Provider& provider() const;
  PROTOBUF_MUST_USE_RESULT ::source::v1alpha1::Provider* release_provider();
  ::source::v1alpha1::Provider* mutable_provider();
  void set_allocated_provider(::source::v1alpha1::Provider* provider);
  private:
  const ::source::v1alpha1::Provider& _internal_provider() const;
  ::source::v1alpha1::Provider* _internal_mutable_provider();
  public:
  void unsafe_arena_set_allocated_provider(
      ::source::v1alpha1::Provider* provider);
  ::source::v1alpha1::Provider* unsafe_arena_release_provider();

  // @@protoc_insertion_point(class_scope:source.v1alpha1.GetProviderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::source::v1alpha1::Provider* provider_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class CreateProviderRequest_DataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateProviderRequest_DataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateProviderRequest_DataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateProviderRequest_DataEntry_DoNotUse();
  explicit constexpr CreateProviderRequest_DataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateProviderRequest_DataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateProviderRequest_DataEntry_DoNotUse& other);
  static const CreateProviderRequest_DataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateProviderRequest_DataEntry_DoNotUse*>(&_CreateProviderRequest_DataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.CreateProviderRequest.DataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.CreateProviderRequest.DataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class CreateProviderRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateProviderRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateProviderRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateProviderRequest_MetadataEntry_DoNotUse();
  explicit constexpr CreateProviderRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateProviderRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateProviderRequest_MetadataEntry_DoNotUse& other);
  static const CreateProviderRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateProviderRequest_MetadataEntry_DoNotUse*>(&_CreateProviderRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.CreateProviderRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "source.v1alpha1.CreateProviderRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class CreateProviderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.CreateProviderRequest) */ {
 public:
  inline CreateProviderRequest() : CreateProviderRequest(nullptr) {}
  ~CreateProviderRequest() override;
  explicit constexpr CreateProviderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateProviderRequest(const CreateProviderRequest& from);
  CreateProviderRequest(CreateProviderRequest&& from) noexcept
    : CreateProviderRequest() {
    *this = ::std::move(from);
  }

  inline CreateProviderRequest& operator=(const CreateProviderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateProviderRequest& operator=(CreateProviderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateProviderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateProviderRequest* internal_default_instance() {
    return reinterpret_cast<const CreateProviderRequest*>(
               &_CreateProviderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(CreateProviderRequest& a, CreateProviderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateProviderRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateProviderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateProviderRequest* New() const final {
    return new CreateProviderRequest();
  }

  CreateProviderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateProviderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateProviderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateProviderRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateProviderRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.CreateProviderRequest";
  }
  protected:
  explicit CreateProviderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kMetadataFieldNumber = 6,
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kLogoFieldNumber = 3,
  };
  // map<string, string> data = 5 [json_name = "data"];
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_data();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_data();

  // map<string, string> metadata = 6 [json_name = "metadata"];
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string logo = 3 [json_name = "logo"];
  void clear_logo();
  const std::string& logo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logo();
  PROTOBUF_MUST_USE_RESULT std::string* release_logo();
  void set_allocated_logo(std::string* logo);
  private:
  const std::string& _internal_logo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logo(const std::string& value);
  std::string* _internal_mutable_logo();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.CreateProviderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CreateProviderRequest_DataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> data_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CreateProviderRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class CreateProviderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.CreateProviderResponse) */ {
 public:
  inline CreateProviderResponse() : CreateProviderResponse(nullptr) {}
  ~CreateProviderResponse() override;
  explicit constexpr CreateProviderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateProviderResponse(const CreateProviderResponse& from);
  CreateProviderResponse(CreateProviderResponse&& from) noexcept
    : CreateProviderResponse() {
    *this = ::std::move(from);
  }

  inline CreateProviderResponse& operator=(const CreateProviderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateProviderResponse& operator=(CreateProviderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateProviderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateProviderResponse* internal_default_instance() {
    return reinterpret_cast<const CreateProviderResponse*>(
               &_CreateProviderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(CreateProviderResponse& a, CreateProviderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateProviderResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateProviderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateProviderResponse* New() const final {
    return new CreateProviderResponse();
  }

  CreateProviderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateProviderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateProviderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateProviderResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateProviderResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.CreateProviderResponse";
  }
  protected:
  explicit CreateProviderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.CreateProviderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class ListProvidersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.ListProvidersRequest) */ {
 public:
  inline ListProvidersRequest() : ListProvidersRequest(nullptr) {}
  ~ListProvidersRequest() override;
  explicit constexpr ListProvidersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListProvidersRequest(const ListProvidersRequest& from);
  ListProvidersRequest(ListProvidersRequest&& from) noexcept
    : ListProvidersRequest() {
    *this = ::std::move(from);
  }

  inline ListProvidersRequest& operator=(const ListProvidersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListProvidersRequest& operator=(ListProvidersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListProvidersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListProvidersRequest* internal_default_instance() {
    return reinterpret_cast<const ListProvidersRequest*>(
               &_ListProvidersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ListProvidersRequest& a, ListProvidersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListProvidersRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListProvidersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListProvidersRequest* New() const final {
    return new ListProvidersRequest();
  }

  ListProvidersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListProvidersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListProvidersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListProvidersRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListProvidersRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.ListProvidersRequest";
  }
  protected:
  explicit ListProvidersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:source.v1alpha1.ListProvidersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// -------------------------------------------------------------------

class ListProvidersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:source.v1alpha1.ListProvidersResponse) */ {
 public:
  inline ListProvidersResponse() : ListProvidersResponse(nullptr) {}
  ~ListProvidersResponse() override;
  explicit constexpr ListProvidersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListProvidersResponse(const ListProvidersResponse& from);
  ListProvidersResponse(ListProvidersResponse&& from) noexcept
    : ListProvidersResponse() {
    *this = ::std::move(from);
  }

  inline ListProvidersResponse& operator=(const ListProvidersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListProvidersResponse& operator=(ListProvidersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListProvidersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListProvidersResponse* internal_default_instance() {
    return reinterpret_cast<const ListProvidersResponse*>(
               &_ListProvidersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(ListProvidersResponse& a, ListProvidersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListProvidersResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListProvidersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListProvidersResponse* New() const final {
    return new ListProvidersResponse();
  }

  ListProvidersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListProvidersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListProvidersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListProvidersResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListProvidersResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "source.v1alpha1.ListProvidersResponse";
  }
  protected:
  explicit ListProvidersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProvidersFieldNumber = 1,
    kTotalPagesFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // repeated .source.v1alpha1.Provider providers = 1 [json_name = "providers"];
  int providers_size() const;
  private:
  int _internal_providers_size() const;
  public:
  void clear_providers();
  ::source::v1alpha1::Provider* mutable_providers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Provider >*
      mutable_providers();
  private:
  const ::source::v1alpha1::Provider& _internal_providers(int index) const;
  ::source::v1alpha1::Provider* _internal_add_providers();
  public:
  const ::source::v1alpha1::Provider& providers(int index) const;
  ::source::v1alpha1::Provider* add_providers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Provider >&
      providers() const;

  // uint32 total_pages = 2 [json_name = "totalPages"];
  void clear_total_pages();
  ::PROTOBUF_NAMESPACE_ID::uint32 total_pages() const;
  void set_total_pages(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_total_pages() const;
  void _internal_set_total_pages(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 count = 3 [json_name = "count"];
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:source.v1alpha1.ListProvidersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Provider > providers_;
  ::PROTOBUF_NAMESPACE_ID::uint32 total_pages_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fv1alpha1_2fsource_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AccountProvider

// string name = 1 [json_name = "name"];
inline void AccountProvider::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& AccountProvider::name() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.AccountProvider.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountProvider::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.AccountProvider.name)
}
inline std::string* AccountProvider::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.AccountProvider.name)
  return _s;
}
inline const std::string& AccountProvider::_internal_name() const {
  return name_.Get();
}
inline void AccountProvider::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountProvider::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountProvider::release_name() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.AccountProvider.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountProvider::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.AccountProvider.name)
}

// string type = 2 [json_name = "type"];
inline void AccountProvider::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& AccountProvider::type() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.AccountProvider.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountProvider::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.AccountProvider.type)
}
inline std::string* AccountProvider::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.AccountProvider.type)
  return _s;
}
inline const std::string& AccountProvider::_internal_type() const {
  return type_.Get();
}
inline void AccountProvider::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountProvider::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountProvider::release_type() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.AccountProvider.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountProvider::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.AccountProvider.type)
}

// -------------------------------------------------------------------

// AccountsProvidersRequest

// string integration_id = 1 [json_name = "integrationId"];
inline void AccountsProvidersRequest::clear_integration_id() {
  integration_id_.ClearToEmpty();
}
inline const std::string& AccountsProvidersRequest::integration_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.AccountsProvidersRequest.integration_id)
  return _internal_integration_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountsProvidersRequest::set_integration_id(ArgT0&& arg0, ArgT... args) {
 
 integration_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.AccountsProvidersRequest.integration_id)
}
inline std::string* AccountsProvidersRequest::mutable_integration_id() {
  std::string* _s = _internal_mutable_integration_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.AccountsProvidersRequest.integration_id)
  return _s;
}
inline const std::string& AccountsProvidersRequest::_internal_integration_id() const {
  return integration_id_.Get();
}
inline void AccountsProvidersRequest::_internal_set_integration_id(const std::string& value) {
  
  integration_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountsProvidersRequest::_internal_mutable_integration_id() {
  
  return integration_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountsProvidersRequest::release_integration_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.AccountsProvidersRequest.integration_id)
  return integration_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountsProvidersRequest::set_allocated_integration_id(std::string* integration_id) {
  if (integration_id != nullptr) {
    
  } else {
    
  }
  integration_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), integration_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.AccountsProvidersRequest.integration_id)
}

// uint32 page = 2 [json_name = "page"];
inline void AccountsProvidersRequest::clear_page() {
  page_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountsProvidersRequest::_internal_page() const {
  return page_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountsProvidersRequest::page() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.AccountsProvidersRequest.page)
  return _internal_page();
}
inline void AccountsProvidersRequest::_internal_set_page(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  page_ = value;
}
inline void AccountsProvidersRequest::set_page(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.AccountsProvidersRequest.page)
}

// -------------------------------------------------------------------

// AccountsProvidersResponse

// repeated .source.v1alpha1.AccountProvider accounts = 1 [json_name = "accounts"];
inline int AccountsProvidersResponse::_internal_accounts_size() const {
  return accounts_.size();
}
inline int AccountsProvidersResponse::accounts_size() const {
  return _internal_accounts_size();
}
inline void AccountsProvidersResponse::clear_accounts() {
  accounts_.Clear();
}
inline ::source::v1alpha1::AccountProvider* AccountsProvidersResponse::mutable_accounts(int index) {
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.AccountsProvidersResponse.accounts)
  return accounts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::AccountProvider >*
AccountsProvidersResponse::mutable_accounts() {
  // @@protoc_insertion_point(field_mutable_list:source.v1alpha1.AccountsProvidersResponse.accounts)
  return &accounts_;
}
inline const ::source::v1alpha1::AccountProvider& AccountsProvidersResponse::_internal_accounts(int index) const {
  return accounts_.Get(index);
}
inline const ::source::v1alpha1::AccountProvider& AccountsProvidersResponse::accounts(int index) const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.AccountsProvidersResponse.accounts)
  return _internal_accounts(index);
}
inline ::source::v1alpha1::AccountProvider* AccountsProvidersResponse::_internal_add_accounts() {
  return accounts_.Add();
}
inline ::source::v1alpha1::AccountProvider* AccountsProvidersResponse::add_accounts() {
  ::source::v1alpha1::AccountProvider* _add = _internal_add_accounts();
  // @@protoc_insertion_point(field_add:source.v1alpha1.AccountsProvidersResponse.accounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::AccountProvider >&
AccountsProvidersResponse::accounts() const {
  // @@protoc_insertion_point(field_list:source.v1alpha1.AccountsProvidersResponse.accounts)
  return accounts_;
}

// uint32 count = 2 [json_name = "count"];
inline void AccountsProvidersResponse::clear_count() {
  count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountsProvidersResponse::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountsProvidersResponse::count() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.AccountsProvidersResponse.count)
  return _internal_count();
}
inline void AccountsProvidersResponse::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  count_ = value;
}
inline void AccountsProvidersResponse::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.AccountsProvidersResponse.count)
}

// uint32 total_pages = 3 [json_name = "totalPages"];
inline void AccountsProvidersResponse::clear_total_pages() {
  total_pages_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountsProvidersResponse::_internal_total_pages() const {
  return total_pages_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountsProvidersResponse::total_pages() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.AccountsProvidersResponse.total_pages)
  return _internal_total_pages();
}
inline void AccountsProvidersResponse::_internal_set_total_pages(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  total_pages_ = value;
}
inline void AccountsProvidersResponse::set_total_pages(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_total_pages(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.AccountsProvidersResponse.total_pages)
}

// -------------------------------------------------------------------

// DeleteIntegrationsByOrganizationRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void DeleteIntegrationsByOrganizationRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteIntegrationsByOrganizationRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteIntegrationsByOrganizationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DeleteIntegrationsByOrganizationRequest.organization_id)
  return _internal_organization_id();
}
inline void DeleteIntegrationsByOrganizationRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void DeleteIntegrationsByOrganizationRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.DeleteIntegrationsByOrganizationRequest.organization_id)
}

// -------------------------------------------------------------------

// DeleteIntegrationsByOrganizationResponse

// string msg = 1 [json_name = "msg"];
inline void DeleteIntegrationsByOrganizationResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& DeleteIntegrationsByOrganizationResponse::msg() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DeleteIntegrationsByOrganizationResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteIntegrationsByOrganizationResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DeleteIntegrationsByOrganizationResponse.msg)
}
inline std::string* DeleteIntegrationsByOrganizationResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DeleteIntegrationsByOrganizationResponse.msg)
  return _s;
}
inline const std::string& DeleteIntegrationsByOrganizationResponse::_internal_msg() const {
  return msg_.Get();
}
inline void DeleteIntegrationsByOrganizationResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteIntegrationsByOrganizationResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteIntegrationsByOrganizationResponse::release_msg() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DeleteIntegrationsByOrganizationResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteIntegrationsByOrganizationResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DeleteIntegrationsByOrganizationResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void DeleteIntegrationsByOrganizationResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& DeleteIntegrationsByOrganizationResponse::error() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DeleteIntegrationsByOrganizationResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteIntegrationsByOrganizationResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DeleteIntegrationsByOrganizationResponse.error)
}
inline std::string* DeleteIntegrationsByOrganizationResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DeleteIntegrationsByOrganizationResponse.error)
  return _s;
}
inline const std::string& DeleteIntegrationsByOrganizationResponse::_internal_error() const {
  return error_.Get();
}
inline void DeleteIntegrationsByOrganizationResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteIntegrationsByOrganizationResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteIntegrationsByOrganizationResponse::release_error() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DeleteIntegrationsByOrganizationResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteIntegrationsByOrganizationResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DeleteIntegrationsByOrganizationResponse.error)
}

// -------------------------------------------------------------------

// GetOneProviderByNameRequest

// string name = 1 [json_name = "name"];
inline void GetOneProviderByNameRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GetOneProviderByNameRequest::name() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.GetOneProviderByNameRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOneProviderByNameRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.GetOneProviderByNameRequest.name)
}
inline std::string* GetOneProviderByNameRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.GetOneProviderByNameRequest.name)
  return _s;
}
inline const std::string& GetOneProviderByNameRequest::_internal_name() const {
  return name_.Get();
}
inline void GetOneProviderByNameRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOneProviderByNameRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOneProviderByNameRequest::release_name() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.GetOneProviderByNameRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOneProviderByNameRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.GetOneProviderByNameRequest.name)
}

// -------------------------------------------------------------------

// GetOneProviderByNameResponse

// .source.v1alpha1.Provider provider = 1 [json_name = "provider"];
inline bool GetOneProviderByNameResponse::_internal_has_provider() const {
  return this != internal_default_instance() && provider_ != nullptr;
}
inline bool GetOneProviderByNameResponse::has_provider() const {
  return _internal_has_provider();
}
inline void GetOneProviderByNameResponse::clear_provider() {
  if (GetArenaForAllocation() == nullptr && provider_ != nullptr) {
    delete provider_;
  }
  provider_ = nullptr;
}
inline const ::source::v1alpha1::Provider& GetOneProviderByNameResponse::_internal_provider() const {
  const ::source::v1alpha1::Provider* p = provider_;
  return p != nullptr ? *p : reinterpret_cast<const ::source::v1alpha1::Provider&>(
      ::source::v1alpha1::_Provider_default_instance_);
}
inline const ::source::v1alpha1::Provider& GetOneProviderByNameResponse::provider() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.GetOneProviderByNameResponse.provider)
  return _internal_provider();
}
inline void GetOneProviderByNameResponse::unsafe_arena_set_allocated_provider(
    ::source::v1alpha1::Provider* provider) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(provider_);
  }
  provider_ = provider;
  if (provider) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:source.v1alpha1.GetOneProviderByNameResponse.provider)
}
inline ::source::v1alpha1::Provider* GetOneProviderByNameResponse::release_provider() {
  
  ::source::v1alpha1::Provider* temp = provider_;
  provider_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::source::v1alpha1::Provider* GetOneProviderByNameResponse::unsafe_arena_release_provider() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.GetOneProviderByNameResponse.provider)
  
  ::source::v1alpha1::Provider* temp = provider_;
  provider_ = nullptr;
  return temp;
}
inline ::source::v1alpha1::Provider* GetOneProviderByNameResponse::_internal_mutable_provider() {
  
  if (provider_ == nullptr) {
    auto* p = CreateMaybeMessage<::source::v1alpha1::Provider>(GetArenaForAllocation());
    provider_ = p;
  }
  return provider_;
}
inline ::source::v1alpha1::Provider* GetOneProviderByNameResponse::mutable_provider() {
  ::source::v1alpha1::Provider* _msg = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.GetOneProviderByNameResponse.provider)
  return _msg;
}
inline void GetOneProviderByNameResponse::set_allocated_provider(::source::v1alpha1::Provider* provider) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete provider_;
  }
  if (provider) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::source::v1alpha1::Provider>::GetOwningArena(provider);
    if (message_arena != submessage_arena) {
      provider = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, provider, submessage_arena);
    }
    
  } else {
    
  }
  provider_ = provider;
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.GetOneProviderByNameResponse.provider)
}

// -------------------------------------------------------------------

// Branch

// string name = 1 [json_name = "name"];
inline void Branch::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Branch::name() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Branch.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Branch::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.Branch.name)
}
inline std::string* Branch::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Branch.name)
  return _s;
}
inline const std::string& Branch::_internal_name() const {
  return name_.Get();
}
inline void Branch::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Branch::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Branch::release_name() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Branch.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Branch::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Branch.name)
}

// string sha = 2 [json_name = "sha"];
inline void Branch::clear_sha() {
  sha_.ClearToEmpty();
}
inline const std::string& Branch::sha() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Branch.sha)
  return _internal_sha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Branch::set_sha(ArgT0&& arg0, ArgT... args) {
 
 sha_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.Branch.sha)
}
inline std::string* Branch::mutable_sha() {
  std::string* _s = _internal_mutable_sha();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Branch.sha)
  return _s;
}
inline const std::string& Branch::_internal_sha() const {
  return sha_.Get();
}
inline void Branch::_internal_set_sha(const std::string& value) {
  
  sha_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Branch::_internal_mutable_sha() {
  
  return sha_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Branch::release_sha() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Branch.sha)
  return sha_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Branch::set_allocated_sha(std::string* sha) {
  if (sha != nullptr) {
    
  } else {
    
  }
  sha_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sha,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Branch.sha)
}

// string url = 3 [json_name = "url"];
inline void Branch::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& Branch::url() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Branch.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Branch::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.Branch.url)
}
inline std::string* Branch::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Branch.url)
  return _s;
}
inline const std::string& Branch::_internal_url() const {
  return url_.Get();
}
inline void Branch::_internal_set_url(const std::string& value) {
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Branch::_internal_mutable_url() {
  
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Branch::release_url() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Branch.url)
  return url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Branch::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Branch.url)
}

// -------------------------------------------------------------------

// ListRepositoriesProviderRequest

// string integration_id = 1 [json_name = "integrationId"];
inline void ListRepositoriesProviderRequest::clear_integration_id() {
  integration_id_.ClearToEmpty();
}
inline const std::string& ListRepositoriesProviderRequest::integration_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepositoriesProviderRequest.integration_id)
  return _internal_integration_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRepositoriesProviderRequest::set_integration_id(ArgT0&& arg0, ArgT... args) {
 
 integration_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListRepositoriesProviderRequest.integration_id)
}
inline std::string* ListRepositoriesProviderRequest::mutable_integration_id() {
  std::string* _s = _internal_mutable_integration_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.ListRepositoriesProviderRequest.integration_id)
  return _s;
}
inline const std::string& ListRepositoriesProviderRequest::_internal_integration_id() const {
  return integration_id_.Get();
}
inline void ListRepositoriesProviderRequest::_internal_set_integration_id(const std::string& value) {
  
  integration_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListRepositoriesProviderRequest::_internal_mutable_integration_id() {
  
  return integration_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListRepositoriesProviderRequest::release_integration_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.ListRepositoriesProviderRequest.integration_id)
  return integration_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListRepositoriesProviderRequest::set_allocated_integration_id(std::string* integration_id) {
  if (integration_id != nullptr) {
    
  } else {
    
  }
  integration_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), integration_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.ListRepositoriesProviderRequest.integration_id)
}

// uint32 page = 2 [json_name = "page"];
inline void ListRepositoriesProviderRequest::clear_page() {
  page_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRepositoriesProviderRequest::_internal_page() const {
  return page_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRepositoriesProviderRequest::page() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepositoriesProviderRequest.page)
  return _internal_page();
}
inline void ListRepositoriesProviderRequest::_internal_set_page(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  page_ = value;
}
inline void ListRepositoriesProviderRequest::set_page(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListRepositoriesProviderRequest.page)
}

// -------------------------------------------------------------------

// ListRepositoriesProviderResponse

// repeated .source.v1alpha1.Repository repositories = 1 [json_name = "repositories"];
inline int ListRepositoriesProviderResponse::_internal_repositories_size() const {
  return repositories_.size();
}
inline int ListRepositoriesProviderResponse::repositories_size() const {
  return _internal_repositories_size();
}
inline void ListRepositoriesProviderResponse::clear_repositories() {
  repositories_.Clear();
}
inline ::source::v1alpha1::Repository* ListRepositoriesProviderResponse::mutable_repositories(int index) {
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.ListRepositoriesProviderResponse.repositories)
  return repositories_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Repository >*
ListRepositoriesProviderResponse::mutable_repositories() {
  // @@protoc_insertion_point(field_mutable_list:source.v1alpha1.ListRepositoriesProviderResponse.repositories)
  return &repositories_;
}
inline const ::source::v1alpha1::Repository& ListRepositoriesProviderResponse::_internal_repositories(int index) const {
  return repositories_.Get(index);
}
inline const ::source::v1alpha1::Repository& ListRepositoriesProviderResponse::repositories(int index) const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepositoriesProviderResponse.repositories)
  return _internal_repositories(index);
}
inline ::source::v1alpha1::Repository* ListRepositoriesProviderResponse::_internal_add_repositories() {
  return repositories_.Add();
}
inline ::source::v1alpha1::Repository* ListRepositoriesProviderResponse::add_repositories() {
  ::source::v1alpha1::Repository* _add = _internal_add_repositories();
  // @@protoc_insertion_point(field_add:source.v1alpha1.ListRepositoriesProviderResponse.repositories)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Repository >&
ListRepositoriesProviderResponse::repositories() const {
  // @@protoc_insertion_point(field_list:source.v1alpha1.ListRepositoriesProviderResponse.repositories)
  return repositories_;
}

// uint32 total_pages = 2 [json_name = "totalPages"];
inline void ListRepositoriesProviderResponse::clear_total_pages() {
  total_pages_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRepositoriesProviderResponse::_internal_total_pages() const {
  return total_pages_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRepositoriesProviderResponse::total_pages() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepositoriesProviderResponse.total_pages)
  return _internal_total_pages();
}
inline void ListRepositoriesProviderResponse::_internal_set_total_pages(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  total_pages_ = value;
}
inline void ListRepositoriesProviderResponse::set_total_pages(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_total_pages(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListRepositoriesProviderResponse.total_pages)
}

// uint32 count = 3 [json_name = "count"];
inline void ListRepositoriesProviderResponse::clear_count() {
  count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRepositoriesProviderResponse::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRepositoriesProviderResponse::count() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepositoriesProviderResponse.count)
  return _internal_count();
}
inline void ListRepositoriesProviderResponse::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  count_ = value;
}
inline void ListRepositoriesProviderResponse::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListRepositoriesProviderResponse.count)
}

// -------------------------------------------------------------------

// GetRepositoryProviderRequest

// string integration_id = 1 [json_name = "integrationId"];
inline void GetRepositoryProviderRequest::clear_integration_id() {
  integration_id_.ClearToEmpty();
}
inline const std::string& GetRepositoryProviderRequest::integration_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.GetRepositoryProviderRequest.integration_id)
  return _internal_integration_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRepositoryProviderRequest::set_integration_id(ArgT0&& arg0, ArgT... args) {
 
 integration_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.GetRepositoryProviderRequest.integration_id)
}
inline std::string* GetRepositoryProviderRequest::mutable_integration_id() {
  std::string* _s = _internal_mutable_integration_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.GetRepositoryProviderRequest.integration_id)
  return _s;
}
inline const std::string& GetRepositoryProviderRequest::_internal_integration_id() const {
  return integration_id_.Get();
}
inline void GetRepositoryProviderRequest::_internal_set_integration_id(const std::string& value) {
  
  integration_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRepositoryProviderRequest::_internal_mutable_integration_id() {
  
  return integration_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRepositoryProviderRequest::release_integration_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.GetRepositoryProviderRequest.integration_id)
  return integration_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRepositoryProviderRequest::set_allocated_integration_id(std::string* integration_id) {
  if (integration_id != nullptr) {
    
  } else {
    
  }
  integration_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), integration_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.GetRepositoryProviderRequest.integration_id)
}

// string name = 2 [json_name = "name"];
inline void GetRepositoryProviderRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GetRepositoryProviderRequest::name() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.GetRepositoryProviderRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRepositoryProviderRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.GetRepositoryProviderRequest.name)
}
inline std::string* GetRepositoryProviderRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.GetRepositoryProviderRequest.name)
  return _s;
}
inline const std::string& GetRepositoryProviderRequest::_internal_name() const {
  return name_.Get();
}
inline void GetRepositoryProviderRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRepositoryProviderRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRepositoryProviderRequest::release_name() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.GetRepositoryProviderRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRepositoryProviderRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.GetRepositoryProviderRequest.name)
}

// -------------------------------------------------------------------

// GetRepositoryProviderResponse

// repeated .source.v1alpha1.Branch branchs = 1 [json_name = "branchs"];
inline int GetRepositoryProviderResponse::_internal_branchs_size() const {
  return branchs_.size();
}
inline int GetRepositoryProviderResponse::branchs_size() const {
  return _internal_branchs_size();
}
inline void GetRepositoryProviderResponse::clear_branchs() {
  branchs_.Clear();
}
inline ::source::v1alpha1::Branch* GetRepositoryProviderResponse::mutable_branchs(int index) {
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.GetRepositoryProviderResponse.branchs)
  return branchs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Branch >*
GetRepositoryProviderResponse::mutable_branchs() {
  // @@protoc_insertion_point(field_mutable_list:source.v1alpha1.GetRepositoryProviderResponse.branchs)
  return &branchs_;
}
inline const ::source::v1alpha1::Branch& GetRepositoryProviderResponse::_internal_branchs(int index) const {
  return branchs_.Get(index);
}
inline const ::source::v1alpha1::Branch& GetRepositoryProviderResponse::branchs(int index) const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.GetRepositoryProviderResponse.branchs)
  return _internal_branchs(index);
}
inline ::source::v1alpha1::Branch* GetRepositoryProviderResponse::_internal_add_branchs() {
  return branchs_.Add();
}
inline ::source::v1alpha1::Branch* GetRepositoryProviderResponse::add_branchs() {
  ::source::v1alpha1::Branch* _add = _internal_add_branchs();
  // @@protoc_insertion_point(field_add:source.v1alpha1.GetRepositoryProviderResponse.branchs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Branch >&
GetRepositoryProviderResponse::branchs() const {
  // @@protoc_insertion_point(field_list:source.v1alpha1.GetRepositoryProviderResponse.branchs)
  return branchs_;
}

// -------------------------------------------------------------------

// DetailRepository

// string id = 1 [json_name = "id"];
inline void DetailRepository::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DetailRepository::id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DetailRepository.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailRepository::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DetailRepository.id)
}
inline std::string* DetailRepository::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DetailRepository.id)
  return _s;
}
inline const std::string& DetailRepository::_internal_id() const {
  return id_.Get();
}
inline void DetailRepository::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetailRepository::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetailRepository::release_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DetailRepository.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetailRepository::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DetailRepository.id)
}

// string name = 2 [json_name = "name"];
inline void DetailRepository::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& DetailRepository::name() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DetailRepository.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailRepository::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DetailRepository.name)
}
inline std::string* DetailRepository::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DetailRepository.name)
  return _s;
}
inline const std::string& DetailRepository::_internal_name() const {
  return name_.Get();
}
inline void DetailRepository::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetailRepository::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetailRepository::release_name() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DetailRepository.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetailRepository::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DetailRepository.name)
}

// bool private = 3 [json_name = "private"];
inline void DetailRepository::clear_private_() {
  private__ = false;
}
inline bool DetailRepository::_internal_private_() const {
  return private__;
}
inline bool DetailRepository::private_() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DetailRepository.private)
  return _internal_private_();
}
inline void DetailRepository::_internal_set_private_(bool value) {
  
  private__ = value;
}
inline void DetailRepository::set_private_(bool value) {
  _internal_set_private_(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.DetailRepository.private)
}

// string fullname = 4 [json_name = "fullname"];
inline void DetailRepository::clear_fullname() {
  fullname_.ClearToEmpty();
}
inline const std::string& DetailRepository::fullname() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DetailRepository.fullname)
  return _internal_fullname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailRepository::set_fullname(ArgT0&& arg0, ArgT... args) {
 
 fullname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DetailRepository.fullname)
}
inline std::string* DetailRepository::mutable_fullname() {
  std::string* _s = _internal_mutable_fullname();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DetailRepository.fullname)
  return _s;
}
inline const std::string& DetailRepository::_internal_fullname() const {
  return fullname_.Get();
}
inline void DetailRepository::_internal_set_fullname(const std::string& value) {
  
  fullname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetailRepository::_internal_mutable_fullname() {
  
  return fullname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetailRepository::release_fullname() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DetailRepository.fullname)
  return fullname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetailRepository::set_allocated_fullname(std::string* fullname) {
  if (fullname != nullptr) {
    
  } else {
    
  }
  fullname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fullname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DetailRepository.fullname)
}

// string description = 5 [json_name = "description"];
inline void DetailRepository::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& DetailRepository::description() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DetailRepository.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailRepository::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DetailRepository.description)
}
inline std::string* DetailRepository::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DetailRepository.description)
  return _s;
}
inline const std::string& DetailRepository::_internal_description() const {
  return description_.Get();
}
inline void DetailRepository::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetailRepository::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetailRepository::release_description() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DetailRepository.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetailRepository::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DetailRepository.description)
}

// bool fork = 6 [json_name = "fork"];
inline void DetailRepository::clear_fork() {
  fork_ = false;
}
inline bool DetailRepository::_internal_fork() const {
  return fork_;
}
inline bool DetailRepository::fork() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DetailRepository.fork)
  return _internal_fork();
}
inline void DetailRepository::_internal_set_fork(bool value) {
  
  fork_ = value;
}
inline void DetailRepository::set_fork(bool value) {
  _internal_set_fork(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.DetailRepository.fork)
}

// string clone_url = 7 [json_name = "cloneUrl"];
inline void DetailRepository::clear_clone_url() {
  clone_url_.ClearToEmpty();
}
inline const std::string& DetailRepository::clone_url() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DetailRepository.clone_url)
  return _internal_clone_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailRepository::set_clone_url(ArgT0&& arg0, ArgT... args) {
 
 clone_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DetailRepository.clone_url)
}
inline std::string* DetailRepository::mutable_clone_url() {
  std::string* _s = _internal_mutable_clone_url();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DetailRepository.clone_url)
  return _s;
}
inline const std::string& DetailRepository::_internal_clone_url() const {
  return clone_url_.Get();
}
inline void DetailRepository::_internal_set_clone_url(const std::string& value) {
  
  clone_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetailRepository::_internal_mutable_clone_url() {
  
  return clone_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetailRepository::release_clone_url() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DetailRepository.clone_url)
  return clone_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetailRepository::set_allocated_clone_url(std::string* clone_url) {
  if (clone_url != nullptr) {
    
  } else {
    
  }
  clone_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clone_url,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DetailRepository.clone_url)
}

// uint32 project_id = 8 [json_name = "projectId"];
inline void DetailRepository::clear_project_id() {
  project_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DetailRepository::_internal_project_id() const {
  return project_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DetailRepository::project_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DetailRepository.project_id)
  return _internal_project_id();
}
inline void DetailRepository::_internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  project_id_ = value;
}
inline void DetailRepository::set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_project_id(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.DetailRepository.project_id)
}

// uint32 organization_id = 9 [json_name = "organizationId"];
inline void DetailRepository::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DetailRepository::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DetailRepository::organization_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DetailRepository.organization_id)
  return _internal_organization_id();
}
inline void DetailRepository::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void DetailRepository::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.DetailRepository.organization_id)
}

// repeated string branchs = 10 [json_name = "branchs"];
inline int DetailRepository::_internal_branchs_size() const {
  return branchs_.size();
}
inline int DetailRepository::branchs_size() const {
  return _internal_branchs_size();
}
inline void DetailRepository::clear_branchs() {
  branchs_.Clear();
}
inline std::string* DetailRepository::add_branchs() {
  std::string* _s = _internal_add_branchs();
  // @@protoc_insertion_point(field_add_mutable:source.v1alpha1.DetailRepository.branchs)
  return _s;
}
inline const std::string& DetailRepository::_internal_branchs(int index) const {
  return branchs_.Get(index);
}
inline const std::string& DetailRepository::branchs(int index) const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DetailRepository.branchs)
  return _internal_branchs(index);
}
inline std::string* DetailRepository::mutable_branchs(int index) {
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DetailRepository.branchs)
  return branchs_.Mutable(index);
}
inline void DetailRepository::set_branchs(int index, const std::string& value) {
  branchs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.DetailRepository.branchs)
}
inline void DetailRepository::set_branchs(int index, std::string&& value) {
  branchs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:source.v1alpha1.DetailRepository.branchs)
}
inline void DetailRepository::set_branchs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  branchs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:source.v1alpha1.DetailRepository.branchs)
}
inline void DetailRepository::set_branchs(int index, const char* value, size_t size) {
  branchs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:source.v1alpha1.DetailRepository.branchs)
}
inline std::string* DetailRepository::_internal_add_branchs() {
  return branchs_.Add();
}
inline void DetailRepository::add_branchs(const std::string& value) {
  branchs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:source.v1alpha1.DetailRepository.branchs)
}
inline void DetailRepository::add_branchs(std::string&& value) {
  branchs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:source.v1alpha1.DetailRepository.branchs)
}
inline void DetailRepository::add_branchs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  branchs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:source.v1alpha1.DetailRepository.branchs)
}
inline void DetailRepository::add_branchs(const char* value, size_t size) {
  branchs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:source.v1alpha1.DetailRepository.branchs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DetailRepository::branchs() const {
  // @@protoc_insertion_point(field_list:source.v1alpha1.DetailRepository.branchs)
  return branchs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DetailRepository::mutable_branchs() {
  // @@protoc_insertion_point(field_mutable_list:source.v1alpha1.DetailRepository.branchs)
  return &branchs_;
}

// string integration_id = 11 [json_name = "integrationId"];
inline void DetailRepository::clear_integration_id() {
  integration_id_.ClearToEmpty();
}
inline const std::string& DetailRepository::integration_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DetailRepository.integration_id)
  return _internal_integration_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailRepository::set_integration_id(ArgT0&& arg0, ArgT... args) {
 
 integration_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DetailRepository.integration_id)
}
inline std::string* DetailRepository::mutable_integration_id() {
  std::string* _s = _internal_mutable_integration_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DetailRepository.integration_id)
  return _s;
}
inline const std::string& DetailRepository::_internal_integration_id() const {
  return integration_id_.Get();
}
inline void DetailRepository::_internal_set_integration_id(const std::string& value) {
  
  integration_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetailRepository::_internal_mutable_integration_id() {
  
  return integration_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetailRepository::release_integration_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DetailRepository.integration_id)
  return integration_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetailRepository::set_allocated_integration_id(std::string* integration_id) {
  if (integration_id != nullptr) {
    
  } else {
    
  }
  integration_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), integration_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DetailRepository.integration_id)
}

// -------------------------------------------------------------------

// ListRepository

// string id = 1 [json_name = "id"];
inline void ListRepository::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& ListRepository::id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepository.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRepository::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListRepository.id)
}
inline std::string* ListRepository::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.ListRepository.id)
  return _s;
}
inline const std::string& ListRepository::_internal_id() const {
  return id_.Get();
}
inline void ListRepository::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListRepository::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListRepository::release_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.ListRepository.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListRepository::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.ListRepository.id)
}

// string name = 2 [json_name = "name"];
inline void ListRepository::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ListRepository::name() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepository.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRepository::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListRepository.name)
}
inline std::string* ListRepository::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.ListRepository.name)
  return _s;
}
inline const std::string& ListRepository::_internal_name() const {
  return name_.Get();
}
inline void ListRepository::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListRepository::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListRepository::release_name() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.ListRepository.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListRepository::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.ListRepository.name)
}

// bool private = 3 [json_name = "private"];
inline void ListRepository::clear_private_() {
  private__ = false;
}
inline bool ListRepository::_internal_private_() const {
  return private__;
}
inline bool ListRepository::private_() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepository.private)
  return _internal_private_();
}
inline void ListRepository::_internal_set_private_(bool value) {
  
  private__ = value;
}
inline void ListRepository::set_private_(bool value) {
  _internal_set_private_(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListRepository.private)
}

// string fullname = 4 [json_name = "fullname"];
inline void ListRepository::clear_fullname() {
  fullname_.ClearToEmpty();
}
inline const std::string& ListRepository::fullname() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepository.fullname)
  return _internal_fullname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRepository::set_fullname(ArgT0&& arg0, ArgT... args) {
 
 fullname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListRepository.fullname)
}
inline std::string* ListRepository::mutable_fullname() {
  std::string* _s = _internal_mutable_fullname();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.ListRepository.fullname)
  return _s;
}
inline const std::string& ListRepository::_internal_fullname() const {
  return fullname_.Get();
}
inline void ListRepository::_internal_set_fullname(const std::string& value) {
  
  fullname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListRepository::_internal_mutable_fullname() {
  
  return fullname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListRepository::release_fullname() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.ListRepository.fullname)
  return fullname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListRepository::set_allocated_fullname(std::string* fullname) {
  if (fullname != nullptr) {
    
  } else {
    
  }
  fullname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fullname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.ListRepository.fullname)
}

// string description = 5 [json_name = "description"];
inline void ListRepository::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& ListRepository::description() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepository.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRepository::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListRepository.description)
}
inline std::string* ListRepository::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.ListRepository.description)
  return _s;
}
inline const std::string& ListRepository::_internal_description() const {
  return description_.Get();
}
inline void ListRepository::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListRepository::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListRepository::release_description() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.ListRepository.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListRepository::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.ListRepository.description)
}

// string clone_url = 7 [json_name = "cloneUrl"];
inline void ListRepository::clear_clone_url() {
  clone_url_.ClearToEmpty();
}
inline const std::string& ListRepository::clone_url() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepository.clone_url)
  return _internal_clone_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRepository::set_clone_url(ArgT0&& arg0, ArgT... args) {
 
 clone_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListRepository.clone_url)
}
inline std::string* ListRepository::mutable_clone_url() {
  std::string* _s = _internal_mutable_clone_url();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.ListRepository.clone_url)
  return _s;
}
inline const std::string& ListRepository::_internal_clone_url() const {
  return clone_url_.Get();
}
inline void ListRepository::_internal_set_clone_url(const std::string& value) {
  
  clone_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListRepository::_internal_mutable_clone_url() {
  
  return clone_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListRepository::release_clone_url() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.ListRepository.clone_url)
  return clone_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListRepository::set_allocated_clone_url(std::string* clone_url) {
  if (clone_url != nullptr) {
    
  } else {
    
  }
  clone_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clone_url,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.ListRepository.clone_url)
}

// uint32 project_id = 8 [json_name = "projectId"];
inline void ListRepository::clear_project_id() {
  project_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRepository::_internal_project_id() const {
  return project_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRepository::project_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepository.project_id)
  return _internal_project_id();
}
inline void ListRepository::_internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  project_id_ = value;
}
inline void ListRepository::set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_project_id(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListRepository.project_id)
}

// uint32 organization_id = 9 [json_name = "organizationId"];
inline void ListRepository::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRepository::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRepository::organization_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepository.organization_id)
  return _internal_organization_id();
}
inline void ListRepository::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void ListRepository::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListRepository.organization_id)
}

// string integration_id = 11 [json_name = "integrationId"];
inline void ListRepository::clear_integration_id() {
  integration_id_.ClearToEmpty();
}
inline const std::string& ListRepository::integration_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepository.integration_id)
  return _internal_integration_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRepository::set_integration_id(ArgT0&& arg0, ArgT... args) {
 
 integration_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListRepository.integration_id)
}
inline std::string* ListRepository::mutable_integration_id() {
  std::string* _s = _internal_mutable_integration_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.ListRepository.integration_id)
  return _s;
}
inline const std::string& ListRepository::_internal_integration_id() const {
  return integration_id_.Get();
}
inline void ListRepository::_internal_set_integration_id(const std::string& value) {
  
  integration_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListRepository::_internal_mutable_integration_id() {
  
  return integration_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListRepository::release_integration_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.ListRepository.integration_id)
  return integration_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListRepository::set_allocated_integration_id(std::string* integration_id) {
  if (integration_id != nullptr) {
    
  } else {
    
  }
  integration_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), integration_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.ListRepository.integration_id)
}

// -------------------------------------------------------------------

// CreateDetailRepository

// string name = 1 [json_name = "name"];
inline void CreateDetailRepository::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateDetailRepository::name() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateDetailRepository.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDetailRepository::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateDetailRepository.name)
}
inline std::string* CreateDetailRepository::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateDetailRepository.name)
  return _s;
}
inline const std::string& CreateDetailRepository::_internal_name() const {
  return name_.Get();
}
inline void CreateDetailRepository::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateDetailRepository::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateDetailRepository::release_name() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateDetailRepository.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateDetailRepository::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateDetailRepository.name)
}

// bool private = 2 [json_name = "private"];
inline void CreateDetailRepository::clear_private_() {
  private__ = false;
}
inline bool CreateDetailRepository::_internal_private_() const {
  return private__;
}
inline bool CreateDetailRepository::private_() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateDetailRepository.private)
  return _internal_private_();
}
inline void CreateDetailRepository::_internal_set_private_(bool value) {
  
  private__ = value;
}
inline void CreateDetailRepository::set_private_(bool value) {
  _internal_set_private_(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateDetailRepository.private)
}

// string fullname = 3 [json_name = "fullname"];
inline void CreateDetailRepository::clear_fullname() {
  fullname_.ClearToEmpty();
}
inline const std::string& CreateDetailRepository::fullname() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateDetailRepository.fullname)
  return _internal_fullname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDetailRepository::set_fullname(ArgT0&& arg0, ArgT... args) {
 
 fullname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateDetailRepository.fullname)
}
inline std::string* CreateDetailRepository::mutable_fullname() {
  std::string* _s = _internal_mutable_fullname();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateDetailRepository.fullname)
  return _s;
}
inline const std::string& CreateDetailRepository::_internal_fullname() const {
  return fullname_.Get();
}
inline void CreateDetailRepository::_internal_set_fullname(const std::string& value) {
  
  fullname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateDetailRepository::_internal_mutable_fullname() {
  
  return fullname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateDetailRepository::release_fullname() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateDetailRepository.fullname)
  return fullname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateDetailRepository::set_allocated_fullname(std::string* fullname) {
  if (fullname != nullptr) {
    
  } else {
    
  }
  fullname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fullname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateDetailRepository.fullname)
}

// string description = 4 [json_name = "description"];
inline void CreateDetailRepository::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& CreateDetailRepository::description() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateDetailRepository.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDetailRepository::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateDetailRepository.description)
}
inline std::string* CreateDetailRepository::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateDetailRepository.description)
  return _s;
}
inline const std::string& CreateDetailRepository::_internal_description() const {
  return description_.Get();
}
inline void CreateDetailRepository::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateDetailRepository::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateDetailRepository::release_description() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateDetailRepository.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateDetailRepository::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateDetailRepository.description)
}

// bool fork = 5 [json_name = "fork"];
inline void CreateDetailRepository::clear_fork() {
  fork_ = false;
}
inline bool CreateDetailRepository::_internal_fork() const {
  return fork_;
}
inline bool CreateDetailRepository::fork() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateDetailRepository.fork)
  return _internal_fork();
}
inline void CreateDetailRepository::_internal_set_fork(bool value) {
  
  fork_ = value;
}
inline void CreateDetailRepository::set_fork(bool value) {
  _internal_set_fork(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateDetailRepository.fork)
}

// string clone_url = 6 [json_name = "cloneUrl"];
inline void CreateDetailRepository::clear_clone_url() {
  clone_url_.ClearToEmpty();
}
inline const std::string& CreateDetailRepository::clone_url() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateDetailRepository.clone_url)
  return _internal_clone_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDetailRepository::set_clone_url(ArgT0&& arg0, ArgT... args) {
 
 clone_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateDetailRepository.clone_url)
}
inline std::string* CreateDetailRepository::mutable_clone_url() {
  std::string* _s = _internal_mutable_clone_url();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateDetailRepository.clone_url)
  return _s;
}
inline const std::string& CreateDetailRepository::_internal_clone_url() const {
  return clone_url_.Get();
}
inline void CreateDetailRepository::_internal_set_clone_url(const std::string& value) {
  
  clone_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateDetailRepository::_internal_mutable_clone_url() {
  
  return clone_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateDetailRepository::release_clone_url() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateDetailRepository.clone_url)
  return clone_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateDetailRepository::set_allocated_clone_url(std::string* clone_url) {
  if (clone_url != nullptr) {
    
  } else {
    
  }
  clone_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clone_url,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateDetailRepository.clone_url)
}

// uint32 project_id = 7 [json_name = "projectId"];
inline void CreateDetailRepository::clear_project_id() {
  project_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateDetailRepository::_internal_project_id() const {
  return project_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateDetailRepository::project_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateDetailRepository.project_id)
  return _internal_project_id();
}
inline void CreateDetailRepository::_internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  project_id_ = value;
}
inline void CreateDetailRepository::set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_project_id(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateDetailRepository.project_id)
}

// uint32 organization_id = 8 [json_name = "organizationId"];
inline void CreateDetailRepository::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateDetailRepository::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateDetailRepository::organization_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateDetailRepository.organization_id)
  return _internal_organization_id();
}
inline void CreateDetailRepository::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CreateDetailRepository::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateDetailRepository.organization_id)
}

// string integration_id = 9 [json_name = "integrationId"];
inline void CreateDetailRepository::clear_integration_id() {
  integration_id_.ClearToEmpty();
}
inline const std::string& CreateDetailRepository::integration_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateDetailRepository.integration_id)
  return _internal_integration_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDetailRepository::set_integration_id(ArgT0&& arg0, ArgT... args) {
 
 integration_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateDetailRepository.integration_id)
}
inline std::string* CreateDetailRepository::mutable_integration_id() {
  std::string* _s = _internal_mutable_integration_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateDetailRepository.integration_id)
  return _s;
}
inline const std::string& CreateDetailRepository::_internal_integration_id() const {
  return integration_id_.Get();
}
inline void CreateDetailRepository::_internal_set_integration_id(const std::string& value) {
  
  integration_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateDetailRepository::_internal_mutable_integration_id() {
  
  return integration_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateDetailRepository::release_integration_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateDetailRepository.integration_id)
  return integration_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateDetailRepository::set_allocated_integration_id(std::string* integration_id) {
  if (integration_id != nullptr) {
    
  } else {
    
  }
  integration_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), integration_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateDetailRepository.integration_id)
}

// -------------------------------------------------------------------

// CreateRepositoryRequest

// .source.v1alpha1.CreateDetailRepository repository = 1 [json_name = "repository"];
inline bool CreateRepositoryRequest::_internal_has_repository() const {
  return this != internal_default_instance() && repository_ != nullptr;
}
inline bool CreateRepositoryRequest::has_repository() const {
  return _internal_has_repository();
}
inline void CreateRepositoryRequest::clear_repository() {
  if (GetArenaForAllocation() == nullptr && repository_ != nullptr) {
    delete repository_;
  }
  repository_ = nullptr;
}
inline const ::source::v1alpha1::CreateDetailRepository& CreateRepositoryRequest::_internal_repository() const {
  const ::source::v1alpha1::CreateDetailRepository* p = repository_;
  return p != nullptr ? *p : reinterpret_cast<const ::source::v1alpha1::CreateDetailRepository&>(
      ::source::v1alpha1::_CreateDetailRepository_default_instance_);
}
inline const ::source::v1alpha1::CreateDetailRepository& CreateRepositoryRequest::repository() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateRepositoryRequest.repository)
  return _internal_repository();
}
inline void CreateRepositoryRequest::unsafe_arena_set_allocated_repository(
    ::source::v1alpha1::CreateDetailRepository* repository) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(repository_);
  }
  repository_ = repository;
  if (repository) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:source.v1alpha1.CreateRepositoryRequest.repository)
}
inline ::source::v1alpha1::CreateDetailRepository* CreateRepositoryRequest::release_repository() {
  
  ::source::v1alpha1::CreateDetailRepository* temp = repository_;
  repository_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::source::v1alpha1::CreateDetailRepository* CreateRepositoryRequest::unsafe_arena_release_repository() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateRepositoryRequest.repository)
  
  ::source::v1alpha1::CreateDetailRepository* temp = repository_;
  repository_ = nullptr;
  return temp;
}
inline ::source::v1alpha1::CreateDetailRepository* CreateRepositoryRequest::_internal_mutable_repository() {
  
  if (repository_ == nullptr) {
    auto* p = CreateMaybeMessage<::source::v1alpha1::CreateDetailRepository>(GetArenaForAllocation());
    repository_ = p;
  }
  return repository_;
}
inline ::source::v1alpha1::CreateDetailRepository* CreateRepositoryRequest::mutable_repository() {
  ::source::v1alpha1::CreateDetailRepository* _msg = _internal_mutable_repository();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateRepositoryRequest.repository)
  return _msg;
}
inline void CreateRepositoryRequest::set_allocated_repository(::source::v1alpha1::CreateDetailRepository* repository) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete repository_;
  }
  if (repository) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::source::v1alpha1::CreateDetailRepository>::GetOwningArena(repository);
    if (message_arena != submessage_arena) {
      repository = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repository, submessage_arena);
    }
    
  } else {
    
  }
  repository_ = repository;
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateRepositoryRequest.repository)
}

// uint32 project_id = 2 [json_name = "projectId"];
inline void CreateRepositoryRequest::clear_project_id() {
  project_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateRepositoryRequest::_internal_project_id() const {
  return project_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateRepositoryRequest::project_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateRepositoryRequest.project_id)
  return _internal_project_id();
}
inline void CreateRepositoryRequest::_internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  project_id_ = value;
}
inline void CreateRepositoryRequest::set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_project_id(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateRepositoryRequest.project_id)
}

// uint32 organization_id = 3 [json_name = "organizationId"];
inline void CreateRepositoryRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateRepositoryRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateRepositoryRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateRepositoryRequest.organization_id)
  return _internal_organization_id();
}
inline void CreateRepositoryRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CreateRepositoryRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateRepositoryRequest.organization_id)
}

// -------------------------------------------------------------------

// CreateRepositoryResponse

// string msg = 1 [json_name = "msg"];
inline void CreateRepositoryResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& CreateRepositoryResponse::msg() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateRepositoryResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRepositoryResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateRepositoryResponse.msg)
}
inline std::string* CreateRepositoryResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateRepositoryResponse.msg)
  return _s;
}
inline const std::string& CreateRepositoryResponse::_internal_msg() const {
  return msg_.Get();
}
inline void CreateRepositoryResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRepositoryResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRepositoryResponse::release_msg() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateRepositoryResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRepositoryResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateRepositoryResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void CreateRepositoryResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& CreateRepositoryResponse::error() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateRepositoryResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRepositoryResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateRepositoryResponse.error)
}
inline std::string* CreateRepositoryResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateRepositoryResponse.error)
  return _s;
}
inline const std::string& CreateRepositoryResponse::_internal_error() const {
  return error_.Get();
}
inline void CreateRepositoryResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRepositoryResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRepositoryResponse::release_error() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateRepositoryResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRepositoryResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateRepositoryResponse.error)
}

// -------------------------------------------------------------------

// ListRepositoriesRequest

// uint32 project_id = 1 [json_name = "projectId"];
inline void ListRepositoriesRequest::clear_project_id() {
  project_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRepositoriesRequest::_internal_project_id() const {
  return project_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRepositoriesRequest::project_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepositoriesRequest.project_id)
  return _internal_project_id();
}
inline void ListRepositoriesRequest::_internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  project_id_ = value;
}
inline void ListRepositoriesRequest::set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_project_id(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListRepositoriesRequest.project_id)
}

// uint32 organization_id = 2 [json_name = "organizationId"];
inline void ListRepositoriesRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRepositoriesRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListRepositoriesRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepositoriesRequest.organization_id)
  return _internal_organization_id();
}
inline void ListRepositoriesRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void ListRepositoriesRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListRepositoriesRequest.organization_id)
}

// -------------------------------------------------------------------

// ListRepositoriesResponse

// repeated .source.v1alpha1.ListRepository repositories = 1 [json_name = "repositories"];
inline int ListRepositoriesResponse::_internal_repositories_size() const {
  return repositories_.size();
}
inline int ListRepositoriesResponse::repositories_size() const {
  return _internal_repositories_size();
}
inline void ListRepositoriesResponse::clear_repositories() {
  repositories_.Clear();
}
inline ::source::v1alpha1::ListRepository* ListRepositoriesResponse::mutable_repositories(int index) {
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.ListRepositoriesResponse.repositories)
  return repositories_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::ListRepository >*
ListRepositoriesResponse::mutable_repositories() {
  // @@protoc_insertion_point(field_mutable_list:source.v1alpha1.ListRepositoriesResponse.repositories)
  return &repositories_;
}
inline const ::source::v1alpha1::ListRepository& ListRepositoriesResponse::_internal_repositories(int index) const {
  return repositories_.Get(index);
}
inline const ::source::v1alpha1::ListRepository& ListRepositoriesResponse::repositories(int index) const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListRepositoriesResponse.repositories)
  return _internal_repositories(index);
}
inline ::source::v1alpha1::ListRepository* ListRepositoriesResponse::_internal_add_repositories() {
  return repositories_.Add();
}
inline ::source::v1alpha1::ListRepository* ListRepositoriesResponse::add_repositories() {
  ::source::v1alpha1::ListRepository* _add = _internal_add_repositories();
  // @@protoc_insertion_point(field_add:source.v1alpha1.ListRepositoriesResponse.repositories)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::ListRepository >&
ListRepositoriesResponse::repositories() const {
  // @@protoc_insertion_point(field_list:source.v1alpha1.ListRepositoriesResponse.repositories)
  return repositories_;
}

// -------------------------------------------------------------------

// GetRepositoryRequest

// string repository_id = 1 [json_name = "repositoryId"];
inline void GetRepositoryRequest::clear_repository_id() {
  repository_id_.ClearToEmpty();
}
inline const std::string& GetRepositoryRequest::repository_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.GetRepositoryRequest.repository_id)
  return _internal_repository_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRepositoryRequest::set_repository_id(ArgT0&& arg0, ArgT... args) {
 
 repository_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.GetRepositoryRequest.repository_id)
}
inline std::string* GetRepositoryRequest::mutable_repository_id() {
  std::string* _s = _internal_mutable_repository_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.GetRepositoryRequest.repository_id)
  return _s;
}
inline const std::string& GetRepositoryRequest::_internal_repository_id() const {
  return repository_id_.Get();
}
inline void GetRepositoryRequest::_internal_set_repository_id(const std::string& value) {
  
  repository_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRepositoryRequest::_internal_mutable_repository_id() {
  
  return repository_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRepositoryRequest::release_repository_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.GetRepositoryRequest.repository_id)
  return repository_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRepositoryRequest::set_allocated_repository_id(std::string* repository_id) {
  if (repository_id != nullptr) {
    
  } else {
    
  }
  repository_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), repository_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.GetRepositoryRequest.repository_id)
}

// -------------------------------------------------------------------

// GetRepositoryResponse

// .source.v1alpha1.DetailRepository repository = 1 [json_name = "repository"];
inline bool GetRepositoryResponse::_internal_has_repository() const {
  return this != internal_default_instance() && repository_ != nullptr;
}
inline bool GetRepositoryResponse::has_repository() const {
  return _internal_has_repository();
}
inline void GetRepositoryResponse::clear_repository() {
  if (GetArenaForAllocation() == nullptr && repository_ != nullptr) {
    delete repository_;
  }
  repository_ = nullptr;
}
inline const ::source::v1alpha1::DetailRepository& GetRepositoryResponse::_internal_repository() const {
  const ::source::v1alpha1::DetailRepository* p = repository_;
  return p != nullptr ? *p : reinterpret_cast<const ::source::v1alpha1::DetailRepository&>(
      ::source::v1alpha1::_DetailRepository_default_instance_);
}
inline const ::source::v1alpha1::DetailRepository& GetRepositoryResponse::repository() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.GetRepositoryResponse.repository)
  return _internal_repository();
}
inline void GetRepositoryResponse::unsafe_arena_set_allocated_repository(
    ::source::v1alpha1::DetailRepository* repository) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(repository_);
  }
  repository_ = repository;
  if (repository) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:source.v1alpha1.GetRepositoryResponse.repository)
}
inline ::source::v1alpha1::DetailRepository* GetRepositoryResponse::release_repository() {
  
  ::source::v1alpha1::DetailRepository* temp = repository_;
  repository_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::source::v1alpha1::DetailRepository* GetRepositoryResponse::unsafe_arena_release_repository() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.GetRepositoryResponse.repository)
  
  ::source::v1alpha1::DetailRepository* temp = repository_;
  repository_ = nullptr;
  return temp;
}
inline ::source::v1alpha1::DetailRepository* GetRepositoryResponse::_internal_mutable_repository() {
  
  if (repository_ == nullptr) {
    auto* p = CreateMaybeMessage<::source::v1alpha1::DetailRepository>(GetArenaForAllocation());
    repository_ = p;
  }
  return repository_;
}
inline ::source::v1alpha1::DetailRepository* GetRepositoryResponse::mutable_repository() {
  ::source::v1alpha1::DetailRepository* _msg = _internal_mutable_repository();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.GetRepositoryResponse.repository)
  return _msg;
}
inline void GetRepositoryResponse::set_allocated_repository(::source::v1alpha1::DetailRepository* repository) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete repository_;
  }
  if (repository) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::source::v1alpha1::DetailRepository>::GetOwningArena(repository);
    if (message_arena != submessage_arena) {
      repository = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repository, submessage_arena);
    }
    
  } else {
    
  }
  repository_ = repository;
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.GetRepositoryResponse.repository)
}

// -------------------------------------------------------------------

// DeleteRepositoryRequest

// string repository_id = 1 [json_name = "repositoryId"];
inline void DeleteRepositoryRequest::clear_repository_id() {
  repository_id_.ClearToEmpty();
}
inline const std::string& DeleteRepositoryRequest::repository_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DeleteRepositoryRequest.repository_id)
  return _internal_repository_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRepositoryRequest::set_repository_id(ArgT0&& arg0, ArgT... args) {
 
 repository_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DeleteRepositoryRequest.repository_id)
}
inline std::string* DeleteRepositoryRequest::mutable_repository_id() {
  std::string* _s = _internal_mutable_repository_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DeleteRepositoryRequest.repository_id)
  return _s;
}
inline const std::string& DeleteRepositoryRequest::_internal_repository_id() const {
  return repository_id_.Get();
}
inline void DeleteRepositoryRequest::_internal_set_repository_id(const std::string& value) {
  
  repository_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteRepositoryRequest::_internal_mutable_repository_id() {
  
  return repository_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteRepositoryRequest::release_repository_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DeleteRepositoryRequest.repository_id)
  return repository_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteRepositoryRequest::set_allocated_repository_id(std::string* repository_id) {
  if (repository_id != nullptr) {
    
  } else {
    
  }
  repository_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), repository_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DeleteRepositoryRequest.repository_id)
}

// -------------------------------------------------------------------

// DeleteRepositoryResponse

// string msg = 1 [json_name = "msg"];
inline void DeleteRepositoryResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& DeleteRepositoryResponse::msg() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DeleteRepositoryResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRepositoryResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DeleteRepositoryResponse.msg)
}
inline std::string* DeleteRepositoryResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DeleteRepositoryResponse.msg)
  return _s;
}
inline const std::string& DeleteRepositoryResponse::_internal_msg() const {
  return msg_.Get();
}
inline void DeleteRepositoryResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteRepositoryResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteRepositoryResponse::release_msg() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DeleteRepositoryResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteRepositoryResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DeleteRepositoryResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void DeleteRepositoryResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& DeleteRepositoryResponse::error() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DeleteRepositoryResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRepositoryResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DeleteRepositoryResponse.error)
}
inline std::string* DeleteRepositoryResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DeleteRepositoryResponse.error)
  return _s;
}
inline const std::string& DeleteRepositoryResponse::_internal_error() const {
  return error_.Get();
}
inline void DeleteRepositoryResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteRepositoryResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteRepositoryResponse::release_error() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DeleteRepositoryResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteRepositoryResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DeleteRepositoryResponse.error)
}

// -------------------------------------------------------------------

// UpdateRepositoryRequest

// string repository_id = 1 [json_name = "repositoryId"];
inline void UpdateRepositoryRequest::clear_repository_id() {
  repository_id_.ClearToEmpty();
}
inline const std::string& UpdateRepositoryRequest::repository_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.UpdateRepositoryRequest.repository_id)
  return _internal_repository_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRepositoryRequest::set_repository_id(ArgT0&& arg0, ArgT... args) {
 
 repository_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.UpdateRepositoryRequest.repository_id)
}
inline std::string* UpdateRepositoryRequest::mutable_repository_id() {
  std::string* _s = _internal_mutable_repository_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.UpdateRepositoryRequest.repository_id)
  return _s;
}
inline const std::string& UpdateRepositoryRequest::_internal_repository_id() const {
  return repository_id_.Get();
}
inline void UpdateRepositoryRequest::_internal_set_repository_id(const std::string& value) {
  
  repository_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateRepositoryRequest::_internal_mutable_repository_id() {
  
  return repository_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateRepositoryRequest::release_repository_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.UpdateRepositoryRequest.repository_id)
  return repository_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateRepositoryRequest::set_allocated_repository_id(std::string* repository_id) {
  if (repository_id != nullptr) {
    
  } else {
    
  }
  repository_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), repository_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.UpdateRepositoryRequest.repository_id)
}

// .source.v1alpha1.DetailRepository repository = 2 [json_name = "repository"];
inline bool UpdateRepositoryRequest::_internal_has_repository() const {
  return this != internal_default_instance() && repository_ != nullptr;
}
inline bool UpdateRepositoryRequest::has_repository() const {
  return _internal_has_repository();
}
inline void UpdateRepositoryRequest::clear_repository() {
  if (GetArenaForAllocation() == nullptr && repository_ != nullptr) {
    delete repository_;
  }
  repository_ = nullptr;
}
inline const ::source::v1alpha1::DetailRepository& UpdateRepositoryRequest::_internal_repository() const {
  const ::source::v1alpha1::DetailRepository* p = repository_;
  return p != nullptr ? *p : reinterpret_cast<const ::source::v1alpha1::DetailRepository&>(
      ::source::v1alpha1::_DetailRepository_default_instance_);
}
inline const ::source::v1alpha1::DetailRepository& UpdateRepositoryRequest::repository() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.UpdateRepositoryRequest.repository)
  return _internal_repository();
}
inline void UpdateRepositoryRequest::unsafe_arena_set_allocated_repository(
    ::source::v1alpha1::DetailRepository* repository) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(repository_);
  }
  repository_ = repository;
  if (repository) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:source.v1alpha1.UpdateRepositoryRequest.repository)
}
inline ::source::v1alpha1::DetailRepository* UpdateRepositoryRequest::release_repository() {
  
  ::source::v1alpha1::DetailRepository* temp = repository_;
  repository_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::source::v1alpha1::DetailRepository* UpdateRepositoryRequest::unsafe_arena_release_repository() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.UpdateRepositoryRequest.repository)
  
  ::source::v1alpha1::DetailRepository* temp = repository_;
  repository_ = nullptr;
  return temp;
}
inline ::source::v1alpha1::DetailRepository* UpdateRepositoryRequest::_internal_mutable_repository() {
  
  if (repository_ == nullptr) {
    auto* p = CreateMaybeMessage<::source::v1alpha1::DetailRepository>(GetArenaForAllocation());
    repository_ = p;
  }
  return repository_;
}
inline ::source::v1alpha1::DetailRepository* UpdateRepositoryRequest::mutable_repository() {
  ::source::v1alpha1::DetailRepository* _msg = _internal_mutable_repository();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.UpdateRepositoryRequest.repository)
  return _msg;
}
inline void UpdateRepositoryRequest::set_allocated_repository(::source::v1alpha1::DetailRepository* repository) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete repository_;
  }
  if (repository) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::source::v1alpha1::DetailRepository>::GetOwningArena(repository);
    if (message_arena != submessage_arena) {
      repository = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repository, submessage_arena);
    }
    
  } else {
    
  }
  repository_ = repository;
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.UpdateRepositoryRequest.repository)
}

// -------------------------------------------------------------------

// UpdateRepositoryResponse

// string msg = 1 [json_name = "msg"];
inline void UpdateRepositoryResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& UpdateRepositoryResponse::msg() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.UpdateRepositoryResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRepositoryResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.UpdateRepositoryResponse.msg)
}
inline std::string* UpdateRepositoryResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.UpdateRepositoryResponse.msg)
  return _s;
}
inline const std::string& UpdateRepositoryResponse::_internal_msg() const {
  return msg_.Get();
}
inline void UpdateRepositoryResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateRepositoryResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateRepositoryResponse::release_msg() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.UpdateRepositoryResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateRepositoryResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.UpdateRepositoryResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void UpdateRepositoryResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& UpdateRepositoryResponse::error() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.UpdateRepositoryResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRepositoryResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.UpdateRepositoryResponse.error)
}
inline std::string* UpdateRepositoryResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.UpdateRepositoryResponse.error)
  return _s;
}
inline const std::string& UpdateRepositoryResponse::_internal_error() const {
  return error_.Get();
}
inline void UpdateRepositoryResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateRepositoryResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateRepositoryResponse::release_error() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.UpdateRepositoryResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateRepositoryResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.UpdateRepositoryResponse.error)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Integration

// string id = 1 [json_name = "id"];
inline void Integration::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Integration::id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Integration.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Integration::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.Integration.id)
}
inline std::string* Integration::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Integration.id)
  return _s;
}
inline const std::string& Integration::_internal_id() const {
  return id_.Get();
}
inline void Integration::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Integration::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Integration::release_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Integration.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Integration::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Integration.id)
}

// uint32 organization_id = 2 [json_name = "organizationId"];
inline void Integration::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Integration::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Integration::organization_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Integration.organization_id)
  return _internal_organization_id();
}
inline void Integration::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void Integration::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.Integration.organization_id)
}

// string name = 3 [json_name = "name"];
inline void Integration::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Integration::name() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Integration.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Integration::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.Integration.name)
}
inline std::string* Integration::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Integration.name)
  return _s;
}
inline const std::string& Integration::_internal_name() const {
  return name_.Get();
}
inline void Integration::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Integration::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Integration::release_name() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Integration.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Integration::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Integration.name)
}

// .source.v1alpha1.Provider provider = 4 [json_name = "provider"];
inline bool Integration::_internal_has_provider() const {
  return this != internal_default_instance() && provider_ != nullptr;
}
inline bool Integration::has_provider() const {
  return _internal_has_provider();
}
inline void Integration::clear_provider() {
  if (GetArenaForAllocation() == nullptr && provider_ != nullptr) {
    delete provider_;
  }
  provider_ = nullptr;
}
inline const ::source::v1alpha1::Provider& Integration::_internal_provider() const {
  const ::source::v1alpha1::Provider* p = provider_;
  return p != nullptr ? *p : reinterpret_cast<const ::source::v1alpha1::Provider&>(
      ::source::v1alpha1::_Provider_default_instance_);
}
inline const ::source::v1alpha1::Provider& Integration::provider() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Integration.provider)
  return _internal_provider();
}
inline void Integration::unsafe_arena_set_allocated_provider(
    ::source::v1alpha1::Provider* provider) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(provider_);
  }
  provider_ = provider;
  if (provider) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:source.v1alpha1.Integration.provider)
}
inline ::source::v1alpha1::Provider* Integration::release_provider() {
  
  ::source::v1alpha1::Provider* temp = provider_;
  provider_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::source::v1alpha1::Provider* Integration::unsafe_arena_release_provider() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Integration.provider)
  
  ::source::v1alpha1::Provider* temp = provider_;
  provider_ = nullptr;
  return temp;
}
inline ::source::v1alpha1::Provider* Integration::_internal_mutable_provider() {
  
  if (provider_ == nullptr) {
    auto* p = CreateMaybeMessage<::source::v1alpha1::Provider>(GetArenaForAllocation());
    provider_ = p;
  }
  return provider_;
}
inline ::source::v1alpha1::Provider* Integration::mutable_provider() {
  ::source::v1alpha1::Provider* _msg = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Integration.provider)
  return _msg;
}
inline void Integration::set_allocated_provider(::source::v1alpha1::Provider* provider) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete provider_;
  }
  if (provider) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::source::v1alpha1::Provider>::GetOwningArena(provider);
    if (message_arena != submessage_arena) {
      provider = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, provider, submessage_arena);
    }
    
  } else {
    
  }
  provider_ = provider;
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Integration.provider)
}

// map<string, string> data = 5 [json_name = "data"];
inline int Integration::_internal_data_size() const {
  return data_.size();
}
inline int Integration::data_size() const {
  return _internal_data_size();
}
inline void Integration::clear_data() {
  data_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Integration::_internal_data() const {
  return data_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Integration::data() const {
  // @@protoc_insertion_point(field_map:source.v1alpha1.Integration.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Integration::_internal_mutable_data() {
  return data_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Integration::mutable_data() {
  // @@protoc_insertion_point(field_mutable_map:source.v1alpha1.Integration.data)
  return _internal_mutable_data();
}

// map<string, string> metadata = 6 [json_name = "metadata"];
inline int Integration::_internal_metadata_size() const {
  return metadata_.size();
}
inline int Integration::metadata_size() const {
  return _internal_metadata_size();
}
inline void Integration::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Integration::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Integration::metadata() const {
  // @@protoc_insertion_point(field_map:source.v1alpha1.Integration.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Integration::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Integration::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:source.v1alpha1.Integration.metadata)
  return _internal_mutable_metadata();
}

// string user_id = 7 [json_name = "userId"];
inline void Integration::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& Integration::user_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Integration.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Integration::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.Integration.user_id)
}
inline std::string* Integration::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Integration.user_id)
  return _s;
}
inline const std::string& Integration::_internal_user_id() const {
  return user_id_.Get();
}
inline void Integration::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Integration::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Integration::release_user_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Integration.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Integration::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Integration.user_id)
}

// .source.v1alpha1.AccountIntegration account = 8 [json_name = "account"];
inline bool Integration::_internal_has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline bool Integration::has_account() const {
  return _internal_has_account();
}
inline void Integration::clear_account() {
  if (GetArenaForAllocation() == nullptr && account_ != nullptr) {
    delete account_;
  }
  account_ = nullptr;
}
inline const ::source::v1alpha1::AccountIntegration& Integration::_internal_account() const {
  const ::source::v1alpha1::AccountIntegration* p = account_;
  return p != nullptr ? *p : reinterpret_cast<const ::source::v1alpha1::AccountIntegration&>(
      ::source::v1alpha1::_AccountIntegration_default_instance_);
}
inline const ::source::v1alpha1::AccountIntegration& Integration::account() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Integration.account)
  return _internal_account();
}
inline void Integration::unsafe_arena_set_allocated_account(
    ::source::v1alpha1::AccountIntegration* account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:source.v1alpha1.Integration.account)
}
inline ::source::v1alpha1::AccountIntegration* Integration::release_account() {
  
  ::source::v1alpha1::AccountIntegration* temp = account_;
  account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::source::v1alpha1::AccountIntegration* Integration::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Integration.account)
  
  ::source::v1alpha1::AccountIntegration* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::source::v1alpha1::AccountIntegration* Integration::_internal_mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::source::v1alpha1::AccountIntegration>(GetArenaForAllocation());
    account_ = p;
  }
  return account_;
}
inline ::source::v1alpha1::AccountIntegration* Integration::mutable_account() {
  ::source::v1alpha1::AccountIntegration* _msg = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Integration.account)
  return _msg;
}
inline void Integration::set_allocated_account(::source::v1alpha1::AccountIntegration* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete account_;
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::source::v1alpha1::AccountIntegration>::GetOwningArena(account);
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Integration.account)
}

// -------------------------------------------------------------------

// Repository

// string name = 1 [json_name = "name"];
inline void Repository::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Repository::name() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Repository.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Repository::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.Repository.name)
}
inline std::string* Repository::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Repository.name)
  return _s;
}
inline const std::string& Repository::_internal_name() const {
  return name_.Get();
}
inline void Repository::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Repository::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Repository::release_name() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Repository.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Repository::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Repository.name)
}

// bool private = 2 [json_name = "private"];
inline void Repository::clear_private_() {
  private__ = false;
}
inline bool Repository::_internal_private_() const {
  return private__;
}
inline bool Repository::private_() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Repository.private)
  return _internal_private_();
}
inline void Repository::_internal_set_private_(bool value) {
  
  private__ = value;
}
inline void Repository::set_private_(bool value) {
  _internal_set_private_(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.Repository.private)
}

// string fullname = 3 [json_name = "fullname"];
inline void Repository::clear_fullname() {
  fullname_.ClearToEmpty();
}
inline const std::string& Repository::fullname() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Repository.fullname)
  return _internal_fullname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Repository::set_fullname(ArgT0&& arg0, ArgT... args) {
 
 fullname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.Repository.fullname)
}
inline std::string* Repository::mutable_fullname() {
  std::string* _s = _internal_mutable_fullname();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Repository.fullname)
  return _s;
}
inline const std::string& Repository::_internal_fullname() const {
  return fullname_.Get();
}
inline void Repository::_internal_set_fullname(const std::string& value) {
  
  fullname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Repository::_internal_mutable_fullname() {
  
  return fullname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Repository::release_fullname() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Repository.fullname)
  return fullname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Repository::set_allocated_fullname(std::string* fullname) {
  if (fullname != nullptr) {
    
  } else {
    
  }
  fullname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fullname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Repository.fullname)
}

// string description = 4 [json_name = "description"];
inline void Repository::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& Repository::description() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Repository.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Repository::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.Repository.description)
}
inline std::string* Repository::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Repository.description)
  return _s;
}
inline const std::string& Repository::_internal_description() const {
  return description_.Get();
}
inline void Repository::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Repository::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Repository::release_description() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Repository.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Repository::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Repository.description)
}

// bool fork = 5 [json_name = "fork"];
inline void Repository::clear_fork() {
  fork_ = false;
}
inline bool Repository::_internal_fork() const {
  return fork_;
}
inline bool Repository::fork() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Repository.fork)
  return _internal_fork();
}
inline void Repository::_internal_set_fork(bool value) {
  
  fork_ = value;
}
inline void Repository::set_fork(bool value) {
  _internal_set_fork(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.Repository.fork)
}

// string clone_url = 6 [json_name = "cloneUrl"];
inline void Repository::clear_clone_url() {
  clone_url_.ClearToEmpty();
}
inline const std::string& Repository::clone_url() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Repository.clone_url)
  return _internal_clone_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Repository::set_clone_url(ArgT0&& arg0, ArgT... args) {
 
 clone_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.Repository.clone_url)
}
inline std::string* Repository::mutable_clone_url() {
  std::string* _s = _internal_mutable_clone_url();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Repository.clone_url)
  return _s;
}
inline const std::string& Repository::_internal_clone_url() const {
  return clone_url_.Get();
}
inline void Repository::_internal_set_clone_url(const std::string& value) {
  
  clone_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Repository::_internal_mutable_clone_url() {
  
  return clone_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Repository::release_clone_url() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Repository.clone_url)
  return clone_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Repository::set_allocated_clone_url(std::string* clone_url) {
  if (clone_url != nullptr) {
    
  } else {
    
  }
  clone_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clone_url,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Repository.clone_url)
}

// string branch = 7 [json_name = "branch"];
inline void Repository::clear_branch() {
  branch_.ClearToEmpty();
}
inline const std::string& Repository::branch() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Repository.branch)
  return _internal_branch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Repository::set_branch(ArgT0&& arg0, ArgT... args) {
 
 branch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.Repository.branch)
}
inline std::string* Repository::mutable_branch() {
  std::string* _s = _internal_mutable_branch();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Repository.branch)
  return _s;
}
inline const std::string& Repository::_internal_branch() const {
  return branch_.Get();
}
inline void Repository::_internal_set_branch(const std::string& value) {
  
  branch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Repository::_internal_mutable_branch() {
  
  return branch_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Repository::release_branch() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Repository.branch)
  return branch_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Repository::set_allocated_branch(std::string* branch) {
  if (branch != nullptr) {
    
  } else {
    
  }
  branch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), branch,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Repository.branch)
}

// -------------------------------------------------------------------

// AccountIntegration

// string name = 1 [json_name = "name"];
inline void AccountIntegration::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& AccountIntegration::name() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.AccountIntegration.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountIntegration::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.AccountIntegration.name)
}
inline std::string* AccountIntegration::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.AccountIntegration.name)
  return _s;
}
inline const std::string& AccountIntegration::_internal_name() const {
  return name_.Get();
}
inline void AccountIntegration::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountIntegration::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountIntegration::release_name() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.AccountIntegration.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountIntegration::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.AccountIntegration.name)
}

// string type = 2 [json_name = "type"];
inline void AccountIntegration::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& AccountIntegration::type() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.AccountIntegration.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountIntegration::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.AccountIntegration.type)
}
inline std::string* AccountIntegration::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.AccountIntegration.type)
  return _s;
}
inline const std::string& AccountIntegration::_internal_type() const {
  return type_.Get();
}
inline void AccountIntegration::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountIntegration::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountIntegration::release_type() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.AccountIntegration.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountIntegration::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.AccountIntegration.type)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateIntegrationRequest

// uint32 organization_id = 2 [json_name = "organizationId"];
inline void CreateIntegrationRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateIntegrationRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateIntegrationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateIntegrationRequest.organization_id)
  return _internal_organization_id();
}
inline void CreateIntegrationRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CreateIntegrationRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateIntegrationRequest.organization_id)
}

// string name = 3 [json_name = "name"];
inline void CreateIntegrationRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateIntegrationRequest::name() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateIntegrationRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIntegrationRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateIntegrationRequest.name)
}
inline std::string* CreateIntegrationRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateIntegrationRequest.name)
  return _s;
}
inline const std::string& CreateIntegrationRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateIntegrationRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateIntegrationRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateIntegrationRequest::release_name() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateIntegrationRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateIntegrationRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateIntegrationRequest.name)
}

// map<string, string> data = 5 [json_name = "data"];
inline int CreateIntegrationRequest::_internal_data_size() const {
  return data_.size();
}
inline int CreateIntegrationRequest::data_size() const {
  return _internal_data_size();
}
inline void CreateIntegrationRequest::clear_data() {
  data_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateIntegrationRequest::_internal_data() const {
  return data_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateIntegrationRequest::data() const {
  // @@protoc_insertion_point(field_map:source.v1alpha1.CreateIntegrationRequest.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateIntegrationRequest::_internal_mutable_data() {
  return data_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateIntegrationRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable_map:source.v1alpha1.CreateIntegrationRequest.data)
  return _internal_mutable_data();
}

// map<string, string> metadata = 6 [json_name = "metadata"];
inline int CreateIntegrationRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int CreateIntegrationRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void CreateIntegrationRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateIntegrationRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateIntegrationRequest::metadata() const {
  // @@protoc_insertion_point(field_map:source.v1alpha1.CreateIntegrationRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateIntegrationRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateIntegrationRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:source.v1alpha1.CreateIntegrationRequest.metadata)
  return _internal_mutable_metadata();
}

// string user_id = 7 [json_name = "userId"];
inline void CreateIntegrationRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& CreateIntegrationRequest::user_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateIntegrationRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIntegrationRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateIntegrationRequest.user_id)
}
inline std::string* CreateIntegrationRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateIntegrationRequest.user_id)
  return _s;
}
inline const std::string& CreateIntegrationRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void CreateIntegrationRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateIntegrationRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateIntegrationRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateIntegrationRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateIntegrationRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateIntegrationRequest.user_id)
}

// string provider_id = 8 [json_name = "providerId"];
inline void CreateIntegrationRequest::clear_provider_id() {
  provider_id_.ClearToEmpty();
}
inline const std::string& CreateIntegrationRequest::provider_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateIntegrationRequest.provider_id)
  return _internal_provider_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIntegrationRequest::set_provider_id(ArgT0&& arg0, ArgT... args) {
 
 provider_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateIntegrationRequest.provider_id)
}
inline std::string* CreateIntegrationRequest::mutable_provider_id() {
  std::string* _s = _internal_mutable_provider_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateIntegrationRequest.provider_id)
  return _s;
}
inline const std::string& CreateIntegrationRequest::_internal_provider_id() const {
  return provider_id_.Get();
}
inline void CreateIntegrationRequest::_internal_set_provider_id(const std::string& value) {
  
  provider_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateIntegrationRequest::_internal_mutable_provider_id() {
  
  return provider_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateIntegrationRequest::release_provider_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateIntegrationRequest.provider_id)
  return provider_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateIntegrationRequest::set_allocated_provider_id(std::string* provider_id) {
  if (provider_id != nullptr) {
    
  } else {
    
  }
  provider_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), provider_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateIntegrationRequest.provider_id)
}

// .source.v1alpha1.AccountIntegration account = 9 [json_name = "account"];
inline bool CreateIntegrationRequest::_internal_has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline bool CreateIntegrationRequest::has_account() const {
  return _internal_has_account();
}
inline void CreateIntegrationRequest::clear_account() {
  if (GetArenaForAllocation() == nullptr && account_ != nullptr) {
    delete account_;
  }
  account_ = nullptr;
}
inline const ::source::v1alpha1::AccountIntegration& CreateIntegrationRequest::_internal_account() const {
  const ::source::v1alpha1::AccountIntegration* p = account_;
  return p != nullptr ? *p : reinterpret_cast<const ::source::v1alpha1::AccountIntegration&>(
      ::source::v1alpha1::_AccountIntegration_default_instance_);
}
inline const ::source::v1alpha1::AccountIntegration& CreateIntegrationRequest::account() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateIntegrationRequest.account)
  return _internal_account();
}
inline void CreateIntegrationRequest::unsafe_arena_set_allocated_account(
    ::source::v1alpha1::AccountIntegration* account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:source.v1alpha1.CreateIntegrationRequest.account)
}
inline ::source::v1alpha1::AccountIntegration* CreateIntegrationRequest::release_account() {
  
  ::source::v1alpha1::AccountIntegration* temp = account_;
  account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::source::v1alpha1::AccountIntegration* CreateIntegrationRequest::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateIntegrationRequest.account)
  
  ::source::v1alpha1::AccountIntegration* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::source::v1alpha1::AccountIntegration* CreateIntegrationRequest::_internal_mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::source::v1alpha1::AccountIntegration>(GetArenaForAllocation());
    account_ = p;
  }
  return account_;
}
inline ::source::v1alpha1::AccountIntegration* CreateIntegrationRequest::mutable_account() {
  ::source::v1alpha1::AccountIntegration* _msg = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateIntegrationRequest.account)
  return _msg;
}
inline void CreateIntegrationRequest::set_allocated_account(::source::v1alpha1::AccountIntegration* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete account_;
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::source::v1alpha1::AccountIntegration>::GetOwningArena(account);
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateIntegrationRequest.account)
}

// -------------------------------------------------------------------

// CreateIntegrationResponse

// string msg = 1 [json_name = "msg"];
inline void CreateIntegrationResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& CreateIntegrationResponse::msg() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateIntegrationResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIntegrationResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateIntegrationResponse.msg)
}
inline std::string* CreateIntegrationResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateIntegrationResponse.msg)
  return _s;
}
inline const std::string& CreateIntegrationResponse::_internal_msg() const {
  return msg_.Get();
}
inline void CreateIntegrationResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateIntegrationResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateIntegrationResponse::release_msg() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateIntegrationResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateIntegrationResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateIntegrationResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void CreateIntegrationResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& CreateIntegrationResponse::error() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateIntegrationResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIntegrationResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateIntegrationResponse.error)
}
inline std::string* CreateIntegrationResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateIntegrationResponse.error)
  return _s;
}
inline const std::string& CreateIntegrationResponse::_internal_error() const {
  return error_.Get();
}
inline void CreateIntegrationResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateIntegrationResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateIntegrationResponse::release_error() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateIntegrationResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateIntegrationResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateIntegrationResponse.error)
}

// string integration_id = 3 [json_name = "integrationId"];
inline void CreateIntegrationResponse::clear_integration_id() {
  integration_id_.ClearToEmpty();
}
inline const std::string& CreateIntegrationResponse::integration_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateIntegrationResponse.integration_id)
  return _internal_integration_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIntegrationResponse::set_integration_id(ArgT0&& arg0, ArgT... args) {
 
 integration_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateIntegrationResponse.integration_id)
}
inline std::string* CreateIntegrationResponse::mutable_integration_id() {
  std::string* _s = _internal_mutable_integration_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateIntegrationResponse.integration_id)
  return _s;
}
inline const std::string& CreateIntegrationResponse::_internal_integration_id() const {
  return integration_id_.Get();
}
inline void CreateIntegrationResponse::_internal_set_integration_id(const std::string& value) {
  
  integration_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateIntegrationResponse::_internal_mutable_integration_id() {
  
  return integration_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateIntegrationResponse::release_integration_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateIntegrationResponse.integration_id)
  return integration_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateIntegrationResponse::set_allocated_integration_id(std::string* integration_id) {
  if (integration_id != nullptr) {
    
  } else {
    
  }
  integration_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), integration_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateIntegrationResponse.integration_id)
}

// -------------------------------------------------------------------

// ListIntegrationsRequest

// uint32 organization_id = 1 [json_name = "organizationId"];
inline void ListIntegrationsRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListIntegrationsRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListIntegrationsRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListIntegrationsRequest.organization_id)
  return _internal_organization_id();
}
inline void ListIntegrationsRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void ListIntegrationsRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListIntegrationsRequest.organization_id)
}

// string user_id = 2 [json_name = "userId"];
inline void ListIntegrationsRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& ListIntegrationsRequest::user_id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListIntegrationsRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIntegrationsRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListIntegrationsRequest.user_id)
}
inline std::string* ListIntegrationsRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.ListIntegrationsRequest.user_id)
  return _s;
}
inline const std::string& ListIntegrationsRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void ListIntegrationsRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListIntegrationsRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListIntegrationsRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.ListIntegrationsRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListIntegrationsRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.ListIntegrationsRequest.user_id)
}

// -------------------------------------------------------------------

// ListIntegrationsResponse

// repeated .source.v1alpha1.Integration integrations = 1 [json_name = "integrations"];
inline int ListIntegrationsResponse::_internal_integrations_size() const {
  return integrations_.size();
}
inline int ListIntegrationsResponse::integrations_size() const {
  return _internal_integrations_size();
}
inline void ListIntegrationsResponse::clear_integrations() {
  integrations_.Clear();
}
inline ::source::v1alpha1::Integration* ListIntegrationsResponse::mutable_integrations(int index) {
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.ListIntegrationsResponse.integrations)
  return integrations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Integration >*
ListIntegrationsResponse::mutable_integrations() {
  // @@protoc_insertion_point(field_mutable_list:source.v1alpha1.ListIntegrationsResponse.integrations)
  return &integrations_;
}
inline const ::source::v1alpha1::Integration& ListIntegrationsResponse::_internal_integrations(int index) const {
  return integrations_.Get(index);
}
inline const ::source::v1alpha1::Integration& ListIntegrationsResponse::integrations(int index) const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListIntegrationsResponse.integrations)
  return _internal_integrations(index);
}
inline ::source::v1alpha1::Integration* ListIntegrationsResponse::_internal_add_integrations() {
  return integrations_.Add();
}
inline ::source::v1alpha1::Integration* ListIntegrationsResponse::add_integrations() {
  ::source::v1alpha1::Integration* _add = _internal_add_integrations();
  // @@protoc_insertion_point(field_add:source.v1alpha1.ListIntegrationsResponse.integrations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Integration >&
ListIntegrationsResponse::integrations() const {
  // @@protoc_insertion_point(field_list:source.v1alpha1.ListIntegrationsResponse.integrations)
  return integrations_;
}

// -------------------------------------------------------------------

// GetIntegrationRequest

// string id = 1 [json_name = "id"];
inline void GetIntegrationRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetIntegrationRequest::id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.GetIntegrationRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetIntegrationRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.GetIntegrationRequest.id)
}
inline std::string* GetIntegrationRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.GetIntegrationRequest.id)
  return _s;
}
inline const std::string& GetIntegrationRequest::_internal_id() const {
  return id_.Get();
}
inline void GetIntegrationRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetIntegrationRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetIntegrationRequest::release_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.GetIntegrationRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetIntegrationRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.GetIntegrationRequest.id)
}

// -------------------------------------------------------------------

// GetIntegrationResponse

// .source.v1alpha1.Integration integration = 1 [json_name = "integration"];
inline bool GetIntegrationResponse::_internal_has_integration() const {
  return this != internal_default_instance() && integration_ != nullptr;
}
inline bool GetIntegrationResponse::has_integration() const {
  return _internal_has_integration();
}
inline void GetIntegrationResponse::clear_integration() {
  if (GetArenaForAllocation() == nullptr && integration_ != nullptr) {
    delete integration_;
  }
  integration_ = nullptr;
}
inline const ::source::v1alpha1::Integration& GetIntegrationResponse::_internal_integration() const {
  const ::source::v1alpha1::Integration* p = integration_;
  return p != nullptr ? *p : reinterpret_cast<const ::source::v1alpha1::Integration&>(
      ::source::v1alpha1::_Integration_default_instance_);
}
inline const ::source::v1alpha1::Integration& GetIntegrationResponse::integration() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.GetIntegrationResponse.integration)
  return _internal_integration();
}
inline void GetIntegrationResponse::unsafe_arena_set_allocated_integration(
    ::source::v1alpha1::Integration* integration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(integration_);
  }
  integration_ = integration;
  if (integration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:source.v1alpha1.GetIntegrationResponse.integration)
}
inline ::source::v1alpha1::Integration* GetIntegrationResponse::release_integration() {
  
  ::source::v1alpha1::Integration* temp = integration_;
  integration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::source::v1alpha1::Integration* GetIntegrationResponse::unsafe_arena_release_integration() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.GetIntegrationResponse.integration)
  
  ::source::v1alpha1::Integration* temp = integration_;
  integration_ = nullptr;
  return temp;
}
inline ::source::v1alpha1::Integration* GetIntegrationResponse::_internal_mutable_integration() {
  
  if (integration_ == nullptr) {
    auto* p = CreateMaybeMessage<::source::v1alpha1::Integration>(GetArenaForAllocation());
    integration_ = p;
  }
  return integration_;
}
inline ::source::v1alpha1::Integration* GetIntegrationResponse::mutable_integration() {
  ::source::v1alpha1::Integration* _msg = _internal_mutable_integration();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.GetIntegrationResponse.integration)
  return _msg;
}
inline void GetIntegrationResponse::set_allocated_integration(::source::v1alpha1::Integration* integration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete integration_;
  }
  if (integration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::source::v1alpha1::Integration>::GetOwningArena(integration);
    if (message_arena != submessage_arena) {
      integration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, integration, submessage_arena);
    }
    
  } else {
    
  }
  integration_ = integration;
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.GetIntegrationResponse.integration)
}

// -------------------------------------------------------------------

// UpdateIntegrationRequest

// string id = 1 [json_name = "id"];
inline void UpdateIntegrationRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UpdateIntegrationRequest::id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.UpdateIntegrationRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateIntegrationRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.UpdateIntegrationRequest.id)
}
inline std::string* UpdateIntegrationRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.UpdateIntegrationRequest.id)
  return _s;
}
inline const std::string& UpdateIntegrationRequest::_internal_id() const {
  return id_.Get();
}
inline void UpdateIntegrationRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateIntegrationRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateIntegrationRequest::release_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.UpdateIntegrationRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateIntegrationRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.UpdateIntegrationRequest.id)
}

// .source.v1alpha1.CreateIntegrationRequest integrations = 2 [json_name = "integrations"];
inline bool UpdateIntegrationRequest::_internal_has_integrations() const {
  return this != internal_default_instance() && integrations_ != nullptr;
}
inline bool UpdateIntegrationRequest::has_integrations() const {
  return _internal_has_integrations();
}
inline void UpdateIntegrationRequest::clear_integrations() {
  if (GetArenaForAllocation() == nullptr && integrations_ != nullptr) {
    delete integrations_;
  }
  integrations_ = nullptr;
}
inline const ::source::v1alpha1::CreateIntegrationRequest& UpdateIntegrationRequest::_internal_integrations() const {
  const ::source::v1alpha1::CreateIntegrationRequest* p = integrations_;
  return p != nullptr ? *p : reinterpret_cast<const ::source::v1alpha1::CreateIntegrationRequest&>(
      ::source::v1alpha1::_CreateIntegrationRequest_default_instance_);
}
inline const ::source::v1alpha1::CreateIntegrationRequest& UpdateIntegrationRequest::integrations() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.UpdateIntegrationRequest.integrations)
  return _internal_integrations();
}
inline void UpdateIntegrationRequest::unsafe_arena_set_allocated_integrations(
    ::source::v1alpha1::CreateIntegrationRequest* integrations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(integrations_);
  }
  integrations_ = integrations;
  if (integrations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:source.v1alpha1.UpdateIntegrationRequest.integrations)
}
inline ::source::v1alpha1::CreateIntegrationRequest* UpdateIntegrationRequest::release_integrations() {
  
  ::source::v1alpha1::CreateIntegrationRequest* temp = integrations_;
  integrations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::source::v1alpha1::CreateIntegrationRequest* UpdateIntegrationRequest::unsafe_arena_release_integrations() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.UpdateIntegrationRequest.integrations)
  
  ::source::v1alpha1::CreateIntegrationRequest* temp = integrations_;
  integrations_ = nullptr;
  return temp;
}
inline ::source::v1alpha1::CreateIntegrationRequest* UpdateIntegrationRequest::_internal_mutable_integrations() {
  
  if (integrations_ == nullptr) {
    auto* p = CreateMaybeMessage<::source::v1alpha1::CreateIntegrationRequest>(GetArenaForAllocation());
    integrations_ = p;
  }
  return integrations_;
}
inline ::source::v1alpha1::CreateIntegrationRequest* UpdateIntegrationRequest::mutable_integrations() {
  ::source::v1alpha1::CreateIntegrationRequest* _msg = _internal_mutable_integrations();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.UpdateIntegrationRequest.integrations)
  return _msg;
}
inline void UpdateIntegrationRequest::set_allocated_integrations(::source::v1alpha1::CreateIntegrationRequest* integrations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete integrations_;
  }
  if (integrations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::source::v1alpha1::CreateIntegrationRequest>::GetOwningArena(integrations);
    if (message_arena != submessage_arena) {
      integrations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, integrations, submessage_arena);
    }
    
  } else {
    
  }
  integrations_ = integrations;
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.UpdateIntegrationRequest.integrations)
}

// -------------------------------------------------------------------

// UpdateIntegrationResponse

// string msg = 1 [json_name = "msg"];
inline void UpdateIntegrationResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& UpdateIntegrationResponse::msg() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.UpdateIntegrationResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateIntegrationResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.UpdateIntegrationResponse.msg)
}
inline std::string* UpdateIntegrationResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.UpdateIntegrationResponse.msg)
  return _s;
}
inline const std::string& UpdateIntegrationResponse::_internal_msg() const {
  return msg_.Get();
}
inline void UpdateIntegrationResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateIntegrationResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateIntegrationResponse::release_msg() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.UpdateIntegrationResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateIntegrationResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.UpdateIntegrationResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void UpdateIntegrationResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& UpdateIntegrationResponse::error() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.UpdateIntegrationResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateIntegrationResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.UpdateIntegrationResponse.error)
}
inline std::string* UpdateIntegrationResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.UpdateIntegrationResponse.error)
  return _s;
}
inline const std::string& UpdateIntegrationResponse::_internal_error() const {
  return error_.Get();
}
inline void UpdateIntegrationResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateIntegrationResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateIntegrationResponse::release_error() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.UpdateIntegrationResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateIntegrationResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.UpdateIntegrationResponse.error)
}

// -------------------------------------------------------------------

// DeleteIntegrationRequest

// string id = 1 [json_name = "id"];
inline void DeleteIntegrationRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteIntegrationRequest::id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DeleteIntegrationRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteIntegrationRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DeleteIntegrationRequest.id)
}
inline std::string* DeleteIntegrationRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DeleteIntegrationRequest.id)
  return _s;
}
inline const std::string& DeleteIntegrationRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteIntegrationRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteIntegrationRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteIntegrationRequest::release_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DeleteIntegrationRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteIntegrationRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DeleteIntegrationRequest.id)
}

// -------------------------------------------------------------------

// DeleteIntegrationResponse

// string msg = 1 [json_name = "msg"];
inline void DeleteIntegrationResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& DeleteIntegrationResponse::msg() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DeleteIntegrationResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteIntegrationResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DeleteIntegrationResponse.msg)
}
inline std::string* DeleteIntegrationResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DeleteIntegrationResponse.msg)
  return _s;
}
inline const std::string& DeleteIntegrationResponse::_internal_msg() const {
  return msg_.Get();
}
inline void DeleteIntegrationResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteIntegrationResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteIntegrationResponse::release_msg() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DeleteIntegrationResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteIntegrationResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DeleteIntegrationResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void DeleteIntegrationResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& DeleteIntegrationResponse::error() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DeleteIntegrationResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteIntegrationResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DeleteIntegrationResponse.error)
}
inline std::string* DeleteIntegrationResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DeleteIntegrationResponse.error)
  return _s;
}
inline const std::string& DeleteIntegrationResponse::_internal_error() const {
  return error_.Get();
}
inline void DeleteIntegrationResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteIntegrationResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteIntegrationResponse::release_error() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DeleteIntegrationResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteIntegrationResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DeleteIntegrationResponse.error)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Provider

// string id = 1 [json_name = "id"];
inline void Provider::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Provider::id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Provider.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Provider::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.Provider.id)
}
inline std::string* Provider::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Provider.id)
  return _s;
}
inline const std::string& Provider::_internal_id() const {
  return id_.Get();
}
inline void Provider::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Provider::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Provider::release_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Provider.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Provider::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Provider.id)
}

// string name = 2 [json_name = "name"];
inline void Provider::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Provider::name() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Provider.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Provider::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.Provider.name)
}
inline std::string* Provider::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Provider.name)
  return _s;
}
inline const std::string& Provider::_internal_name() const {
  return name_.Get();
}
inline void Provider::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Provider::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Provider::release_name() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Provider.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Provider::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Provider.name)
}

// string description = 3 [json_name = "description"];
inline void Provider::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& Provider::description() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Provider.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Provider::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.Provider.description)
}
inline std::string* Provider::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Provider.description)
  return _s;
}
inline const std::string& Provider::_internal_description() const {
  return description_.Get();
}
inline void Provider::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Provider::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Provider::release_description() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Provider.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Provider::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Provider.description)
}

// string logo = 4 [json_name = "logo"];
inline void Provider::clear_logo() {
  logo_.ClearToEmpty();
}
inline const std::string& Provider::logo() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.Provider.logo)
  return _internal_logo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Provider::set_logo(ArgT0&& arg0, ArgT... args) {
 
 logo_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.Provider.logo)
}
inline std::string* Provider::mutable_logo() {
  std::string* _s = _internal_mutable_logo();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.Provider.logo)
  return _s;
}
inline const std::string& Provider::_internal_logo() const {
  return logo_.Get();
}
inline void Provider::_internal_set_logo(const std::string& value) {
  
  logo_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Provider::_internal_mutable_logo() {
  
  return logo_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Provider::release_logo() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.Provider.logo)
  return logo_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Provider::set_allocated_logo(std::string* logo) {
  if (logo != nullptr) {
    
  } else {
    
  }
  logo_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logo,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.Provider.logo)
}

// map<string, string> data = 5 [json_name = "data"];
inline int Provider::_internal_data_size() const {
  return data_.size();
}
inline int Provider::data_size() const {
  return _internal_data_size();
}
inline void Provider::clear_data() {
  data_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Provider::_internal_data() const {
  return data_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Provider::data() const {
  // @@protoc_insertion_point(field_map:source.v1alpha1.Provider.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Provider::_internal_mutable_data() {
  return data_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Provider::mutable_data() {
  // @@protoc_insertion_point(field_mutable_map:source.v1alpha1.Provider.data)
  return _internal_mutable_data();
}

// map<string, string> metadata = 6 [json_name = "metadata"];
inline int Provider::_internal_metadata_size() const {
  return metadata_.size();
}
inline int Provider::metadata_size() const {
  return _internal_metadata_size();
}
inline void Provider::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Provider::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Provider::metadata() const {
  // @@protoc_insertion_point(field_map:source.v1alpha1.Provider.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Provider::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Provider::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:source.v1alpha1.Provider.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// DeleteProviderRequest

// string id = 1 [json_name = "id"];
inline void DeleteProviderRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteProviderRequest::id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DeleteProviderRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteProviderRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DeleteProviderRequest.id)
}
inline std::string* DeleteProviderRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DeleteProviderRequest.id)
  return _s;
}
inline const std::string& DeleteProviderRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteProviderRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteProviderRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteProviderRequest::release_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DeleteProviderRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteProviderRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DeleteProviderRequest.id)
}

// -------------------------------------------------------------------

// DeleteProviderResponse

// string msg = 1 [json_name = "msg"];
inline void DeleteProviderResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& DeleteProviderResponse::msg() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DeleteProviderResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteProviderResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DeleteProviderResponse.msg)
}
inline std::string* DeleteProviderResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DeleteProviderResponse.msg)
  return _s;
}
inline const std::string& DeleteProviderResponse::_internal_msg() const {
  return msg_.Get();
}
inline void DeleteProviderResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteProviderResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteProviderResponse::release_msg() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DeleteProviderResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteProviderResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DeleteProviderResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void DeleteProviderResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& DeleteProviderResponse::error() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.DeleteProviderResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteProviderResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.DeleteProviderResponse.error)
}
inline std::string* DeleteProviderResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.DeleteProviderResponse.error)
  return _s;
}
inline const std::string& DeleteProviderResponse::_internal_error() const {
  return error_.Get();
}
inline void DeleteProviderResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteProviderResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteProviderResponse::release_error() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.DeleteProviderResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteProviderResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.DeleteProviderResponse.error)
}

// -------------------------------------------------------------------

// UpdateProviderRequest

// string id = 1 [json_name = "id"];
inline void UpdateProviderRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UpdateProviderRequest::id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.UpdateProviderRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateProviderRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.UpdateProviderRequest.id)
}
inline std::string* UpdateProviderRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.UpdateProviderRequest.id)
  return _s;
}
inline const std::string& UpdateProviderRequest::_internal_id() const {
  return id_.Get();
}
inline void UpdateProviderRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateProviderRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateProviderRequest::release_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.UpdateProviderRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateProviderRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.UpdateProviderRequest.id)
}

// .source.v1alpha1.CreateProviderRequest provider = 2 [json_name = "provider"];
inline bool UpdateProviderRequest::_internal_has_provider() const {
  return this != internal_default_instance() && provider_ != nullptr;
}
inline bool UpdateProviderRequest::has_provider() const {
  return _internal_has_provider();
}
inline void UpdateProviderRequest::clear_provider() {
  if (GetArenaForAllocation() == nullptr && provider_ != nullptr) {
    delete provider_;
  }
  provider_ = nullptr;
}
inline const ::source::v1alpha1::CreateProviderRequest& UpdateProviderRequest::_internal_provider() const {
  const ::source::v1alpha1::CreateProviderRequest* p = provider_;
  return p != nullptr ? *p : reinterpret_cast<const ::source::v1alpha1::CreateProviderRequest&>(
      ::source::v1alpha1::_CreateProviderRequest_default_instance_);
}
inline const ::source::v1alpha1::CreateProviderRequest& UpdateProviderRequest::provider() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.UpdateProviderRequest.provider)
  return _internal_provider();
}
inline void UpdateProviderRequest::unsafe_arena_set_allocated_provider(
    ::source::v1alpha1::CreateProviderRequest* provider) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(provider_);
  }
  provider_ = provider;
  if (provider) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:source.v1alpha1.UpdateProviderRequest.provider)
}
inline ::source::v1alpha1::CreateProviderRequest* UpdateProviderRequest::release_provider() {
  
  ::source::v1alpha1::CreateProviderRequest* temp = provider_;
  provider_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::source::v1alpha1::CreateProviderRequest* UpdateProviderRequest::unsafe_arena_release_provider() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.UpdateProviderRequest.provider)
  
  ::source::v1alpha1::CreateProviderRequest* temp = provider_;
  provider_ = nullptr;
  return temp;
}
inline ::source::v1alpha1::CreateProviderRequest* UpdateProviderRequest::_internal_mutable_provider() {
  
  if (provider_ == nullptr) {
    auto* p = CreateMaybeMessage<::source::v1alpha1::CreateProviderRequest>(GetArenaForAllocation());
    provider_ = p;
  }
  return provider_;
}
inline ::source::v1alpha1::CreateProviderRequest* UpdateProviderRequest::mutable_provider() {
  ::source::v1alpha1::CreateProviderRequest* _msg = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.UpdateProviderRequest.provider)
  return _msg;
}
inline void UpdateProviderRequest::set_allocated_provider(::source::v1alpha1::CreateProviderRequest* provider) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete provider_;
  }
  if (provider) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::source::v1alpha1::CreateProviderRequest>::GetOwningArena(provider);
    if (message_arena != submessage_arena) {
      provider = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, provider, submessage_arena);
    }
    
  } else {
    
  }
  provider_ = provider;
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.UpdateProviderRequest.provider)
}

// -------------------------------------------------------------------

// UpdateProviderResponse

// string msg = 1 [json_name = "msg"];
inline void UpdateProviderResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& UpdateProviderResponse::msg() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.UpdateProviderResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateProviderResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.UpdateProviderResponse.msg)
}
inline std::string* UpdateProviderResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.UpdateProviderResponse.msg)
  return _s;
}
inline const std::string& UpdateProviderResponse::_internal_msg() const {
  return msg_.Get();
}
inline void UpdateProviderResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateProviderResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateProviderResponse::release_msg() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.UpdateProviderResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateProviderResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.UpdateProviderResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void UpdateProviderResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& UpdateProviderResponse::error() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.UpdateProviderResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateProviderResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.UpdateProviderResponse.error)
}
inline std::string* UpdateProviderResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.UpdateProviderResponse.error)
  return _s;
}
inline const std::string& UpdateProviderResponse::_internal_error() const {
  return error_.Get();
}
inline void UpdateProviderResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateProviderResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateProviderResponse::release_error() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.UpdateProviderResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateProviderResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.UpdateProviderResponse.error)
}

// -------------------------------------------------------------------

// GetProviderRequest

// string id = 1 [json_name = "id"];
inline void GetProviderRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetProviderRequest::id() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.GetProviderRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProviderRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.GetProviderRequest.id)
}
inline std::string* GetProviderRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.GetProviderRequest.id)
  return _s;
}
inline const std::string& GetProviderRequest::_internal_id() const {
  return id_.Get();
}
inline void GetProviderRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetProviderRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetProviderRequest::release_id() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.GetProviderRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetProviderRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.GetProviderRequest.id)
}

// -------------------------------------------------------------------

// GetProviderResponse

// .source.v1alpha1.Provider provider = 1 [json_name = "provider"];
inline bool GetProviderResponse::_internal_has_provider() const {
  return this != internal_default_instance() && provider_ != nullptr;
}
inline bool GetProviderResponse::has_provider() const {
  return _internal_has_provider();
}
inline void GetProviderResponse::clear_provider() {
  if (GetArenaForAllocation() == nullptr && provider_ != nullptr) {
    delete provider_;
  }
  provider_ = nullptr;
}
inline const ::source::v1alpha1::Provider& GetProviderResponse::_internal_provider() const {
  const ::source::v1alpha1::Provider* p = provider_;
  return p != nullptr ? *p : reinterpret_cast<const ::source::v1alpha1::Provider&>(
      ::source::v1alpha1::_Provider_default_instance_);
}
inline const ::source::v1alpha1::Provider& GetProviderResponse::provider() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.GetProviderResponse.provider)
  return _internal_provider();
}
inline void GetProviderResponse::unsafe_arena_set_allocated_provider(
    ::source::v1alpha1::Provider* provider) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(provider_);
  }
  provider_ = provider;
  if (provider) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:source.v1alpha1.GetProviderResponse.provider)
}
inline ::source::v1alpha1::Provider* GetProviderResponse::release_provider() {
  
  ::source::v1alpha1::Provider* temp = provider_;
  provider_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::source::v1alpha1::Provider* GetProviderResponse::unsafe_arena_release_provider() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.GetProviderResponse.provider)
  
  ::source::v1alpha1::Provider* temp = provider_;
  provider_ = nullptr;
  return temp;
}
inline ::source::v1alpha1::Provider* GetProviderResponse::_internal_mutable_provider() {
  
  if (provider_ == nullptr) {
    auto* p = CreateMaybeMessage<::source::v1alpha1::Provider>(GetArenaForAllocation());
    provider_ = p;
  }
  return provider_;
}
inline ::source::v1alpha1::Provider* GetProviderResponse::mutable_provider() {
  ::source::v1alpha1::Provider* _msg = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.GetProviderResponse.provider)
  return _msg;
}
inline void GetProviderResponse::set_allocated_provider(::source::v1alpha1::Provider* provider) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete provider_;
  }
  if (provider) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::source::v1alpha1::Provider>::GetOwningArena(provider);
    if (message_arena != submessage_arena) {
      provider = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, provider, submessage_arena);
    }
    
  } else {
    
  }
  provider_ = provider;
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.GetProviderResponse.provider)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateProviderRequest

// string name = 1 [json_name = "name"];
inline void CreateProviderRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateProviderRequest::name() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateProviderRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateProviderRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateProviderRequest.name)
}
inline std::string* CreateProviderRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateProviderRequest.name)
  return _s;
}
inline const std::string& CreateProviderRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateProviderRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateProviderRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateProviderRequest::release_name() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateProviderRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateProviderRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateProviderRequest.name)
}

// string description = 2 [json_name = "description"];
inline void CreateProviderRequest::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& CreateProviderRequest::description() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateProviderRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateProviderRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateProviderRequest.description)
}
inline std::string* CreateProviderRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateProviderRequest.description)
  return _s;
}
inline const std::string& CreateProviderRequest::_internal_description() const {
  return description_.Get();
}
inline void CreateProviderRequest::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateProviderRequest::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateProviderRequest::release_description() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateProviderRequest.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateProviderRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateProviderRequest.description)
}

// string logo = 3 [json_name = "logo"];
inline void CreateProviderRequest::clear_logo() {
  logo_.ClearToEmpty();
}
inline const std::string& CreateProviderRequest::logo() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateProviderRequest.logo)
  return _internal_logo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateProviderRequest::set_logo(ArgT0&& arg0, ArgT... args) {
 
 logo_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateProviderRequest.logo)
}
inline std::string* CreateProviderRequest::mutable_logo() {
  std::string* _s = _internal_mutable_logo();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateProviderRequest.logo)
  return _s;
}
inline const std::string& CreateProviderRequest::_internal_logo() const {
  return logo_.Get();
}
inline void CreateProviderRequest::_internal_set_logo(const std::string& value) {
  
  logo_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateProviderRequest::_internal_mutable_logo() {
  
  return logo_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateProviderRequest::release_logo() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateProviderRequest.logo)
  return logo_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateProviderRequest::set_allocated_logo(std::string* logo) {
  if (logo != nullptr) {
    
  } else {
    
  }
  logo_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logo,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateProviderRequest.logo)
}

// map<string, string> data = 5 [json_name = "data"];
inline int CreateProviderRequest::_internal_data_size() const {
  return data_.size();
}
inline int CreateProviderRequest::data_size() const {
  return _internal_data_size();
}
inline void CreateProviderRequest::clear_data() {
  data_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateProviderRequest::_internal_data() const {
  return data_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateProviderRequest::data() const {
  // @@protoc_insertion_point(field_map:source.v1alpha1.CreateProviderRequest.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateProviderRequest::_internal_mutable_data() {
  return data_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateProviderRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable_map:source.v1alpha1.CreateProviderRequest.data)
  return _internal_mutable_data();
}

// map<string, string> metadata = 6 [json_name = "metadata"];
inline int CreateProviderRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int CreateProviderRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void CreateProviderRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateProviderRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateProviderRequest::metadata() const {
  // @@protoc_insertion_point(field_map:source.v1alpha1.CreateProviderRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateProviderRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateProviderRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:source.v1alpha1.CreateProviderRequest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// CreateProviderResponse

// string msg = 1 [json_name = "msg"];
inline void CreateProviderResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& CreateProviderResponse::msg() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateProviderResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateProviderResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateProviderResponse.msg)
}
inline std::string* CreateProviderResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateProviderResponse.msg)
  return _s;
}
inline const std::string& CreateProviderResponse::_internal_msg() const {
  return msg_.Get();
}
inline void CreateProviderResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateProviderResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateProviderResponse::release_msg() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateProviderResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateProviderResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateProviderResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void CreateProviderResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& CreateProviderResponse::error() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.CreateProviderResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateProviderResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:source.v1alpha1.CreateProviderResponse.error)
}
inline std::string* CreateProviderResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.CreateProviderResponse.error)
  return _s;
}
inline const std::string& CreateProviderResponse::_internal_error() const {
  return error_.Get();
}
inline void CreateProviderResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateProviderResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateProviderResponse::release_error() {
  // @@protoc_insertion_point(field_release:source.v1alpha1.CreateProviderResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateProviderResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:source.v1alpha1.CreateProviderResponse.error)
}

// -------------------------------------------------------------------

// ListProvidersRequest

// -------------------------------------------------------------------

// ListProvidersResponse

// repeated .source.v1alpha1.Provider providers = 1 [json_name = "providers"];
inline int ListProvidersResponse::_internal_providers_size() const {
  return providers_.size();
}
inline int ListProvidersResponse::providers_size() const {
  return _internal_providers_size();
}
inline void ListProvidersResponse::clear_providers() {
  providers_.Clear();
}
inline ::source::v1alpha1::Provider* ListProvidersResponse::mutable_providers(int index) {
  // @@protoc_insertion_point(field_mutable:source.v1alpha1.ListProvidersResponse.providers)
  return providers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Provider >*
ListProvidersResponse::mutable_providers() {
  // @@protoc_insertion_point(field_mutable_list:source.v1alpha1.ListProvidersResponse.providers)
  return &providers_;
}
inline const ::source::v1alpha1::Provider& ListProvidersResponse::_internal_providers(int index) const {
  return providers_.Get(index);
}
inline const ::source::v1alpha1::Provider& ListProvidersResponse::providers(int index) const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListProvidersResponse.providers)
  return _internal_providers(index);
}
inline ::source::v1alpha1::Provider* ListProvidersResponse::_internal_add_providers() {
  return providers_.Add();
}
inline ::source::v1alpha1::Provider* ListProvidersResponse::add_providers() {
  ::source::v1alpha1::Provider* _add = _internal_add_providers();
  // @@protoc_insertion_point(field_add:source.v1alpha1.ListProvidersResponse.providers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::source::v1alpha1::Provider >&
ListProvidersResponse::providers() const {
  // @@protoc_insertion_point(field_list:source.v1alpha1.ListProvidersResponse.providers)
  return providers_;
}

// uint32 total_pages = 2 [json_name = "totalPages"];
inline void ListProvidersResponse::clear_total_pages() {
  total_pages_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListProvidersResponse::_internal_total_pages() const {
  return total_pages_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListProvidersResponse::total_pages() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListProvidersResponse.total_pages)
  return _internal_total_pages();
}
inline void ListProvidersResponse::_internal_set_total_pages(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  total_pages_ = value;
}
inline void ListProvidersResponse::set_total_pages(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_total_pages(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListProvidersResponse.total_pages)
}

// uint32 count = 3 [json_name = "count"];
inline void ListProvidersResponse::clear_count() {
  count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListProvidersResponse::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListProvidersResponse::count() const {
  // @@protoc_insertion_point(field_get:source.v1alpha1.ListProvidersResponse.count)
  return _internal_count();
}
inline void ListProvidersResponse::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  count_ = value;
}
inline void ListProvidersResponse::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:source.v1alpha1.ListProvidersResponse.count)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace source

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_source_2fv1alpha1_2fsource_2eproto
