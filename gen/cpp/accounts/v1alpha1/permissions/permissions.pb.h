// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: accounts/v1alpha1/permissions/permissions.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "accounts/v1alpha1/accounts.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto;
namespace accounts {
namespace v1alpha1 {
namespace permissions {
namespace v1 {
class AssignPermissionRequest;
struct AssignPermissionRequestDefaultTypeInternal;
extern AssignPermissionRequestDefaultTypeInternal _AssignPermissionRequest_default_instance_;
class CategoryPermission;
struct CategoryPermissionDefaultTypeInternal;
extern CategoryPermissionDefaultTypeInternal _CategoryPermission_default_instance_;
class CreatePermissionRequest;
struct CreatePermissionRequestDefaultTypeInternal;
extern CreatePermissionRequestDefaultTypeInternal _CreatePermissionRequest_default_instance_;
class CreatePermissionResponse;
struct CreatePermissionResponseDefaultTypeInternal;
extern CreatePermissionResponseDefaultTypeInternal _CreatePermissionResponse_default_instance_;
class DeletePermissionRequest;
struct DeletePermissionRequestDefaultTypeInternal;
extern DeletePermissionRequestDefaultTypeInternal _DeletePermissionRequest_default_instance_;
class DeletePermissionResponse;
struct DeletePermissionResponseDefaultTypeInternal;
extern DeletePermissionResponseDefaultTypeInternal _DeletePermissionResponse_default_instance_;
class GetOnePermissionRequest;
struct GetOnePermissionRequestDefaultTypeInternal;
extern GetOnePermissionRequestDefaultTypeInternal _GetOnePermissionRequest_default_instance_;
class GetOnePermissionResponse;
struct GetOnePermissionResponseDefaultTypeInternal;
extern GetOnePermissionResponseDefaultTypeInternal _GetOnePermissionResponse_default_instance_;
class GroupPermission;
struct GroupPermissionDefaultTypeInternal;
extern GroupPermissionDefaultTypeInternal _GroupPermission_default_instance_;
class ListPermissionRequest;
struct ListPermissionRequestDefaultTypeInternal;
extern ListPermissionRequestDefaultTypeInternal _ListPermissionRequest_default_instance_;
class ListPermissionResponse;
struct ListPermissionResponseDefaultTypeInternal;
extern ListPermissionResponseDefaultTypeInternal _ListPermissionResponse_default_instance_;
class UpdatePermissionRequest;
struct UpdatePermissionRequestDefaultTypeInternal;
extern UpdatePermissionRequestDefaultTypeInternal _UpdatePermissionRequest_default_instance_;
class UpdatePermissionResponse;
struct UpdatePermissionResponseDefaultTypeInternal;
extern UpdatePermissionResponseDefaultTypeInternal _UpdatePermissionResponse_default_instance_;
}  // namespace v1
}  // namespace permissions
}  // namespace v1alpha1
}  // namespace accounts
PROTOBUF_NAMESPACE_OPEN
template<> ::accounts::v1alpha1::permissions::v1::AssignPermissionRequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::permissions::v1::AssignPermissionRequest>(Arena*);
template<> ::accounts::v1alpha1::permissions::v1::CategoryPermission* Arena::CreateMaybeMessage<::accounts::v1alpha1::permissions::v1::CategoryPermission>(Arena*);
template<> ::accounts::v1alpha1::permissions::v1::CreatePermissionRequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::permissions::v1::CreatePermissionRequest>(Arena*);
template<> ::accounts::v1alpha1::permissions::v1::CreatePermissionResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::permissions::v1::CreatePermissionResponse>(Arena*);
template<> ::accounts::v1alpha1::permissions::v1::DeletePermissionRequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::permissions::v1::DeletePermissionRequest>(Arena*);
template<> ::accounts::v1alpha1::permissions::v1::DeletePermissionResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::permissions::v1::DeletePermissionResponse>(Arena*);
template<> ::accounts::v1alpha1::permissions::v1::GetOnePermissionRequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::permissions::v1::GetOnePermissionRequest>(Arena*);
template<> ::accounts::v1alpha1::permissions::v1::GetOnePermissionResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::permissions::v1::GetOnePermissionResponse>(Arena*);
template<> ::accounts::v1alpha1::permissions::v1::GroupPermission* Arena::CreateMaybeMessage<::accounts::v1alpha1::permissions::v1::GroupPermission>(Arena*);
template<> ::accounts::v1alpha1::permissions::v1::ListPermissionRequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::permissions::v1::ListPermissionRequest>(Arena*);
template<> ::accounts::v1alpha1::permissions::v1::ListPermissionResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::permissions::v1::ListPermissionResponse>(Arena*);
template<> ::accounts::v1alpha1::permissions::v1::UpdatePermissionRequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::permissions::v1::UpdatePermissionRequest>(Arena*);
template<> ::accounts::v1alpha1::permissions::v1::UpdatePermissionResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::permissions::v1::UpdatePermissionResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace accounts {
namespace v1alpha1 {
namespace permissions {
namespace v1 {

// ===================================================================

class ListPermissionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.permissions.v1.ListPermissionRequest) */ {
 public:
  inline ListPermissionRequest() : ListPermissionRequest(nullptr) {}
  ~ListPermissionRequest() override;
  explicit constexpr ListPermissionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPermissionRequest(const ListPermissionRequest& from);
  ListPermissionRequest(ListPermissionRequest&& from) noexcept
    : ListPermissionRequest() {
    *this = ::std::move(from);
  }

  inline ListPermissionRequest& operator=(const ListPermissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPermissionRequest& operator=(ListPermissionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPermissionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPermissionRequest* internal_default_instance() {
    return reinterpret_cast<const ListPermissionRequest*>(
               &_ListPermissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ListPermissionRequest& a, ListPermissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPermissionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPermissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPermissionRequest* New() const final {
    return new ListPermissionRequest();
  }

  ListPermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPermissionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPermissionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPermissionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPermissionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.permissions.v1.ListPermissionRequest";
  }
  protected:
  explicit ListPermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.permissions.v1.ListPermissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto;
};
// -------------------------------------------------------------------

class CreatePermissionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.permissions.v1.CreatePermissionRequest) */ {
 public:
  inline CreatePermissionRequest() : CreatePermissionRequest(nullptr) {}
  ~CreatePermissionRequest() override;
  explicit constexpr CreatePermissionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatePermissionRequest(const CreatePermissionRequest& from);
  CreatePermissionRequest(CreatePermissionRequest&& from) noexcept
    : CreatePermissionRequest() {
    *this = ::std::move(from);
  }

  inline CreatePermissionRequest& operator=(const CreatePermissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePermissionRequest& operator=(CreatePermissionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePermissionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePermissionRequest* internal_default_instance() {
    return reinterpret_cast<const CreatePermissionRequest*>(
               &_CreatePermissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreatePermissionRequest& a, CreatePermissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatePermissionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePermissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreatePermissionRequest* New() const final {
    return new CreatePermissionRequest();
  }

  CreatePermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreatePermissionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatePermissionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreatePermissionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePermissionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.permissions.v1.CreatePermissionRequest";
  }
  protected:
  explicit CreatePermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kCategoryFieldNumber = 3,
    kActionFieldNumber = 4,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string type = 2 [json_name = "type"];
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string category = 3 [json_name = "category"];
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_MUST_USE_RESULT std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string action = 4 [json_name = "action"];
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_MUST_USE_RESULT std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.permissions.v1.CreatePermissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto;
};
// -------------------------------------------------------------------

class UpdatePermissionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.permissions.v1.UpdatePermissionRequest) */ {
 public:
  inline UpdatePermissionRequest() : UpdatePermissionRequest(nullptr) {}
  ~UpdatePermissionRequest() override;
  explicit constexpr UpdatePermissionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdatePermissionRequest(const UpdatePermissionRequest& from);
  UpdatePermissionRequest(UpdatePermissionRequest&& from) noexcept
    : UpdatePermissionRequest() {
    *this = ::std::move(from);
  }

  inline UpdatePermissionRequest& operator=(const UpdatePermissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePermissionRequest& operator=(UpdatePermissionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePermissionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePermissionRequest* internal_default_instance() {
    return reinterpret_cast<const UpdatePermissionRequest*>(
               &_UpdatePermissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UpdatePermissionRequest& a, UpdatePermissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePermissionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePermissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdatePermissionRequest* New() const final {
    return new UpdatePermissionRequest();
  }

  UpdatePermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePermissionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdatePermissionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdatePermissionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePermissionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.permissions.v1.UpdatePermissionRequest";
  }
  protected:
  explicit UpdatePermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTypeFieldNumber = 3,
    kPermissionIdFieldNumber = 1,
  };
  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string type = 3 [json_name = "type"];
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // uint32 permission_id = 1 [json_name = "permissionId"];
  void clear_permission_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 permission_id() const;
  void set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_permission_id() const;
  void _internal_set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.permissions.v1.UpdatePermissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 permission_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto;
};
// -------------------------------------------------------------------

class GetOnePermissionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.permissions.v1.GetOnePermissionRequest) */ {
 public:
  inline GetOnePermissionRequest() : GetOnePermissionRequest(nullptr) {}
  ~GetOnePermissionRequest() override;
  explicit constexpr GetOnePermissionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOnePermissionRequest(const GetOnePermissionRequest& from);
  GetOnePermissionRequest(GetOnePermissionRequest&& from) noexcept
    : GetOnePermissionRequest() {
    *this = ::std::move(from);
  }

  inline GetOnePermissionRequest& operator=(const GetOnePermissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOnePermissionRequest& operator=(GetOnePermissionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOnePermissionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOnePermissionRequest* internal_default_instance() {
    return reinterpret_cast<const GetOnePermissionRequest*>(
               &_GetOnePermissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetOnePermissionRequest& a, GetOnePermissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOnePermissionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOnePermissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetOnePermissionRequest* New() const final {
    return new GetOnePermissionRequest();
  }

  GetOnePermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOnePermissionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOnePermissionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOnePermissionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOnePermissionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.permissions.v1.GetOnePermissionRequest";
  }
  protected:
  explicit GetOnePermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionIdFieldNumber = 1,
  };
  // uint32 permission_id = 1 [json_name = "permissionId"];
  void clear_permission_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 permission_id() const;
  void set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_permission_id() const;
  void _internal_set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.permissions.v1.GetOnePermissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 permission_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto;
};
// -------------------------------------------------------------------

class GetOnePermissionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.permissions.v1.GetOnePermissionResponse) */ {
 public:
  inline GetOnePermissionResponse() : GetOnePermissionResponse(nullptr) {}
  ~GetOnePermissionResponse() override;
  explicit constexpr GetOnePermissionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOnePermissionResponse(const GetOnePermissionResponse& from);
  GetOnePermissionResponse(GetOnePermissionResponse&& from) noexcept
    : GetOnePermissionResponse() {
    *this = ::std::move(from);
  }

  inline GetOnePermissionResponse& operator=(const GetOnePermissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOnePermissionResponse& operator=(GetOnePermissionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOnePermissionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOnePermissionResponse* internal_default_instance() {
    return reinterpret_cast<const GetOnePermissionResponse*>(
               &_GetOnePermissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetOnePermissionResponse& a, GetOnePermissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOnePermissionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOnePermissionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetOnePermissionResponse* New() const final {
    return new GetOnePermissionResponse();
  }

  GetOnePermissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOnePermissionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOnePermissionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOnePermissionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOnePermissionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.permissions.v1.GetOnePermissionResponse";
  }
  protected:
  explicit GetOnePermissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTypeFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string type = 3 [json_name = "type"];
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // uint32 id = 1 [json_name = "id"];
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.permissions.v1.GetOnePermissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto;
};
// -------------------------------------------------------------------

class DeletePermissionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.permissions.v1.DeletePermissionRequest) */ {
 public:
  inline DeletePermissionRequest() : DeletePermissionRequest(nullptr) {}
  ~DeletePermissionRequest() override;
  explicit constexpr DeletePermissionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePermissionRequest(const DeletePermissionRequest& from);
  DeletePermissionRequest(DeletePermissionRequest&& from) noexcept
    : DeletePermissionRequest() {
    *this = ::std::move(from);
  }

  inline DeletePermissionRequest& operator=(const DeletePermissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePermissionRequest& operator=(DeletePermissionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePermissionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePermissionRequest* internal_default_instance() {
    return reinterpret_cast<const DeletePermissionRequest*>(
               &_DeletePermissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeletePermissionRequest& a, DeletePermissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePermissionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePermissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeletePermissionRequest* New() const final {
    return new DeletePermissionRequest();
  }

  DeletePermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeletePermissionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePermissionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeletePermissionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePermissionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.permissions.v1.DeletePermissionRequest";
  }
  protected:
  explicit DeletePermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionIdFieldNumber = 1,
  };
  // uint32 permission_id = 1 [json_name = "permissionId"];
  void clear_permission_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 permission_id() const;
  void set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_permission_id() const;
  void _internal_set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.permissions.v1.DeletePermissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 permission_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto;
};
// -------------------------------------------------------------------

class UpdatePermissionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.permissions.v1.UpdatePermissionResponse) */ {
 public:
  inline UpdatePermissionResponse() : UpdatePermissionResponse(nullptr) {}
  ~UpdatePermissionResponse() override;
  explicit constexpr UpdatePermissionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdatePermissionResponse(const UpdatePermissionResponse& from);
  UpdatePermissionResponse(UpdatePermissionResponse&& from) noexcept
    : UpdatePermissionResponse() {
    *this = ::std::move(from);
  }

  inline UpdatePermissionResponse& operator=(const UpdatePermissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePermissionResponse& operator=(UpdatePermissionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePermissionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePermissionResponse* internal_default_instance() {
    return reinterpret_cast<const UpdatePermissionResponse*>(
               &_UpdatePermissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdatePermissionResponse& a, UpdatePermissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePermissionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePermissionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdatePermissionResponse* New() const final {
    return new UpdatePermissionResponse();
  }

  UpdatePermissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePermissionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdatePermissionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdatePermissionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePermissionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.permissions.v1.UpdatePermissionResponse";
  }
  protected:
  explicit UpdatePermissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.permissions.v1.UpdatePermissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto;
};
// -------------------------------------------------------------------

class DeletePermissionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.permissions.v1.DeletePermissionResponse) */ {
 public:
  inline DeletePermissionResponse() : DeletePermissionResponse(nullptr) {}
  ~DeletePermissionResponse() override;
  explicit constexpr DeletePermissionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePermissionResponse(const DeletePermissionResponse& from);
  DeletePermissionResponse(DeletePermissionResponse&& from) noexcept
    : DeletePermissionResponse() {
    *this = ::std::move(from);
  }

  inline DeletePermissionResponse& operator=(const DeletePermissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePermissionResponse& operator=(DeletePermissionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePermissionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePermissionResponse* internal_default_instance() {
    return reinterpret_cast<const DeletePermissionResponse*>(
               &_DeletePermissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeletePermissionResponse& a, DeletePermissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePermissionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePermissionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeletePermissionResponse* New() const final {
    return new DeletePermissionResponse();
  }

  DeletePermissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeletePermissionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePermissionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeletePermissionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePermissionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.permissions.v1.DeletePermissionResponse";
  }
  protected:
  explicit DeletePermissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.permissions.v1.DeletePermissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto;
};
// -------------------------------------------------------------------

class CreatePermissionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.permissions.v1.CreatePermissionResponse) */ {
 public:
  inline CreatePermissionResponse() : CreatePermissionResponse(nullptr) {}
  ~CreatePermissionResponse() override;
  explicit constexpr CreatePermissionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatePermissionResponse(const CreatePermissionResponse& from);
  CreatePermissionResponse(CreatePermissionResponse&& from) noexcept
    : CreatePermissionResponse() {
    *this = ::std::move(from);
  }

  inline CreatePermissionResponse& operator=(const CreatePermissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePermissionResponse& operator=(CreatePermissionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePermissionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePermissionResponse* internal_default_instance() {
    return reinterpret_cast<const CreatePermissionResponse*>(
               &_CreatePermissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CreatePermissionResponse& a, CreatePermissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatePermissionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePermissionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreatePermissionResponse* New() const final {
    return new CreatePermissionResponse();
  }

  CreatePermissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreatePermissionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatePermissionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreatePermissionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePermissionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.permissions.v1.CreatePermissionResponse";
  }
  protected:
  explicit CreatePermissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.permissions.v1.CreatePermissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto;
};
// -------------------------------------------------------------------

class ListPermissionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.permissions.v1.ListPermissionResponse) */ {
 public:
  inline ListPermissionResponse() : ListPermissionResponse(nullptr) {}
  ~ListPermissionResponse() override;
  explicit constexpr ListPermissionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPermissionResponse(const ListPermissionResponse& from);
  ListPermissionResponse(ListPermissionResponse&& from) noexcept
    : ListPermissionResponse() {
    *this = ::std::move(from);
  }

  inline ListPermissionResponse& operator=(const ListPermissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPermissionResponse& operator=(ListPermissionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPermissionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPermissionResponse* internal_default_instance() {
    return reinterpret_cast<const ListPermissionResponse*>(
               &_ListPermissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListPermissionResponse& a, ListPermissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPermissionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPermissionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPermissionResponse* New() const final {
    return new ListPermissionResponse();
  }

  ListPermissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPermissionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPermissionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPermissionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPermissionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.permissions.v1.ListPermissionResponse";
  }
  protected:
  explicit ListPermissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoriesPermissionsFieldNumber = 1,
  };
  // repeated .accounts.v1alpha1.permissions.v1.CategoryPermission categories_permissions = 1 [json_name = "categoriesPermissions"];
  int categories_permissions_size() const;
  private:
  int _internal_categories_permissions_size() const;
  public:
  void clear_categories_permissions();
  ::accounts::v1alpha1::permissions::v1::CategoryPermission* mutable_categories_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::permissions::v1::CategoryPermission >*
      mutable_categories_permissions();
  private:
  const ::accounts::v1alpha1::permissions::v1::CategoryPermission& _internal_categories_permissions(int index) const;
  ::accounts::v1alpha1::permissions::v1::CategoryPermission* _internal_add_categories_permissions();
  public:
  const ::accounts::v1alpha1::permissions::v1::CategoryPermission& categories_permissions(int index) const;
  ::accounts::v1alpha1::permissions::v1::CategoryPermission* add_categories_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::permissions::v1::CategoryPermission >&
      categories_permissions() const;

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.permissions.v1.ListPermissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::permissions::v1::CategoryPermission > categories_permissions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto;
};
// -------------------------------------------------------------------

class AssignPermissionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.permissions.v1.AssignPermissionRequest) */ {
 public:
  inline AssignPermissionRequest() : AssignPermissionRequest(nullptr) {}
  ~AssignPermissionRequest() override;
  explicit constexpr AssignPermissionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssignPermissionRequest(const AssignPermissionRequest& from);
  AssignPermissionRequest(AssignPermissionRequest&& from) noexcept
    : AssignPermissionRequest() {
    *this = ::std::move(from);
  }

  inline AssignPermissionRequest& operator=(const AssignPermissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssignPermissionRequest& operator=(AssignPermissionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssignPermissionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssignPermissionRequest* internal_default_instance() {
    return reinterpret_cast<const AssignPermissionRequest*>(
               &_AssignPermissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AssignPermissionRequest& a, AssignPermissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AssignPermissionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssignPermissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AssignPermissionRequest* New() const final {
    return new AssignPermissionRequest();
  }

  AssignPermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AssignPermissionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssignPermissionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AssignPermissionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssignPermissionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.permissions.v1.AssignPermissionRequest";
  }
  protected:
  explicit AssignPermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kPermissionIdFieldNumber = 2,
  };
  // uint32 user_id = 1 [json_name = "userId"];
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 permission_id = 2 [json_name = "permissionId"];
  void clear_permission_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 permission_id() const;
  void set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_permission_id() const;
  void _internal_set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.permissions.v1.AssignPermissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 permission_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto;
};
// -------------------------------------------------------------------

class GroupPermission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.permissions.v1.GroupPermission) */ {
 public:
  inline GroupPermission() : GroupPermission(nullptr) {}
  ~GroupPermission() override;
  explicit constexpr GroupPermission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupPermission(const GroupPermission& from);
  GroupPermission(GroupPermission&& from) noexcept
    : GroupPermission() {
    *this = ::std::move(from);
  }

  inline GroupPermission& operator=(const GroupPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupPermission& operator=(GroupPermission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupPermission& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupPermission* internal_default_instance() {
    return reinterpret_cast<const GroupPermission*>(
               &_GroupPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GroupPermission& a, GroupPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupPermission* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupPermission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GroupPermission* New() const final {
    return new GroupPermission();
  }

  GroupPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GroupPermission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupPermission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GroupPermission& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupPermission* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.permissions.v1.GroupPermission";
  }
  protected:
  explicit GroupPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 3,
    kNameFieldNumber = 1,
  };
  // repeated .accounts.v1alpha1.Permission permissions = 3 [json_name = "permissions"];
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::accounts::v1alpha1::Permission* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::Permission >*
      mutable_permissions();
  private:
  const ::accounts::v1alpha1::Permission& _internal_permissions(int index) const;
  ::accounts::v1alpha1::Permission* _internal_add_permissions();
  public:
  const ::accounts::v1alpha1::Permission& permissions(int index) const;
  ::accounts::v1alpha1::Permission* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::Permission >&
      permissions() const;

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.permissions.v1.GroupPermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::Permission > permissions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto;
};
// -------------------------------------------------------------------

class CategoryPermission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.permissions.v1.CategoryPermission) */ {
 public:
  inline CategoryPermission() : CategoryPermission(nullptr) {}
  ~CategoryPermission() override;
  explicit constexpr CategoryPermission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CategoryPermission(const CategoryPermission& from);
  CategoryPermission(CategoryPermission&& from) noexcept
    : CategoryPermission() {
    *this = ::std::move(from);
  }

  inline CategoryPermission& operator=(const CategoryPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline CategoryPermission& operator=(CategoryPermission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CategoryPermission& default_instance() {
    return *internal_default_instance();
  }
  static inline const CategoryPermission* internal_default_instance() {
    return reinterpret_cast<const CategoryPermission*>(
               &_CategoryPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CategoryPermission& a, CategoryPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(CategoryPermission* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CategoryPermission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CategoryPermission* New() const final {
    return new CategoryPermission();
  }

  CategoryPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CategoryPermission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CategoryPermission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CategoryPermission& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CategoryPermission* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.permissions.v1.CategoryPermission";
  }
  protected:
  explicit CategoryPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupPermissionsFieldNumber = 3,
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // repeated .accounts.v1alpha1.permissions.v1.GroupPermission group_permissions = 3 [json_name = "groupPermissions"];
  int group_permissions_size() const;
  private:
  int _internal_group_permissions_size() const;
  public:
  void clear_group_permissions();
  ::accounts::v1alpha1::permissions::v1::GroupPermission* mutable_group_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::permissions::v1::GroupPermission >*
      mutable_group_permissions();
  private:
  const ::accounts::v1alpha1::permissions::v1::GroupPermission& _internal_group_permissions(int index) const;
  ::accounts::v1alpha1::permissions::v1::GroupPermission* _internal_add_group_permissions();
  public:
  const ::accounts::v1alpha1::permissions::v1::GroupPermission& group_permissions(int index) const;
  ::accounts::v1alpha1::permissions::v1::GroupPermission* add_group_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::permissions::v1::GroupPermission >&
      group_permissions() const;

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string type = 2 [json_name = "type"];
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.permissions.v1.CategoryPermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::permissions::v1::GroupPermission > group_permissions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ListPermissionRequest

// -------------------------------------------------------------------

// CreatePermissionRequest

// string name = 1 [json_name = "name"];
inline void CreatePermissionRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreatePermissionRequest::name() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePermissionRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.name)
}
inline std::string* CreatePermissionRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.name)
  return _s;
}
inline const std::string& CreatePermissionRequest::_internal_name() const {
  return name_.Get();
}
inline void CreatePermissionRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePermissionRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePermissionRequest::release_name() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePermissionRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.name)
}

// string type = 2 [json_name = "type"];
inline void CreatePermissionRequest::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& CreatePermissionRequest::type() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePermissionRequest::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.type)
}
inline std::string* CreatePermissionRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.type)
  return _s;
}
inline const std::string& CreatePermissionRequest::_internal_type() const {
  return type_.Get();
}
inline void CreatePermissionRequest::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePermissionRequest::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePermissionRequest::release_type() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePermissionRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.type)
}

// string category = 3 [json_name = "category"];
inline void CreatePermissionRequest::clear_category() {
  category_.ClearToEmpty();
}
inline const std::string& CreatePermissionRequest::category() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePermissionRequest::set_category(ArgT0&& arg0, ArgT... args) {
 
 category_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.category)
}
inline std::string* CreatePermissionRequest::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.category)
  return _s;
}
inline const std::string& CreatePermissionRequest::_internal_category() const {
  return category_.Get();
}
inline void CreatePermissionRequest::_internal_set_category(const std::string& value) {
  
  category_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePermissionRequest::_internal_mutable_category() {
  
  return category_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePermissionRequest::release_category() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.category)
  return category_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePermissionRequest::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  category_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), category,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.category)
}

// string action = 4 [json_name = "action"];
inline void CreatePermissionRequest::clear_action() {
  action_.ClearToEmpty();
}
inline const std::string& CreatePermissionRequest::action() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePermissionRequest::set_action(ArgT0&& arg0, ArgT... args) {
 
 action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.action)
}
inline std::string* CreatePermissionRequest::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.action)
  return _s;
}
inline const std::string& CreatePermissionRequest::_internal_action() const {
  return action_.Get();
}
inline void CreatePermissionRequest::_internal_set_action(const std::string& value) {
  
  action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePermissionRequest::_internal_mutable_action() {
  
  return action_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePermissionRequest::release_action() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.action)
  return action_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePermissionRequest::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    
  } else {
    
  }
  action_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), action,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.CreatePermissionRequest.action)
}

// -------------------------------------------------------------------

// UpdatePermissionRequest

// uint32 permission_id = 1 [json_name = "permissionId"];
inline void UpdatePermissionRequest::clear_permission_id() {
  permission_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdatePermissionRequest::_internal_permission_id() const {
  return permission_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdatePermissionRequest::permission_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.UpdatePermissionRequest.permission_id)
  return _internal_permission_id();
}
inline void UpdatePermissionRequest::_internal_set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  permission_id_ = value;
}
inline void UpdatePermissionRequest::set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_permission_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.UpdatePermissionRequest.permission_id)
}

// string name = 2 [json_name = "name"];
inline void UpdatePermissionRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& UpdatePermissionRequest::name() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.UpdatePermissionRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdatePermissionRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.UpdatePermissionRequest.name)
}
inline std::string* UpdatePermissionRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.UpdatePermissionRequest.name)
  return _s;
}
inline const std::string& UpdatePermissionRequest::_internal_name() const {
  return name_.Get();
}
inline void UpdatePermissionRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdatePermissionRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdatePermissionRequest::release_name() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.UpdatePermissionRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdatePermissionRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.UpdatePermissionRequest.name)
}

// string type = 3 [json_name = "type"];
inline void UpdatePermissionRequest::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& UpdatePermissionRequest::type() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.UpdatePermissionRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdatePermissionRequest::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.UpdatePermissionRequest.type)
}
inline std::string* UpdatePermissionRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.UpdatePermissionRequest.type)
  return _s;
}
inline const std::string& UpdatePermissionRequest::_internal_type() const {
  return type_.Get();
}
inline void UpdatePermissionRequest::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdatePermissionRequest::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdatePermissionRequest::release_type() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.UpdatePermissionRequest.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdatePermissionRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.UpdatePermissionRequest.type)
}

// -------------------------------------------------------------------

// GetOnePermissionRequest

// uint32 permission_id = 1 [json_name = "permissionId"];
inline void GetOnePermissionRequest::clear_permission_id() {
  permission_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOnePermissionRequest::_internal_permission_id() const {
  return permission_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOnePermissionRequest::permission_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.GetOnePermissionRequest.permission_id)
  return _internal_permission_id();
}
inline void GetOnePermissionRequest::_internal_set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  permission_id_ = value;
}
inline void GetOnePermissionRequest::set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_permission_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.GetOnePermissionRequest.permission_id)
}

// -------------------------------------------------------------------

// GetOnePermissionResponse

// uint32 id = 1 [json_name = "id"];
inline void GetOnePermissionResponse::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOnePermissionResponse::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOnePermissionResponse::id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.GetOnePermissionResponse.id)
  return _internal_id();
}
inline void GetOnePermissionResponse::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void GetOnePermissionResponse::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.GetOnePermissionResponse.id)
}

// string name = 2 [json_name = "name"];
inline void GetOnePermissionResponse::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GetOnePermissionResponse::name() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.GetOnePermissionResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOnePermissionResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.GetOnePermissionResponse.name)
}
inline std::string* GetOnePermissionResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.GetOnePermissionResponse.name)
  return _s;
}
inline const std::string& GetOnePermissionResponse::_internal_name() const {
  return name_.Get();
}
inline void GetOnePermissionResponse::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOnePermissionResponse::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOnePermissionResponse::release_name() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.GetOnePermissionResponse.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOnePermissionResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.GetOnePermissionResponse.name)
}

// string type = 3 [json_name = "type"];
inline void GetOnePermissionResponse::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& GetOnePermissionResponse::type() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.GetOnePermissionResponse.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOnePermissionResponse::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.GetOnePermissionResponse.type)
}
inline std::string* GetOnePermissionResponse::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.GetOnePermissionResponse.type)
  return _s;
}
inline const std::string& GetOnePermissionResponse::_internal_type() const {
  return type_.Get();
}
inline void GetOnePermissionResponse::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOnePermissionResponse::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOnePermissionResponse::release_type() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.GetOnePermissionResponse.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOnePermissionResponse::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.GetOnePermissionResponse.type)
}

// -------------------------------------------------------------------

// DeletePermissionRequest

// uint32 permission_id = 1 [json_name = "permissionId"];
inline void DeletePermissionRequest::clear_permission_id() {
  permission_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeletePermissionRequest::_internal_permission_id() const {
  return permission_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeletePermissionRequest::permission_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.DeletePermissionRequest.permission_id)
  return _internal_permission_id();
}
inline void DeletePermissionRequest::_internal_set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  permission_id_ = value;
}
inline void DeletePermissionRequest::set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_permission_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.DeletePermissionRequest.permission_id)
}

// -------------------------------------------------------------------

// UpdatePermissionResponse

// string msg = 1 [json_name = "msg"];
inline void UpdatePermissionResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& UpdatePermissionResponse::msg() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.UpdatePermissionResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdatePermissionResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.UpdatePermissionResponse.msg)
}
inline std::string* UpdatePermissionResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.UpdatePermissionResponse.msg)
  return _s;
}
inline const std::string& UpdatePermissionResponse::_internal_msg() const {
  return msg_.Get();
}
inline void UpdatePermissionResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdatePermissionResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdatePermissionResponse::release_msg() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.UpdatePermissionResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdatePermissionResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.UpdatePermissionResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void UpdatePermissionResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& UpdatePermissionResponse::error() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.UpdatePermissionResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdatePermissionResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.UpdatePermissionResponse.error)
}
inline std::string* UpdatePermissionResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.UpdatePermissionResponse.error)
  return _s;
}
inline const std::string& UpdatePermissionResponse::_internal_error() const {
  return error_.Get();
}
inline void UpdatePermissionResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdatePermissionResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdatePermissionResponse::release_error() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.UpdatePermissionResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdatePermissionResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.UpdatePermissionResponse.error)
}

// -------------------------------------------------------------------

// DeletePermissionResponse

// string msg = 1 [json_name = "msg"];
inline void DeletePermissionResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& DeletePermissionResponse::msg() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.DeletePermissionResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePermissionResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.DeletePermissionResponse.msg)
}
inline std::string* DeletePermissionResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.DeletePermissionResponse.msg)
  return _s;
}
inline const std::string& DeletePermissionResponse::_internal_msg() const {
  return msg_.Get();
}
inline void DeletePermissionResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePermissionResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePermissionResponse::release_msg() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.DeletePermissionResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePermissionResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.DeletePermissionResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void DeletePermissionResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& DeletePermissionResponse::error() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.DeletePermissionResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeletePermissionResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.DeletePermissionResponse.error)
}
inline std::string* DeletePermissionResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.DeletePermissionResponse.error)
  return _s;
}
inline const std::string& DeletePermissionResponse::_internal_error() const {
  return error_.Get();
}
inline void DeletePermissionResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeletePermissionResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeletePermissionResponse::release_error() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.DeletePermissionResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeletePermissionResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.DeletePermissionResponse.error)
}

// -------------------------------------------------------------------

// CreatePermissionResponse

// string msg = 1 [json_name = "msg"];
inline void CreatePermissionResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& CreatePermissionResponse::msg() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.CreatePermissionResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePermissionResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.CreatePermissionResponse.msg)
}
inline std::string* CreatePermissionResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.CreatePermissionResponse.msg)
  return _s;
}
inline const std::string& CreatePermissionResponse::_internal_msg() const {
  return msg_.Get();
}
inline void CreatePermissionResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePermissionResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePermissionResponse::release_msg() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.CreatePermissionResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePermissionResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.CreatePermissionResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void CreatePermissionResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& CreatePermissionResponse::error() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.CreatePermissionResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatePermissionResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.CreatePermissionResponse.error)
}
inline std::string* CreatePermissionResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.CreatePermissionResponse.error)
  return _s;
}
inline const std::string& CreatePermissionResponse::_internal_error() const {
  return error_.Get();
}
inline void CreatePermissionResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatePermissionResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatePermissionResponse::release_error() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.CreatePermissionResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatePermissionResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.CreatePermissionResponse.error)
}

// -------------------------------------------------------------------

// ListPermissionResponse

// repeated .accounts.v1alpha1.permissions.v1.CategoryPermission categories_permissions = 1 [json_name = "categoriesPermissions"];
inline int ListPermissionResponse::_internal_categories_permissions_size() const {
  return categories_permissions_.size();
}
inline int ListPermissionResponse::categories_permissions_size() const {
  return _internal_categories_permissions_size();
}
inline void ListPermissionResponse::clear_categories_permissions() {
  categories_permissions_.Clear();
}
inline ::accounts::v1alpha1::permissions::v1::CategoryPermission* ListPermissionResponse::mutable_categories_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.ListPermissionResponse.categories_permissions)
  return categories_permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::permissions::v1::CategoryPermission >*
ListPermissionResponse::mutable_categories_permissions() {
  // @@protoc_insertion_point(field_mutable_list:accounts.v1alpha1.permissions.v1.ListPermissionResponse.categories_permissions)
  return &categories_permissions_;
}
inline const ::accounts::v1alpha1::permissions::v1::CategoryPermission& ListPermissionResponse::_internal_categories_permissions(int index) const {
  return categories_permissions_.Get(index);
}
inline const ::accounts::v1alpha1::permissions::v1::CategoryPermission& ListPermissionResponse::categories_permissions(int index) const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.ListPermissionResponse.categories_permissions)
  return _internal_categories_permissions(index);
}
inline ::accounts::v1alpha1::permissions::v1::CategoryPermission* ListPermissionResponse::_internal_add_categories_permissions() {
  return categories_permissions_.Add();
}
inline ::accounts::v1alpha1::permissions::v1::CategoryPermission* ListPermissionResponse::add_categories_permissions() {
  ::accounts::v1alpha1::permissions::v1::CategoryPermission* _add = _internal_add_categories_permissions();
  // @@protoc_insertion_point(field_add:accounts.v1alpha1.permissions.v1.ListPermissionResponse.categories_permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::permissions::v1::CategoryPermission >&
ListPermissionResponse::categories_permissions() const {
  // @@protoc_insertion_point(field_list:accounts.v1alpha1.permissions.v1.ListPermissionResponse.categories_permissions)
  return categories_permissions_;
}

// -------------------------------------------------------------------

// AssignPermissionRequest

// uint32 user_id = 1 [json_name = "userId"];
inline void AssignPermissionRequest::clear_user_id() {
  user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AssignPermissionRequest::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AssignPermissionRequest::user_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.AssignPermissionRequest.user_id)
  return _internal_user_id();
}
inline void AssignPermissionRequest::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  user_id_ = value;
}
inline void AssignPermissionRequest::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.AssignPermissionRequest.user_id)
}

// uint32 permission_id = 2 [json_name = "permissionId"];
inline void AssignPermissionRequest::clear_permission_id() {
  permission_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AssignPermissionRequest::_internal_permission_id() const {
  return permission_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AssignPermissionRequest::permission_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.AssignPermissionRequest.permission_id)
  return _internal_permission_id();
}
inline void AssignPermissionRequest::_internal_set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  permission_id_ = value;
}
inline void AssignPermissionRequest::set_permission_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_permission_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.AssignPermissionRequest.permission_id)
}

// -------------------------------------------------------------------

// GroupPermission

// string name = 1 [json_name = "name"];
inline void GroupPermission::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GroupPermission::name() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.GroupPermission.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupPermission::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.GroupPermission.name)
}
inline std::string* GroupPermission::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.GroupPermission.name)
  return _s;
}
inline const std::string& GroupPermission::_internal_name() const {
  return name_.Get();
}
inline void GroupPermission::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GroupPermission::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GroupPermission::release_name() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.GroupPermission.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GroupPermission::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.GroupPermission.name)
}

// repeated .accounts.v1alpha1.Permission permissions = 3 [json_name = "permissions"];
inline int GroupPermission::_internal_permissions_size() const {
  return permissions_.size();
}
inline int GroupPermission::permissions_size() const {
  return _internal_permissions_size();
}
inline ::accounts::v1alpha1::Permission* GroupPermission::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.GroupPermission.permissions)
  return permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::Permission >*
GroupPermission::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:accounts.v1alpha1.permissions.v1.GroupPermission.permissions)
  return &permissions_;
}
inline const ::accounts::v1alpha1::Permission& GroupPermission::_internal_permissions(int index) const {
  return permissions_.Get(index);
}
inline const ::accounts::v1alpha1::Permission& GroupPermission::permissions(int index) const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.GroupPermission.permissions)
  return _internal_permissions(index);
}
inline ::accounts::v1alpha1::Permission* GroupPermission::_internal_add_permissions() {
  return permissions_.Add();
}
inline ::accounts::v1alpha1::Permission* GroupPermission::add_permissions() {
  ::accounts::v1alpha1::Permission* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:accounts.v1alpha1.permissions.v1.GroupPermission.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::Permission >&
GroupPermission::permissions() const {
  // @@protoc_insertion_point(field_list:accounts.v1alpha1.permissions.v1.GroupPermission.permissions)
  return permissions_;
}

// -------------------------------------------------------------------

// CategoryPermission

// string name = 1 [json_name = "name"];
inline void CategoryPermission::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CategoryPermission::name() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.CategoryPermission.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CategoryPermission::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.CategoryPermission.name)
}
inline std::string* CategoryPermission::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.CategoryPermission.name)
  return _s;
}
inline const std::string& CategoryPermission::_internal_name() const {
  return name_.Get();
}
inline void CategoryPermission::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CategoryPermission::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CategoryPermission::release_name() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.CategoryPermission.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CategoryPermission::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.CategoryPermission.name)
}

// string type = 2 [json_name = "type"];
inline void CategoryPermission::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& CategoryPermission::type() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.CategoryPermission.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CategoryPermission::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.permissions.v1.CategoryPermission.type)
}
inline std::string* CategoryPermission::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.CategoryPermission.type)
  return _s;
}
inline const std::string& CategoryPermission::_internal_type() const {
  return type_.Get();
}
inline void CategoryPermission::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CategoryPermission::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CategoryPermission::release_type() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.permissions.v1.CategoryPermission.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CategoryPermission::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.permissions.v1.CategoryPermission.type)
}

// repeated .accounts.v1alpha1.permissions.v1.GroupPermission group_permissions = 3 [json_name = "groupPermissions"];
inline int CategoryPermission::_internal_group_permissions_size() const {
  return group_permissions_.size();
}
inline int CategoryPermission::group_permissions_size() const {
  return _internal_group_permissions_size();
}
inline void CategoryPermission::clear_group_permissions() {
  group_permissions_.Clear();
}
inline ::accounts::v1alpha1::permissions::v1::GroupPermission* CategoryPermission::mutable_group_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.permissions.v1.CategoryPermission.group_permissions)
  return group_permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::permissions::v1::GroupPermission >*
CategoryPermission::mutable_group_permissions() {
  // @@protoc_insertion_point(field_mutable_list:accounts.v1alpha1.permissions.v1.CategoryPermission.group_permissions)
  return &group_permissions_;
}
inline const ::accounts::v1alpha1::permissions::v1::GroupPermission& CategoryPermission::_internal_group_permissions(int index) const {
  return group_permissions_.Get(index);
}
inline const ::accounts::v1alpha1::permissions::v1::GroupPermission& CategoryPermission::group_permissions(int index) const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.permissions.v1.CategoryPermission.group_permissions)
  return _internal_group_permissions(index);
}
inline ::accounts::v1alpha1::permissions::v1::GroupPermission* CategoryPermission::_internal_add_group_permissions() {
  return group_permissions_.Add();
}
inline ::accounts::v1alpha1::permissions::v1::GroupPermission* CategoryPermission::add_group_permissions() {
  ::accounts::v1alpha1::permissions::v1::GroupPermission* _add = _internal_add_group_permissions();
  // @@protoc_insertion_point(field_add:accounts.v1alpha1.permissions.v1.CategoryPermission.group_permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::permissions::v1::GroupPermission >&
CategoryPermission::group_permissions() const {
  // @@protoc_insertion_point(field_list:accounts.v1alpha1.permissions.v1.CategoryPermission.group_permissions)
  return group_permissions_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace permissions
}  // namespace v1alpha1
}  // namespace accounts

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_accounts_2fv1alpha1_2fpermissions_2fpermissions_2eproto
