// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: accounts/v1alpha1/tokens/tokens_api.proto
#ifndef GRPC_accounts_2fv1alpha1_2ftokens_2ftokens_5fapi_2eproto__INCLUDED
#define GRPC_accounts_2fv1alpha1_2ftokens_2ftokens_5fapi_2eproto__INCLUDED

#include "accounts/v1alpha1/tokens/tokens_api.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace accounts {
namespace v1alpha1 {
namespace tokens {
namespace v1 {

class TokenService final {
 public:
  static constexpr char const* service_full_name() {
    return "accounts.v1alpha1.tokens.v1.TokenService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // TOKEN CCP
    virtual ::grpc::Status CreateTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest& request, ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>> AsyncCreateTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>>(AsyncCreateTokenCCPRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>> PrepareAsyncCreateTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>>(PrepareAsyncCreateTokenCCPRaw(context, request, cq));
    }
    virtual ::grpc::Status GetOneTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest& request, ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>> AsyncGetOneTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>>(AsyncGetOneTokenCCPRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>> PrepareAsyncGetOneTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>>(PrepareAsyncGetOneTokenCCPRaw(context, request, cq));
    }
    // Get Users Email filter
    // LOGS REDIS
    virtual ::grpc::Status Logs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest& request, ::accounts::v1alpha1::tokens::v1::LogsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::LogsResponse>> AsyncLogs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::LogsResponse>>(AsyncLogsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::LogsResponse>> PrepareAsyncLogs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::LogsResponse>>(PrepareAsyncLogsRaw(context, request, cq));
    }
    virtual ::grpc::Status SaveLogs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest& request, ::accounts::v1alpha1::tokens::v1::SaveLogsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::SaveLogsResponse>> AsyncSaveLogs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::SaveLogsResponse>>(AsyncSaveLogsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::SaveLogsResponse>> PrepareAsyncSaveLogs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::SaveLogsResponse>>(PrepareAsyncSaveLogsRaw(context, request, cq));
    }
    // DOBLE AUTHETICATION
    virtual ::grpc::Status MFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest& request, ::accounts::v1alpha1::tokens::v1::MFAResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::MFAResponse>> AsyncMFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::MFAResponse>>(AsyncMFARaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::MFAResponse>> PrepareAsyncMFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::MFAResponse>>(PrepareAsyncMFARaw(context, request, cq));
    }
    virtual ::grpc::Status EnableOrDisableMFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest& request, ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>> AsyncEnableOrDisableMFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>>(AsyncEnableOrDisableMFARaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>> PrepareAsyncEnableOrDisableMFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>>(PrepareAsyncEnableOrDisableMFARaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // TOKEN CCP
      virtual void CreateTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest* request, ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetOneTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest* request, ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Get Users Email filter
      // LOGS REDIS
      virtual void Logs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest* request, ::accounts::v1alpha1::tokens::v1::LogsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SaveLogs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest* request, ::accounts::v1alpha1::tokens::v1::SaveLogsResponse* response, std::function<void(::grpc::Status)>) = 0;
      // DOBLE AUTHETICATION
      virtual void MFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest* request, ::accounts::v1alpha1::tokens::v1::MFAResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EnableOrDisableMFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest* request, ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse* response, std::function<void(::grpc::Status)>) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>* AsyncCreateTokenCCPRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>* PrepareAsyncCreateTokenCCPRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>* AsyncGetOneTokenCCPRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>* PrepareAsyncGetOneTokenCCPRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::LogsResponse>* AsyncLogsRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::LogsResponse>* PrepareAsyncLogsRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::SaveLogsResponse>* AsyncSaveLogsRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::SaveLogsResponse>* PrepareAsyncSaveLogsRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::MFAResponse>* AsyncMFARaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::MFAResponse>* PrepareAsyncMFARaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>* AsyncEnableOrDisableMFARaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>* PrepareAsyncEnableOrDisableMFARaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status CreateTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest& request, ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>> AsyncCreateTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>>(AsyncCreateTokenCCPRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>> PrepareAsyncCreateTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>>(PrepareAsyncCreateTokenCCPRaw(context, request, cq));
    }
    ::grpc::Status GetOneTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest& request, ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>> AsyncGetOneTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>>(AsyncGetOneTokenCCPRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>> PrepareAsyncGetOneTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>>(PrepareAsyncGetOneTokenCCPRaw(context, request, cq));
    }
    ::grpc::Status Logs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest& request, ::accounts::v1alpha1::tokens::v1::LogsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::LogsResponse>> AsyncLogs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::LogsResponse>>(AsyncLogsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::LogsResponse>> PrepareAsyncLogs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::LogsResponse>>(PrepareAsyncLogsRaw(context, request, cq));
    }
    ::grpc::Status SaveLogs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest& request, ::accounts::v1alpha1::tokens::v1::SaveLogsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::SaveLogsResponse>> AsyncSaveLogs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::SaveLogsResponse>>(AsyncSaveLogsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::SaveLogsResponse>> PrepareAsyncSaveLogs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::SaveLogsResponse>>(PrepareAsyncSaveLogsRaw(context, request, cq));
    }
    ::grpc::Status MFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest& request, ::accounts::v1alpha1::tokens::v1::MFAResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::MFAResponse>> AsyncMFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::MFAResponse>>(AsyncMFARaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::MFAResponse>> PrepareAsyncMFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::MFAResponse>>(PrepareAsyncMFARaw(context, request, cq));
    }
    ::grpc::Status EnableOrDisableMFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest& request, ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>> AsyncEnableOrDisableMFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>>(AsyncEnableOrDisableMFARaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>> PrepareAsyncEnableOrDisableMFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>>(PrepareAsyncEnableOrDisableMFARaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void CreateTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest* request, ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse* response, std::function<void(::grpc::Status)>) override;
      void GetOneTokenCCP(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest* request, ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse* response, std::function<void(::grpc::Status)>) override;
      void Logs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest* request, ::accounts::v1alpha1::tokens::v1::LogsResponse* response, std::function<void(::grpc::Status)>) override;
      void SaveLogs(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest* request, ::accounts::v1alpha1::tokens::v1::SaveLogsResponse* response, std::function<void(::grpc::Status)>) override;
      void MFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest* request, ::accounts::v1alpha1::tokens::v1::MFAResponse* response, std::function<void(::grpc::Status)>) override;
      void EnableOrDisableMFA(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest* request, ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse* response, std::function<void(::grpc::Status)>) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>* AsyncCreateTokenCCPRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>* PrepareAsyncCreateTokenCCPRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>* AsyncGetOneTokenCCPRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>* PrepareAsyncGetOneTokenCCPRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::LogsResponse>* AsyncLogsRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::LogsResponse>* PrepareAsyncLogsRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::SaveLogsResponse>* AsyncSaveLogsRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::SaveLogsResponse>* PrepareAsyncSaveLogsRaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::MFAResponse>* AsyncMFARaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::MFAResponse>* PrepareAsyncMFARaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>* AsyncEnableOrDisableMFARaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>* PrepareAsyncEnableOrDisableMFARaw(::grpc::ClientContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CreateTokenCCP_;
    const ::grpc::internal::RpcMethod rpcmethod_GetOneTokenCCP_;
    const ::grpc::internal::RpcMethod rpcmethod_Logs_;
    const ::grpc::internal::RpcMethod rpcmethod_SaveLogs_;
    const ::grpc::internal::RpcMethod rpcmethod_MFA_;
    const ::grpc::internal::RpcMethod rpcmethod_EnableOrDisableMFA_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // TOKEN CCP
    virtual ::grpc::Status CreateTokenCCP(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest* request, ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse* response);
    virtual ::grpc::Status GetOneTokenCCP(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest* request, ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse* response);
    // Get Users Email filter
    // LOGS REDIS
    virtual ::grpc::Status Logs(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest* request, ::accounts::v1alpha1::tokens::v1::LogsResponse* response);
    virtual ::grpc::Status SaveLogs(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest* request, ::accounts::v1alpha1::tokens::v1::SaveLogsResponse* response);
    // DOBLE AUTHETICATION
    virtual ::grpc::Status MFA(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest* request, ::accounts::v1alpha1::tokens::v1::MFAResponse* response);
    virtual ::grpc::Status EnableOrDisableMFA(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest* request, ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateTokenCCP : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CreateTokenCCP() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CreateTokenCCP() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTokenCCP(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest* request, ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateTokenCCP(::grpc::ServerContext* context, ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest* request, ::grpc::ServerAsyncResponseWriter< ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetOneTokenCCP : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetOneTokenCCP() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetOneTokenCCP() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOneTokenCCP(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest* request, ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOneTokenCCP(::grpc::ServerContext* context, ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest* request, ::grpc::ServerAsyncResponseWriter< ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Logs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Logs() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Logs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Logs(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest* request, ::accounts::v1alpha1::tokens::v1::LogsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogs(::grpc::ServerContext* context, ::accounts::v1alpha1::tokens::v1::LogsRequest* request, ::grpc::ServerAsyncResponseWriter< ::accounts::v1alpha1::tokens::v1::LogsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SaveLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SaveLogs() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SaveLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveLogs(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest* request, ::accounts::v1alpha1::tokens::v1::SaveLogsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSaveLogs(::grpc::ServerContext* context, ::accounts::v1alpha1::tokens::v1::SaveLogsRequest* request, ::grpc::ServerAsyncResponseWriter< ::accounts::v1alpha1::tokens::v1::SaveLogsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MFA : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_MFA() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_MFA() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MFA(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest* request, ::accounts::v1alpha1::tokens::v1::MFAResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMFA(::grpc::ServerContext* context, ::accounts::v1alpha1::tokens::v1::MFARequest* request, ::grpc::ServerAsyncResponseWriter< ::accounts::v1alpha1::tokens::v1::MFAResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EnableOrDisableMFA : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_EnableOrDisableMFA() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_EnableOrDisableMFA() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableOrDisableMFA(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest* request, ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableOrDisableMFA(::grpc::ServerContext* context, ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest* request, ::grpc::ServerAsyncResponseWriter< ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CreateTokenCCP<WithAsyncMethod_GetOneTokenCCP<WithAsyncMethod_Logs<WithAsyncMethod_SaveLogs<WithAsyncMethod_MFA<WithAsyncMethod_EnableOrDisableMFA<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_CreateTokenCCP : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CreateTokenCCP() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CreateTokenCCP() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTokenCCP(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest* request, ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetOneTokenCCP : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetOneTokenCCP() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetOneTokenCCP() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOneTokenCCP(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest* request, ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Logs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Logs() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Logs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Logs(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest* request, ::accounts::v1alpha1::tokens::v1::LogsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SaveLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SaveLogs() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SaveLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveLogs(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest* request, ::accounts::v1alpha1::tokens::v1::SaveLogsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MFA : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_MFA() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_MFA() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MFA(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest* request, ::accounts::v1alpha1::tokens::v1::MFAResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EnableOrDisableMFA : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_EnableOrDisableMFA() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_EnableOrDisableMFA() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableOrDisableMFA(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest* request, ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateTokenCCP : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CreateTokenCCP() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CreateTokenCCP() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTokenCCP(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest* request, ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateTokenCCP(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetOneTokenCCP : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetOneTokenCCP() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetOneTokenCCP() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOneTokenCCP(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest* request, ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOneTokenCCP(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Logs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Logs() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Logs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Logs(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest* request, ::accounts::v1alpha1::tokens::v1::LogsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SaveLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SaveLogs() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_SaveLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveLogs(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest* request, ::accounts::v1alpha1::tokens::v1::SaveLogsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSaveLogs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MFA : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_MFA() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_MFA() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MFA(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest* request, ::accounts::v1alpha1::tokens::v1::MFAResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMFA(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EnableOrDisableMFA : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_EnableOrDisableMFA() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_EnableOrDisableMFA() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableOrDisableMFA(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest* request, ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableOrDisableMFA(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateTokenCCP : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CreateTokenCCP() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest, ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>(std::bind(&WithStreamedUnaryMethod_CreateTokenCCP<BaseClass>::StreamedCreateTokenCCP, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateTokenCCP() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateTokenCCP(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest* request, ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateTokenCCP(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest,::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetOneTokenCCP : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetOneTokenCCP() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest, ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>(std::bind(&WithStreamedUnaryMethod_GetOneTokenCCP<BaseClass>::StreamedGetOneTokenCCP, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetOneTokenCCP() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetOneTokenCCP(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest* request, ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetOneTokenCCP(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest,::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Logs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Logs() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::accounts::v1alpha1::tokens::v1::LogsRequest, ::accounts::v1alpha1::tokens::v1::LogsResponse>(std::bind(&WithStreamedUnaryMethod_Logs<BaseClass>::StreamedLogs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Logs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Logs(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::LogsRequest* request, ::accounts::v1alpha1::tokens::v1::LogsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLogs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::accounts::v1alpha1::tokens::v1::LogsRequest,::accounts::v1alpha1::tokens::v1::LogsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SaveLogs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SaveLogs() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::accounts::v1alpha1::tokens::v1::SaveLogsRequest, ::accounts::v1alpha1::tokens::v1::SaveLogsResponse>(std::bind(&WithStreamedUnaryMethod_SaveLogs<BaseClass>::StreamedSaveLogs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SaveLogs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SaveLogs(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::SaveLogsRequest* request, ::accounts::v1alpha1::tokens::v1::SaveLogsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSaveLogs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::accounts::v1alpha1::tokens::v1::SaveLogsRequest,::accounts::v1alpha1::tokens::v1::SaveLogsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MFA : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_MFA() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::accounts::v1alpha1::tokens::v1::MFARequest, ::accounts::v1alpha1::tokens::v1::MFAResponse>(std::bind(&WithStreamedUnaryMethod_MFA<BaseClass>::StreamedMFA, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_MFA() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MFA(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::MFARequest* request, ::accounts::v1alpha1::tokens::v1::MFAResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMFA(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::accounts::v1alpha1::tokens::v1::MFARequest,::accounts::v1alpha1::tokens::v1::MFAResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EnableOrDisableMFA : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_EnableOrDisableMFA() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest, ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>(std::bind(&WithStreamedUnaryMethod_EnableOrDisableMFA<BaseClass>::StreamedEnableOrDisableMFA, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_EnableOrDisableMFA() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EnableOrDisableMFA(::grpc::ServerContext* context, const ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest* request, ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnableOrDisableMFA(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest,::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CreateTokenCCP<WithStreamedUnaryMethod_GetOneTokenCCP<WithStreamedUnaryMethod_Logs<WithStreamedUnaryMethod_SaveLogs<WithStreamedUnaryMethod_MFA<WithStreamedUnaryMethod_EnableOrDisableMFA<Service > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CreateTokenCCP<WithStreamedUnaryMethod_GetOneTokenCCP<WithStreamedUnaryMethod_Logs<WithStreamedUnaryMethod_SaveLogs<WithStreamedUnaryMethod_MFA<WithStreamedUnaryMethod_EnableOrDisableMFA<Service > > > > > > StreamedService;
};

}  // namespace v1
}  // namespace tokens
}  // namespace v1alpha1
}  // namespace accounts


#endif  // GRPC_accounts_2fv1alpha1_2ftokens_2ftokens_5fapi_2eproto__INCLUDED
