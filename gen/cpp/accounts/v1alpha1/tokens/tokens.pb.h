// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: accounts/v1alpha1/tokens/tokens.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto;
namespace accounts {
namespace v1alpha1 {
namespace tokens {
namespace v1 {
class CreateTokenCCPRequest;
struct CreateTokenCCPRequestDefaultTypeInternal;
extern CreateTokenCCPRequestDefaultTypeInternal _CreateTokenCCPRequest_default_instance_;
class CreateTokenCCPResponse;
struct CreateTokenCCPResponseDefaultTypeInternal;
extern CreateTokenCCPResponseDefaultTypeInternal _CreateTokenCCPResponse_default_instance_;
class EnableOrDisableMFARequest;
struct EnableOrDisableMFARequestDefaultTypeInternal;
extern EnableOrDisableMFARequestDefaultTypeInternal _EnableOrDisableMFARequest_default_instance_;
class EnableOrDisableMFAResponse;
struct EnableOrDisableMFAResponseDefaultTypeInternal;
extern EnableOrDisableMFAResponseDefaultTypeInternal _EnableOrDisableMFAResponse_default_instance_;
class GetOneTokenCCPRequest;
struct GetOneTokenCCPRequestDefaultTypeInternal;
extern GetOneTokenCCPRequestDefaultTypeInternal _GetOneTokenCCPRequest_default_instance_;
class GetOneTokenCCPResponse;
struct GetOneTokenCCPResponseDefaultTypeInternal;
extern GetOneTokenCCPResponseDefaultTypeInternal _GetOneTokenCCPResponse_default_instance_;
class Log;
struct LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class LogsRequest;
struct LogsRequestDefaultTypeInternal;
extern LogsRequestDefaultTypeInternal _LogsRequest_default_instance_;
class LogsResponse;
struct LogsResponseDefaultTypeInternal;
extern LogsResponseDefaultTypeInternal _LogsResponse_default_instance_;
class MFARequest;
struct MFARequestDefaultTypeInternal;
extern MFARequestDefaultTypeInternal _MFARequest_default_instance_;
class MFAResponse;
struct MFAResponseDefaultTypeInternal;
extern MFAResponseDefaultTypeInternal _MFAResponse_default_instance_;
class SaveLogsRequest;
struct SaveLogsRequestDefaultTypeInternal;
extern SaveLogsRequestDefaultTypeInternal _SaveLogsRequest_default_instance_;
class SaveLogsResponse;
struct SaveLogsResponseDefaultTypeInternal;
extern SaveLogsResponseDefaultTypeInternal _SaveLogsResponse_default_instance_;
}  // namespace v1
}  // namespace tokens
}  // namespace v1alpha1
}  // namespace accounts
PROTOBUF_NAMESPACE_OPEN
template<> ::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::tokens::v1::CreateTokenCCPRequest>(Arena*);
template<> ::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::tokens::v1::CreateTokenCCPResponse>(Arena*);
template<> ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::tokens::v1::EnableOrDisableMFARequest>(Arena*);
template<> ::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::tokens::v1::EnableOrDisableMFAResponse>(Arena*);
template<> ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::tokens::v1::GetOneTokenCCPRequest>(Arena*);
template<> ::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::tokens::v1::GetOneTokenCCPResponse>(Arena*);
template<> ::accounts::v1alpha1::tokens::v1::Log* Arena::CreateMaybeMessage<::accounts::v1alpha1::tokens::v1::Log>(Arena*);
template<> ::accounts::v1alpha1::tokens::v1::LogsRequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::tokens::v1::LogsRequest>(Arena*);
template<> ::accounts::v1alpha1::tokens::v1::LogsResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::tokens::v1::LogsResponse>(Arena*);
template<> ::accounts::v1alpha1::tokens::v1::MFARequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::tokens::v1::MFARequest>(Arena*);
template<> ::accounts::v1alpha1::tokens::v1::MFAResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::tokens::v1::MFAResponse>(Arena*);
template<> ::accounts::v1alpha1::tokens::v1::SaveLogsRequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::tokens::v1::SaveLogsRequest>(Arena*);
template<> ::accounts::v1alpha1::tokens::v1::SaveLogsResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::tokens::v1::SaveLogsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace accounts {
namespace v1alpha1 {
namespace tokens {
namespace v1 {

// ===================================================================

class GetOneTokenCCPRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.tokens.v1.GetOneTokenCCPRequest) */ {
 public:
  inline GetOneTokenCCPRequest() : GetOneTokenCCPRequest(nullptr) {}
  ~GetOneTokenCCPRequest() override;
  explicit constexpr GetOneTokenCCPRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOneTokenCCPRequest(const GetOneTokenCCPRequest& from);
  GetOneTokenCCPRequest(GetOneTokenCCPRequest&& from) noexcept
    : GetOneTokenCCPRequest() {
    *this = ::std::move(from);
  }

  inline GetOneTokenCCPRequest& operator=(const GetOneTokenCCPRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOneTokenCCPRequest& operator=(GetOneTokenCCPRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOneTokenCCPRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOneTokenCCPRequest* internal_default_instance() {
    return reinterpret_cast<const GetOneTokenCCPRequest*>(
               &_GetOneTokenCCPRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetOneTokenCCPRequest& a, GetOneTokenCCPRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOneTokenCCPRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOneTokenCCPRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetOneTokenCCPRequest* New() const final {
    return new GetOneTokenCCPRequest();
  }

  GetOneTokenCCPRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOneTokenCCPRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOneTokenCCPRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOneTokenCCPRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOneTokenCCPRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.tokens.v1.GetOneTokenCCPRequest";
  }
  protected:
  explicit GetOneTokenCCPRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1 [json_name = "token"];
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.tokens.v1.GetOneTokenCCPRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto;
};
// -------------------------------------------------------------------

class GetOneTokenCCPResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse) */ {
 public:
  inline GetOneTokenCCPResponse() : GetOneTokenCCPResponse(nullptr) {}
  ~GetOneTokenCCPResponse() override;
  explicit constexpr GetOneTokenCCPResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOneTokenCCPResponse(const GetOneTokenCCPResponse& from);
  GetOneTokenCCPResponse(GetOneTokenCCPResponse&& from) noexcept
    : GetOneTokenCCPResponse() {
    *this = ::std::move(from);
  }

  inline GetOneTokenCCPResponse& operator=(const GetOneTokenCCPResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOneTokenCCPResponse& operator=(GetOneTokenCCPResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOneTokenCCPResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOneTokenCCPResponse* internal_default_instance() {
    return reinterpret_cast<const GetOneTokenCCPResponse*>(
               &_GetOneTokenCCPResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetOneTokenCCPResponse& a, GetOneTokenCCPResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOneTokenCCPResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOneTokenCCPResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetOneTokenCCPResponse* New() const final {
    return new GetOneTokenCCPResponse();
  }

  GetOneTokenCCPResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOneTokenCCPResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOneTokenCCPResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOneTokenCCPResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOneTokenCCPResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse";
  }
  protected:
  explicit GetOneTokenCCPResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 2,
    kEmailFieldNumber = 3,
    kUserIdDexFieldNumber = 4,
    kFirstNameFieldNumber = 5,
    kUserIdFieldNumber = 1,
    kEmailVerifiedFieldNumber = 6,
  };
  // string token = 2 [json_name = "token"];
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string email = 3 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_MUST_USE_RESULT std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string user_id_dex = 4 [json_name = "userIdDex"];
  void clear_user_id_dex();
  const std::string& user_id_dex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id_dex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id_dex();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_id_dex();
  void set_allocated_user_id_dex(std::string* user_id_dex);
  private:
  const std::string& _internal_user_id_dex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id_dex(const std::string& value);
  std::string* _internal_mutable_user_id_dex();
  public:

  // string first_name = 5 [json_name = "firstName"];
  void clear_first_name();
  const std::string& first_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_first_name();
  void set_allocated_first_name(std::string* first_name);
  private:
  const std::string& _internal_first_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_name(const std::string& value);
  std::string* _internal_mutable_first_name();
  public:

  // uint32 user_id = 1 [json_name = "userId"];
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool email_verified = 6 [json_name = "emailVerified"];
  void clear_email_verified();
  bool email_verified() const;
  void set_email_verified(bool value);
  private:
  bool _internal_email_verified() const;
  void _internal_set_email_verified(bool value);
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_dex_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  bool email_verified_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto;
};
// -------------------------------------------------------------------

class CreateTokenCCPRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.tokens.v1.CreateTokenCCPRequest) */ {
 public:
  inline CreateTokenCCPRequest() : CreateTokenCCPRequest(nullptr) {}
  ~CreateTokenCCPRequest() override;
  explicit constexpr CreateTokenCCPRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTokenCCPRequest(const CreateTokenCCPRequest& from);
  CreateTokenCCPRequest(CreateTokenCCPRequest&& from) noexcept
    : CreateTokenCCPRequest() {
    *this = ::std::move(from);
  }

  inline CreateTokenCCPRequest& operator=(const CreateTokenCCPRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTokenCCPRequest& operator=(CreateTokenCCPRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTokenCCPRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTokenCCPRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTokenCCPRequest*>(
               &_CreateTokenCCPRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateTokenCCPRequest& a, CreateTokenCCPRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTokenCCPRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTokenCCPRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTokenCCPRequest* New() const final {
    return new CreateTokenCCPRequest();
  }

  CreateTokenCCPRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTokenCCPRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTokenCCPRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateTokenCCPRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTokenCCPRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.tokens.v1.CreateTokenCCPRequest";
  }
  protected:
  explicit CreateTokenCCPRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenDexFieldNumber = 1,
  };
  // string token_dex = 1 [json_name = "tokenDex"];
  void clear_token_dex();
  const std::string& token_dex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_dex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_dex();
  PROTOBUF_MUST_USE_RESULT std::string* release_token_dex();
  void set_allocated_token_dex(std::string* token_dex);
  private:
  const std::string& _internal_token_dex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_dex(const std::string& value);
  std::string* _internal_mutable_token_dex();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.tokens.v1.CreateTokenCCPRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_dex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto;
};
// -------------------------------------------------------------------

class CreateTokenCCPResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse) */ {
 public:
  inline CreateTokenCCPResponse() : CreateTokenCCPResponse(nullptr) {}
  ~CreateTokenCCPResponse() override;
  explicit constexpr CreateTokenCCPResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTokenCCPResponse(const CreateTokenCCPResponse& from);
  CreateTokenCCPResponse(CreateTokenCCPResponse&& from) noexcept
    : CreateTokenCCPResponse() {
    *this = ::std::move(from);
  }

  inline CreateTokenCCPResponse& operator=(const CreateTokenCCPResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTokenCCPResponse& operator=(CreateTokenCCPResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTokenCCPResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTokenCCPResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTokenCCPResponse*>(
               &_CreateTokenCCPResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateTokenCCPResponse& a, CreateTokenCCPResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTokenCCPResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTokenCCPResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTokenCCPResponse* New() const final {
    return new CreateTokenCCPResponse();
  }

  CreateTokenCCPResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTokenCCPResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTokenCCPResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateTokenCCPResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTokenCCPResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse";
  }
  protected:
  explicit CreateTokenCCPResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenCcpFieldNumber = 1,
    kMsgFieldNumber = 2,
    kUserIdFieldNumber = 6,
    kTimeExpirationMfaFieldNumber = 5,
  };
  // string token_ccp = 1 [json_name = "tokenCcp"];
  void clear_token_ccp();
  const std::string& token_ccp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_ccp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_ccp();
  PROTOBUF_MUST_USE_RESULT std::string* release_token_ccp();
  void set_allocated_token_ccp(std::string* token_ccp);
  private:
  const std::string& _internal_token_ccp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_ccp(const std::string& value);
  std::string* _internal_mutable_token_ccp();
  public:

  // string msg = 2 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string user_id = 6 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // int64 time_expiration_mfa = 5 [json_name = "timeExpirationMfa"];
  void clear_time_expiration_mfa();
  ::PROTOBUF_NAMESPACE_ID::int64 time_expiration_mfa() const;
  void set_time_expiration_mfa(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time_expiration_mfa() const;
  void _internal_set_time_expiration_mfa(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_ccp_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_expiration_mfa_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto;
};
// -------------------------------------------------------------------

class Log final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.tokens.v1.Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  ~Log() override;
  explicit constexpr Log(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Log(const Log& from);
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Log& default_instance() {
    return *internal_default_instance();
  }
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Log* New() const final {
    return new Log();
  }

  Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Log& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Log& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.tokens.v1.Log";
  }
  protected:
  explicit Log(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kSystemFieldNumber = 2,
    kClientWebFieldNumber = 3,
    kIpFieldNumber = 4,
    kDateFieldNumber = 5,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string system = 2 [json_name = "system"];
  void clear_system();
  const std::string& system() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_system(ArgT0&& arg0, ArgT... args);
  std::string* mutable_system();
  PROTOBUF_MUST_USE_RESULT std::string* release_system();
  void set_allocated_system(std::string* system);
  private:
  const std::string& _internal_system() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system(const std::string& value);
  std::string* _internal_mutable_system();
  public:

  // string client_web = 3 [json_name = "clientWeb"];
  void clear_client_web();
  const std::string& client_web() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_web(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_web();
  PROTOBUF_MUST_USE_RESULT std::string* release_client_web();
  void set_allocated_client_web(std::string* client_web);
  private:
  const std::string& _internal_client_web() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_web(const std::string& value);
  std::string* _internal_mutable_client_web();
  public:

  // string ip = 4 [json_name = "ip"];
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_MUST_USE_RESULT std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string date = 5 [json_name = "date"];
  void clear_date();
  const std::string& date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date();
  PROTOBUF_MUST_USE_RESULT std::string* release_date();
  void set_allocated_date(std::string* date);
  private:
  const std::string& _internal_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date(const std::string& value);
  std::string* _internal_mutable_date();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.tokens.v1.Log)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr system_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_web_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto;
};
// -------------------------------------------------------------------

class SaveLogsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.tokens.v1.SaveLogsRequest) */ {
 public:
  inline SaveLogsRequest() : SaveLogsRequest(nullptr) {}
  ~SaveLogsRequest() override;
  explicit constexpr SaveLogsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveLogsRequest(const SaveLogsRequest& from);
  SaveLogsRequest(SaveLogsRequest&& from) noexcept
    : SaveLogsRequest() {
    *this = ::std::move(from);
  }

  inline SaveLogsRequest& operator=(const SaveLogsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveLogsRequest& operator=(SaveLogsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveLogsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveLogsRequest* internal_default_instance() {
    return reinterpret_cast<const SaveLogsRequest*>(
               &_SaveLogsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SaveLogsRequest& a, SaveLogsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveLogsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveLogsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SaveLogsRequest* New() const final {
    return new SaveLogsRequest();
  }

  SaveLogsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SaveLogsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveLogsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SaveLogsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveLogsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.tokens.v1.SaveLogsRequest";
  }
  protected:
  explicit SaveLogsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogFieldNumber = 1,
  };
  // .accounts.v1alpha1.tokens.v1.Log log = 1 [json_name = "log"];
  bool has_log() const;
  private:
  bool _internal_has_log() const;
  public:
  void clear_log();
  const ::accounts::v1alpha1::tokens::v1::Log& log() const;
  PROTOBUF_MUST_USE_RESULT ::accounts::v1alpha1::tokens::v1::Log* release_log();
  ::accounts::v1alpha1::tokens::v1::Log* mutable_log();
  void set_allocated_log(::accounts::v1alpha1::tokens::v1::Log* log);
  private:
  const ::accounts::v1alpha1::tokens::v1::Log& _internal_log() const;
  ::accounts::v1alpha1::tokens::v1::Log* _internal_mutable_log();
  public:
  void unsafe_arena_set_allocated_log(
      ::accounts::v1alpha1::tokens::v1::Log* log);
  ::accounts::v1alpha1::tokens::v1::Log* unsafe_arena_release_log();

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.tokens.v1.SaveLogsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::accounts::v1alpha1::tokens::v1::Log* log_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto;
};
// -------------------------------------------------------------------

class SaveLogsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.tokens.v1.SaveLogsResponse) */ {
 public:
  inline SaveLogsResponse() : SaveLogsResponse(nullptr) {}
  ~SaveLogsResponse() override;
  explicit constexpr SaveLogsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveLogsResponse(const SaveLogsResponse& from);
  SaveLogsResponse(SaveLogsResponse&& from) noexcept
    : SaveLogsResponse() {
    *this = ::std::move(from);
  }

  inline SaveLogsResponse& operator=(const SaveLogsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveLogsResponse& operator=(SaveLogsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveLogsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveLogsResponse* internal_default_instance() {
    return reinterpret_cast<const SaveLogsResponse*>(
               &_SaveLogsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SaveLogsResponse& a, SaveLogsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveLogsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveLogsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SaveLogsResponse* New() const final {
    return new SaveLogsResponse();
  }

  SaveLogsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SaveLogsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveLogsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SaveLogsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveLogsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.tokens.v1.SaveLogsResponse";
  }
  protected:
  explicit SaveLogsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.tokens.v1.SaveLogsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto;
};
// -------------------------------------------------------------------

class LogsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.tokens.v1.LogsRequest) */ {
 public:
  inline LogsRequest() : LogsRequest(nullptr) {}
  ~LogsRequest() override;
  explicit constexpr LogsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogsRequest(const LogsRequest& from);
  LogsRequest(LogsRequest&& from) noexcept
    : LogsRequest() {
    *this = ::std::move(from);
  }

  inline LogsRequest& operator=(const LogsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogsRequest& operator=(LogsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogsRequest* internal_default_instance() {
    return reinterpret_cast<const LogsRequest*>(
               &_LogsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LogsRequest& a, LogsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogsRequest* New() const final {
    return new LogsRequest();
  }

  LogsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.tokens.v1.LogsRequest";
  }
  protected:
  explicit LogsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.tokens.v1.LogsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto;
};
// -------------------------------------------------------------------

class LogsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.tokens.v1.LogsResponse) */ {
 public:
  inline LogsResponse() : LogsResponse(nullptr) {}
  ~LogsResponse() override;
  explicit constexpr LogsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogsResponse(const LogsResponse& from);
  LogsResponse(LogsResponse&& from) noexcept
    : LogsResponse() {
    *this = ::std::move(from);
  }

  inline LogsResponse& operator=(const LogsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogsResponse& operator=(LogsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogsResponse* internal_default_instance() {
    return reinterpret_cast<const LogsResponse*>(
               &_LogsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LogsResponse& a, LogsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LogsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogsResponse* New() const final {
    return new LogsResponse();
  }

  LogsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.tokens.v1.LogsResponse";
  }
  protected:
  explicit LogsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 1,
  };
  // repeated .accounts.v1alpha1.tokens.v1.Log logs = 1 [json_name = "logs"];
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::accounts::v1alpha1::tokens::v1::Log* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::tokens::v1::Log >*
      mutable_logs();
  private:
  const ::accounts::v1alpha1::tokens::v1::Log& _internal_logs(int index) const;
  ::accounts::v1alpha1::tokens::v1::Log* _internal_add_logs();
  public:
  const ::accounts::v1alpha1::tokens::v1::Log& logs(int index) const;
  ::accounts::v1alpha1::tokens::v1::Log* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::tokens::v1::Log >&
      logs() const;

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.tokens.v1.LogsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::tokens::v1::Log > logs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto;
};
// -------------------------------------------------------------------

class EnableOrDisableMFARequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.tokens.v1.EnableOrDisableMFARequest) */ {
 public:
  inline EnableOrDisableMFARequest() : EnableOrDisableMFARequest(nullptr) {}
  ~EnableOrDisableMFARequest() override;
  explicit constexpr EnableOrDisableMFARequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnableOrDisableMFARequest(const EnableOrDisableMFARequest& from);
  EnableOrDisableMFARequest(EnableOrDisableMFARequest&& from) noexcept
    : EnableOrDisableMFARequest() {
    *this = ::std::move(from);
  }

  inline EnableOrDisableMFARequest& operator=(const EnableOrDisableMFARequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableOrDisableMFARequest& operator=(EnableOrDisableMFARequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableOrDisableMFARequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableOrDisableMFARequest* internal_default_instance() {
    return reinterpret_cast<const EnableOrDisableMFARequest*>(
               &_EnableOrDisableMFARequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EnableOrDisableMFARequest& a, EnableOrDisableMFARequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EnableOrDisableMFARequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableOrDisableMFARequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnableOrDisableMFARequest* New() const final {
    return new EnableOrDisableMFARequest();
  }

  EnableOrDisableMFARequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnableOrDisableMFARequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnableOrDisableMFARequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnableOrDisableMFARequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableOrDisableMFARequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.tokens.v1.EnableOrDisableMFARequest";
  }
  protected:
  explicit EnableOrDisableMFARequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.tokens.v1.EnableOrDisableMFARequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto;
};
// -------------------------------------------------------------------

class EnableOrDisableMFAResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.tokens.v1.EnableOrDisableMFAResponse) */ {
 public:
  inline EnableOrDisableMFAResponse() : EnableOrDisableMFAResponse(nullptr) {}
  ~EnableOrDisableMFAResponse() override;
  explicit constexpr EnableOrDisableMFAResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnableOrDisableMFAResponse(const EnableOrDisableMFAResponse& from);
  EnableOrDisableMFAResponse(EnableOrDisableMFAResponse&& from) noexcept
    : EnableOrDisableMFAResponse() {
    *this = ::std::move(from);
  }

  inline EnableOrDisableMFAResponse& operator=(const EnableOrDisableMFAResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableOrDisableMFAResponse& operator=(EnableOrDisableMFAResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableOrDisableMFAResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableOrDisableMFAResponse* internal_default_instance() {
    return reinterpret_cast<const EnableOrDisableMFAResponse*>(
               &_EnableOrDisableMFAResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EnableOrDisableMFAResponse& a, EnableOrDisableMFAResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EnableOrDisableMFAResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableOrDisableMFAResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnableOrDisableMFAResponse* New() const final {
    return new EnableOrDisableMFAResponse();
  }

  EnableOrDisableMFAResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnableOrDisableMFAResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnableOrDisableMFAResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnableOrDisableMFAResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableOrDisableMFAResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.tokens.v1.EnableOrDisableMFAResponse";
  }
  protected:
  explicit EnableOrDisableMFAResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.tokens.v1.EnableOrDisableMFAResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto;
};
// -------------------------------------------------------------------

class MFARequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.tokens.v1.MFARequest) */ {
 public:
  inline MFARequest() : MFARequest(nullptr) {}
  ~MFARequest() override;
  explicit constexpr MFARequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MFARequest(const MFARequest& from);
  MFARequest(MFARequest&& from) noexcept
    : MFARequest() {
    *this = ::std::move(from);
  }

  inline MFARequest& operator=(const MFARequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MFARequest& operator=(MFARequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MFARequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MFARequest* internal_default_instance() {
    return reinterpret_cast<const MFARequest*>(
               &_MFARequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MFARequest& a, MFARequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MFARequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MFARequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MFARequest* New() const final {
    return new MFARequest();
  }

  MFARequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MFARequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MFARequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MFARequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MFARequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.tokens.v1.MFARequest";
  }
  protected:
  explicit MFARequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumbersFieldNumber = 3,
    kUserIdFieldNumber = 1,
  };
  // repeated int32 numbers = 3 [json_name = "numbers"];
  int numbers_size() const;
  private:
  int _internal_numbers_size() const;
  public:
  void clear_numbers();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_numbers(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_numbers() const;
  void _internal_add_numbers(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_numbers();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 numbers(int index) const;
  void set_numbers(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_numbers(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      numbers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_numbers();

  // string user_id = 1 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.tokens.v1.MFARequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > numbers_;
  mutable std::atomic<int> _numbers_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto;
};
// -------------------------------------------------------------------

class MFAResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.tokens.v1.MFAResponse) */ {
 public:
  inline MFAResponse() : MFAResponse(nullptr) {}
  ~MFAResponse() override;
  explicit constexpr MFAResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MFAResponse(const MFAResponse& from);
  MFAResponse(MFAResponse&& from) noexcept
    : MFAResponse() {
    *this = ::std::move(from);
  }

  inline MFAResponse& operator=(const MFAResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MFAResponse& operator=(MFAResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MFAResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MFAResponse* internal_default_instance() {
    return reinterpret_cast<const MFAResponse*>(
               &_MFAResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MFAResponse& a, MFAResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MFAResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MFAResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MFAResponse* New() const final {
    return new MFAResponse();
  }

  MFAResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MFAResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MFAResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MFAResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MFAResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.tokens.v1.MFAResponse";
  }
  protected:
  explicit MFAResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenCcpFieldNumber = 1,
    kMsgFieldNumber = 2,
    kErrorFieldNumber = 3,
  };
  // string token_ccp = 1 [json_name = "tokenCcp"];
  void clear_token_ccp();
  const std::string& token_ccp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_ccp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_ccp();
  PROTOBUF_MUST_USE_RESULT std::string* release_token_ccp();
  void set_allocated_token_ccp(std::string* token_ccp);
  private:
  const std::string& _internal_token_ccp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_ccp(const std::string& value);
  std::string* _internal_mutable_token_ccp();
  public:

  // string msg = 2 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 3 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.tokens.v1.MFAResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_ccp_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetOneTokenCCPRequest

// string token = 1 [json_name = "token"];
inline void GetOneTokenCCPRequest::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& GetOneTokenCCPRequest::token() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.GetOneTokenCCPRequest.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOneTokenCCPRequest::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.GetOneTokenCCPRequest.token)
}
inline std::string* GetOneTokenCCPRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.GetOneTokenCCPRequest.token)
  return _s;
}
inline const std::string& GetOneTokenCCPRequest::_internal_token() const {
  return token_.Get();
}
inline void GetOneTokenCCPRequest::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOneTokenCCPRequest::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOneTokenCCPRequest::release_token() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.GetOneTokenCCPRequest.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOneTokenCCPRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.GetOneTokenCCPRequest.token)
}

// -------------------------------------------------------------------

// GetOneTokenCCPResponse

// uint32 user_id = 1 [json_name = "userId"];
inline void GetOneTokenCCPResponse::clear_user_id() {
  user_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOneTokenCCPResponse::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOneTokenCCPResponse::user_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.user_id)
  return _internal_user_id();
}
inline void GetOneTokenCCPResponse::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  user_id_ = value;
}
inline void GetOneTokenCCPResponse::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.user_id)
}

// string token = 2 [json_name = "token"];
inline void GetOneTokenCCPResponse::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& GetOneTokenCCPResponse::token() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOneTokenCCPResponse::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.token)
}
inline std::string* GetOneTokenCCPResponse::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.token)
  return _s;
}
inline const std::string& GetOneTokenCCPResponse::_internal_token() const {
  return token_.Get();
}
inline void GetOneTokenCCPResponse::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOneTokenCCPResponse::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOneTokenCCPResponse::release_token() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOneTokenCCPResponse::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.token)
}

// string email = 3 [json_name = "email"];
inline void GetOneTokenCCPResponse::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& GetOneTokenCCPResponse::email() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOneTokenCCPResponse::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.email)
}
inline std::string* GetOneTokenCCPResponse::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.email)
  return _s;
}
inline const std::string& GetOneTokenCCPResponse::_internal_email() const {
  return email_.Get();
}
inline void GetOneTokenCCPResponse::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOneTokenCCPResponse::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOneTokenCCPResponse::release_email() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOneTokenCCPResponse::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.email)
}

// string user_id_dex = 4 [json_name = "userIdDex"];
inline void GetOneTokenCCPResponse::clear_user_id_dex() {
  user_id_dex_.ClearToEmpty();
}
inline const std::string& GetOneTokenCCPResponse::user_id_dex() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.user_id_dex)
  return _internal_user_id_dex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOneTokenCCPResponse::set_user_id_dex(ArgT0&& arg0, ArgT... args) {
 
 user_id_dex_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.user_id_dex)
}
inline std::string* GetOneTokenCCPResponse::mutable_user_id_dex() {
  std::string* _s = _internal_mutable_user_id_dex();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.user_id_dex)
  return _s;
}
inline const std::string& GetOneTokenCCPResponse::_internal_user_id_dex() const {
  return user_id_dex_.Get();
}
inline void GetOneTokenCCPResponse::_internal_set_user_id_dex(const std::string& value) {
  
  user_id_dex_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOneTokenCCPResponse::_internal_mutable_user_id_dex() {
  
  return user_id_dex_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOneTokenCCPResponse::release_user_id_dex() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.user_id_dex)
  return user_id_dex_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOneTokenCCPResponse::set_allocated_user_id_dex(std::string* user_id_dex) {
  if (user_id_dex != nullptr) {
    
  } else {
    
  }
  user_id_dex_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id_dex,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.user_id_dex)
}

// string first_name = 5 [json_name = "firstName"];
inline void GetOneTokenCCPResponse::clear_first_name() {
  first_name_.ClearToEmpty();
}
inline const std::string& GetOneTokenCCPResponse::first_name() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.first_name)
  return _internal_first_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOneTokenCCPResponse::set_first_name(ArgT0&& arg0, ArgT... args) {
 
 first_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.first_name)
}
inline std::string* GetOneTokenCCPResponse::mutable_first_name() {
  std::string* _s = _internal_mutable_first_name();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.first_name)
  return _s;
}
inline const std::string& GetOneTokenCCPResponse::_internal_first_name() const {
  return first_name_.Get();
}
inline void GetOneTokenCCPResponse::_internal_set_first_name(const std::string& value) {
  
  first_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOneTokenCCPResponse::_internal_mutable_first_name() {
  
  return first_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOneTokenCCPResponse::release_first_name() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.first_name)
  return first_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOneTokenCCPResponse::set_allocated_first_name(std::string* first_name) {
  if (first_name != nullptr) {
    
  } else {
    
  }
  first_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), first_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.first_name)
}

// bool email_verified = 6 [json_name = "emailVerified"];
inline void GetOneTokenCCPResponse::clear_email_verified() {
  email_verified_ = false;
}
inline bool GetOneTokenCCPResponse::_internal_email_verified() const {
  return email_verified_;
}
inline bool GetOneTokenCCPResponse::email_verified() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.email_verified)
  return _internal_email_verified();
}
inline void GetOneTokenCCPResponse::_internal_set_email_verified(bool value) {
  
  email_verified_ = value;
}
inline void GetOneTokenCCPResponse::set_email_verified(bool value) {
  _internal_set_email_verified(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.GetOneTokenCCPResponse.email_verified)
}

// -------------------------------------------------------------------

// CreateTokenCCPRequest

// string token_dex = 1 [json_name = "tokenDex"];
inline void CreateTokenCCPRequest::clear_token_dex() {
  token_dex_.ClearToEmpty();
}
inline const std::string& CreateTokenCCPRequest::token_dex() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.CreateTokenCCPRequest.token_dex)
  return _internal_token_dex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTokenCCPRequest::set_token_dex(ArgT0&& arg0, ArgT... args) {
 
 token_dex_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.CreateTokenCCPRequest.token_dex)
}
inline std::string* CreateTokenCCPRequest::mutable_token_dex() {
  std::string* _s = _internal_mutable_token_dex();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.CreateTokenCCPRequest.token_dex)
  return _s;
}
inline const std::string& CreateTokenCCPRequest::_internal_token_dex() const {
  return token_dex_.Get();
}
inline void CreateTokenCCPRequest::_internal_set_token_dex(const std::string& value) {
  
  token_dex_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateTokenCCPRequest::_internal_mutable_token_dex() {
  
  return token_dex_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateTokenCCPRequest::release_token_dex() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.CreateTokenCCPRequest.token_dex)
  return token_dex_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateTokenCCPRequest::set_allocated_token_dex(std::string* token_dex) {
  if (token_dex != nullptr) {
    
  } else {
    
  }
  token_dex_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token_dex,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.CreateTokenCCPRequest.token_dex)
}

// -------------------------------------------------------------------

// CreateTokenCCPResponse

// string token_ccp = 1 [json_name = "tokenCcp"];
inline void CreateTokenCCPResponse::clear_token_ccp() {
  token_ccp_.ClearToEmpty();
}
inline const std::string& CreateTokenCCPResponse::token_ccp() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.token_ccp)
  return _internal_token_ccp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTokenCCPResponse::set_token_ccp(ArgT0&& arg0, ArgT... args) {
 
 token_ccp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.token_ccp)
}
inline std::string* CreateTokenCCPResponse::mutable_token_ccp() {
  std::string* _s = _internal_mutable_token_ccp();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.token_ccp)
  return _s;
}
inline const std::string& CreateTokenCCPResponse::_internal_token_ccp() const {
  return token_ccp_.Get();
}
inline void CreateTokenCCPResponse::_internal_set_token_ccp(const std::string& value) {
  
  token_ccp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateTokenCCPResponse::_internal_mutable_token_ccp() {
  
  return token_ccp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateTokenCCPResponse::release_token_ccp() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.token_ccp)
  return token_ccp_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateTokenCCPResponse::set_allocated_token_ccp(std::string* token_ccp) {
  if (token_ccp != nullptr) {
    
  } else {
    
  }
  token_ccp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token_ccp,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.token_ccp)
}

// string msg = 2 [json_name = "msg"];
inline void CreateTokenCCPResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& CreateTokenCCPResponse::msg() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTokenCCPResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.msg)
}
inline std::string* CreateTokenCCPResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.msg)
  return _s;
}
inline const std::string& CreateTokenCCPResponse::_internal_msg() const {
  return msg_.Get();
}
inline void CreateTokenCCPResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateTokenCCPResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateTokenCCPResponse::release_msg() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateTokenCCPResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.msg)
}

// int64 time_expiration_mfa = 5 [json_name = "timeExpirationMfa"];
inline void CreateTokenCCPResponse::clear_time_expiration_mfa() {
  time_expiration_mfa_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateTokenCCPResponse::_internal_time_expiration_mfa() const {
  return time_expiration_mfa_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateTokenCCPResponse::time_expiration_mfa() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.time_expiration_mfa)
  return _internal_time_expiration_mfa();
}
inline void CreateTokenCCPResponse::_internal_set_time_expiration_mfa(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  time_expiration_mfa_ = value;
}
inline void CreateTokenCCPResponse::set_time_expiration_mfa(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time_expiration_mfa(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.time_expiration_mfa)
}

// string user_id = 6 [json_name = "userId"];
inline void CreateTokenCCPResponse::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& CreateTokenCCPResponse::user_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTokenCCPResponse::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.user_id)
}
inline std::string* CreateTokenCCPResponse::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.user_id)
  return _s;
}
inline const std::string& CreateTokenCCPResponse::_internal_user_id() const {
  return user_id_.Get();
}
inline void CreateTokenCCPResponse::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateTokenCCPResponse::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateTokenCCPResponse::release_user_id() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateTokenCCPResponse::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.CreateTokenCCPResponse.user_id)
}

// -------------------------------------------------------------------

// Log

// string user_id = 1 [json_name = "userId"];
inline void Log::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& Log::user_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.Log.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.Log.user_id)
}
inline std::string* Log::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.Log.user_id)
  return _s;
}
inline const std::string& Log::_internal_user_id() const {
  return user_id_.Get();
}
inline void Log::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Log::release_user_id() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.Log.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Log::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.Log.user_id)
}

// string system = 2 [json_name = "system"];
inline void Log::clear_system() {
  system_.ClearToEmpty();
}
inline const std::string& Log::system() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.Log.system)
  return _internal_system();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_system(ArgT0&& arg0, ArgT... args) {
 
 system_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.Log.system)
}
inline std::string* Log::mutable_system() {
  std::string* _s = _internal_mutable_system();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.Log.system)
  return _s;
}
inline const std::string& Log::_internal_system() const {
  return system_.Get();
}
inline void Log::_internal_set_system(const std::string& value) {
  
  system_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_system() {
  
  return system_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Log::release_system() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.Log.system)
  return system_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Log::set_allocated_system(std::string* system) {
  if (system != nullptr) {
    
  } else {
    
  }
  system_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), system,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.Log.system)
}

// string client_web = 3 [json_name = "clientWeb"];
inline void Log::clear_client_web() {
  client_web_.ClearToEmpty();
}
inline const std::string& Log::client_web() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.Log.client_web)
  return _internal_client_web();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_client_web(ArgT0&& arg0, ArgT... args) {
 
 client_web_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.Log.client_web)
}
inline std::string* Log::mutable_client_web() {
  std::string* _s = _internal_mutable_client_web();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.Log.client_web)
  return _s;
}
inline const std::string& Log::_internal_client_web() const {
  return client_web_.Get();
}
inline void Log::_internal_set_client_web(const std::string& value) {
  
  client_web_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_client_web() {
  
  return client_web_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Log::release_client_web() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.Log.client_web)
  return client_web_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Log::set_allocated_client_web(std::string* client_web) {
  if (client_web != nullptr) {
    
  } else {
    
  }
  client_web_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_web,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.Log.client_web)
}

// string ip = 4 [json_name = "ip"];
inline void Log::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& Log::ip() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.Log.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.Log.ip)
}
inline std::string* Log::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.Log.ip)
  return _s;
}
inline const std::string& Log::_internal_ip() const {
  return ip_.Get();
}
inline void Log::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Log::release_ip() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.Log.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Log::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.Log.ip)
}

// string date = 5 [json_name = "date"];
inline void Log::clear_date() {
  date_.ClearToEmpty();
}
inline const std::string& Log::date() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.Log.date)
  return _internal_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_date(ArgT0&& arg0, ArgT... args) {
 
 date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.Log.date)
}
inline std::string* Log::mutable_date() {
  std::string* _s = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.Log.date)
  return _s;
}
inline const std::string& Log::_internal_date() const {
  return date_.Get();
}
inline void Log::_internal_set_date(const std::string& value) {
  
  date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_date() {
  
  return date_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Log::release_date() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.Log.date)
  return date_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Log::set_allocated_date(std::string* date) {
  if (date != nullptr) {
    
  } else {
    
  }
  date_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), date,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.Log.date)
}

// -------------------------------------------------------------------

// SaveLogsRequest

// .accounts.v1alpha1.tokens.v1.Log log = 1 [json_name = "log"];
inline bool SaveLogsRequest::_internal_has_log() const {
  return this != internal_default_instance() && log_ != nullptr;
}
inline bool SaveLogsRequest::has_log() const {
  return _internal_has_log();
}
inline void SaveLogsRequest::clear_log() {
  if (GetArenaForAllocation() == nullptr && log_ != nullptr) {
    delete log_;
  }
  log_ = nullptr;
}
inline const ::accounts::v1alpha1::tokens::v1::Log& SaveLogsRequest::_internal_log() const {
  const ::accounts::v1alpha1::tokens::v1::Log* p = log_;
  return p != nullptr ? *p : reinterpret_cast<const ::accounts::v1alpha1::tokens::v1::Log&>(
      ::accounts::v1alpha1::tokens::v1::_Log_default_instance_);
}
inline const ::accounts::v1alpha1::tokens::v1::Log& SaveLogsRequest::log() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.SaveLogsRequest.log)
  return _internal_log();
}
inline void SaveLogsRequest::unsafe_arena_set_allocated_log(
    ::accounts::v1alpha1::tokens::v1::Log* log) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_);
  }
  log_ = log;
  if (log) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:accounts.v1alpha1.tokens.v1.SaveLogsRequest.log)
}
inline ::accounts::v1alpha1::tokens::v1::Log* SaveLogsRequest::release_log() {
  
  ::accounts::v1alpha1::tokens::v1::Log* temp = log_;
  log_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::accounts::v1alpha1::tokens::v1::Log* SaveLogsRequest::unsafe_arena_release_log() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.SaveLogsRequest.log)
  
  ::accounts::v1alpha1::tokens::v1::Log* temp = log_;
  log_ = nullptr;
  return temp;
}
inline ::accounts::v1alpha1::tokens::v1::Log* SaveLogsRequest::_internal_mutable_log() {
  
  if (log_ == nullptr) {
    auto* p = CreateMaybeMessage<::accounts::v1alpha1::tokens::v1::Log>(GetArenaForAllocation());
    log_ = p;
  }
  return log_;
}
inline ::accounts::v1alpha1::tokens::v1::Log* SaveLogsRequest::mutable_log() {
  ::accounts::v1alpha1::tokens::v1::Log* _msg = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.SaveLogsRequest.log)
  return _msg;
}
inline void SaveLogsRequest::set_allocated_log(::accounts::v1alpha1::tokens::v1::Log* log) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete log_;
  }
  if (log) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::accounts::v1alpha1::tokens::v1::Log>::GetOwningArena(log);
    if (message_arena != submessage_arena) {
      log = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log, submessage_arena);
    }
    
  } else {
    
  }
  log_ = log;
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.SaveLogsRequest.log)
}

// -------------------------------------------------------------------

// SaveLogsResponse

// string msg = 1 [json_name = "msg"];
inline void SaveLogsResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& SaveLogsResponse::msg() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.SaveLogsResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveLogsResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.SaveLogsResponse.msg)
}
inline std::string* SaveLogsResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.SaveLogsResponse.msg)
  return _s;
}
inline const std::string& SaveLogsResponse::_internal_msg() const {
  return msg_.Get();
}
inline void SaveLogsResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SaveLogsResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SaveLogsResponse::release_msg() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.SaveLogsResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SaveLogsResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.SaveLogsResponse.msg)
}

// -------------------------------------------------------------------

// LogsRequest

// string user_id = 1 [json_name = "userId"];
inline void LogsRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& LogsRequest::user_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.LogsRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogsRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.LogsRequest.user_id)
}
inline std::string* LogsRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.LogsRequest.user_id)
  return _s;
}
inline const std::string& LogsRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void LogsRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LogsRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LogsRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.LogsRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LogsRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.LogsRequest.user_id)
}

// -------------------------------------------------------------------

// LogsResponse

// repeated .accounts.v1alpha1.tokens.v1.Log logs = 1 [json_name = "logs"];
inline int LogsResponse::_internal_logs_size() const {
  return logs_.size();
}
inline int LogsResponse::logs_size() const {
  return _internal_logs_size();
}
inline void LogsResponse::clear_logs() {
  logs_.Clear();
}
inline ::accounts::v1alpha1::tokens::v1::Log* LogsResponse::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.LogsResponse.logs)
  return logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::tokens::v1::Log >*
LogsResponse::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:accounts.v1alpha1.tokens.v1.LogsResponse.logs)
  return &logs_;
}
inline const ::accounts::v1alpha1::tokens::v1::Log& LogsResponse::_internal_logs(int index) const {
  return logs_.Get(index);
}
inline const ::accounts::v1alpha1::tokens::v1::Log& LogsResponse::logs(int index) const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.LogsResponse.logs)
  return _internal_logs(index);
}
inline ::accounts::v1alpha1::tokens::v1::Log* LogsResponse::_internal_add_logs() {
  return logs_.Add();
}
inline ::accounts::v1alpha1::tokens::v1::Log* LogsResponse::add_logs() {
  ::accounts::v1alpha1::tokens::v1::Log* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:accounts.v1alpha1.tokens.v1.LogsResponse.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::tokens::v1::Log >&
LogsResponse::logs() const {
  // @@protoc_insertion_point(field_list:accounts.v1alpha1.tokens.v1.LogsResponse.logs)
  return logs_;
}

// -------------------------------------------------------------------

// EnableOrDisableMFARequest

// string user_id = 1 [json_name = "userId"];
inline void EnableOrDisableMFARequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& EnableOrDisableMFARequest::user_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.EnableOrDisableMFARequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnableOrDisableMFARequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.EnableOrDisableMFARequest.user_id)
}
inline std::string* EnableOrDisableMFARequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.EnableOrDisableMFARequest.user_id)
  return _s;
}
inline const std::string& EnableOrDisableMFARequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void EnableOrDisableMFARequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnableOrDisableMFARequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnableOrDisableMFARequest::release_user_id() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.EnableOrDisableMFARequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnableOrDisableMFARequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.EnableOrDisableMFARequest.user_id)
}

// -------------------------------------------------------------------

// EnableOrDisableMFAResponse

// string msg = 1 [json_name = "msg"];
inline void EnableOrDisableMFAResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& EnableOrDisableMFAResponse::msg() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.EnableOrDisableMFAResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnableOrDisableMFAResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.EnableOrDisableMFAResponse.msg)
}
inline std::string* EnableOrDisableMFAResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.EnableOrDisableMFAResponse.msg)
  return _s;
}
inline const std::string& EnableOrDisableMFAResponse::_internal_msg() const {
  return msg_.Get();
}
inline void EnableOrDisableMFAResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnableOrDisableMFAResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnableOrDisableMFAResponse::release_msg() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.EnableOrDisableMFAResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnableOrDisableMFAResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.EnableOrDisableMFAResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void EnableOrDisableMFAResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& EnableOrDisableMFAResponse::error() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.EnableOrDisableMFAResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnableOrDisableMFAResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.EnableOrDisableMFAResponse.error)
}
inline std::string* EnableOrDisableMFAResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.EnableOrDisableMFAResponse.error)
  return _s;
}
inline const std::string& EnableOrDisableMFAResponse::_internal_error() const {
  return error_.Get();
}
inline void EnableOrDisableMFAResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnableOrDisableMFAResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnableOrDisableMFAResponse::release_error() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.EnableOrDisableMFAResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnableOrDisableMFAResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.EnableOrDisableMFAResponse.error)
}

// -------------------------------------------------------------------

// MFARequest

// string user_id = 1 [json_name = "userId"];
inline void MFARequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& MFARequest::user_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.MFARequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MFARequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.MFARequest.user_id)
}
inline std::string* MFARequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.MFARequest.user_id)
  return _s;
}
inline const std::string& MFARequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void MFARequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MFARequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MFARequest::release_user_id() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.MFARequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MFARequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.MFARequest.user_id)
}

// repeated int32 numbers = 3 [json_name = "numbers"];
inline int MFARequest::_internal_numbers_size() const {
  return numbers_.size();
}
inline int MFARequest::numbers_size() const {
  return _internal_numbers_size();
}
inline void MFARequest::clear_numbers() {
  numbers_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MFARequest::_internal_numbers(int index) const {
  return numbers_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MFARequest::numbers(int index) const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.MFARequest.numbers)
  return _internal_numbers(index);
}
inline void MFARequest::set_numbers(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  numbers_.Set(index, value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.MFARequest.numbers)
}
inline void MFARequest::_internal_add_numbers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  numbers_.Add(value);
}
inline void MFARequest::add_numbers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_numbers(value);
  // @@protoc_insertion_point(field_add:accounts.v1alpha1.tokens.v1.MFARequest.numbers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
MFARequest::_internal_numbers() const {
  return numbers_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
MFARequest::numbers() const {
  // @@protoc_insertion_point(field_list:accounts.v1alpha1.tokens.v1.MFARequest.numbers)
  return _internal_numbers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
MFARequest::_internal_mutable_numbers() {
  return &numbers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
MFARequest::mutable_numbers() {
  // @@protoc_insertion_point(field_mutable_list:accounts.v1alpha1.tokens.v1.MFARequest.numbers)
  return _internal_mutable_numbers();
}

// -------------------------------------------------------------------

// MFAResponse

// string token_ccp = 1 [json_name = "tokenCcp"];
inline void MFAResponse::clear_token_ccp() {
  token_ccp_.ClearToEmpty();
}
inline const std::string& MFAResponse::token_ccp() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.MFAResponse.token_ccp)
  return _internal_token_ccp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MFAResponse::set_token_ccp(ArgT0&& arg0, ArgT... args) {
 
 token_ccp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.MFAResponse.token_ccp)
}
inline std::string* MFAResponse::mutable_token_ccp() {
  std::string* _s = _internal_mutable_token_ccp();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.MFAResponse.token_ccp)
  return _s;
}
inline const std::string& MFAResponse::_internal_token_ccp() const {
  return token_ccp_.Get();
}
inline void MFAResponse::_internal_set_token_ccp(const std::string& value) {
  
  token_ccp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MFAResponse::_internal_mutable_token_ccp() {
  
  return token_ccp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MFAResponse::release_token_ccp() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.MFAResponse.token_ccp)
  return token_ccp_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MFAResponse::set_allocated_token_ccp(std::string* token_ccp) {
  if (token_ccp != nullptr) {
    
  } else {
    
  }
  token_ccp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token_ccp,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.MFAResponse.token_ccp)
}

// string msg = 2 [json_name = "msg"];
inline void MFAResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& MFAResponse::msg() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.MFAResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MFAResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.MFAResponse.msg)
}
inline std::string* MFAResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.MFAResponse.msg)
  return _s;
}
inline const std::string& MFAResponse::_internal_msg() const {
  return msg_.Get();
}
inline void MFAResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MFAResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MFAResponse::release_msg() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.MFAResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MFAResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.MFAResponse.msg)
}

// string error = 3 [json_name = "error"];
inline void MFAResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& MFAResponse::error() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.tokens.v1.MFAResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MFAResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.tokens.v1.MFAResponse.error)
}
inline std::string* MFAResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.tokens.v1.MFAResponse.error)
  return _s;
}
inline const std::string& MFAResponse::_internal_error() const {
  return error_.Get();
}
inline void MFAResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MFAResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MFAResponse::release_error() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.tokens.v1.MFAResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MFAResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.tokens.v1.MFAResponse.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace tokens
}  // namespace v1alpha1
}  // namespace accounts

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_accounts_2fv1alpha1_2ftokens_2ftokens_2eproto
