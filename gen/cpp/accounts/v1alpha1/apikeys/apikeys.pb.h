// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: accounts/v1alpha1/apikeys/apikeys.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "accounts/v1alpha1/accounts.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto;
namespace accounts {
namespace v1alpha1 {
namespace apikeys {
namespace v1 {
class ApiKeyList;
struct ApiKeyListDefaultTypeInternal;
extern ApiKeyListDefaultTypeInternal _ApiKeyList_default_instance_;
class CreateApiKeyRequest;
struct CreateApiKeyRequestDefaultTypeInternal;
extern CreateApiKeyRequestDefaultTypeInternal _CreateApiKeyRequest_default_instance_;
class CreateApiKeyResponse;
struct CreateApiKeyResponseDefaultTypeInternal;
extern CreateApiKeyResponseDefaultTypeInternal _CreateApiKeyResponse_default_instance_;
class DeleteApiKeyRequest;
struct DeleteApiKeyRequestDefaultTypeInternal;
extern DeleteApiKeyRequestDefaultTypeInternal _DeleteApiKeyRequest_default_instance_;
class DeleteApiKeyResponse;
struct DeleteApiKeyResponseDefaultTypeInternal;
extern DeleteApiKeyResponseDefaultTypeInternal _DeleteApiKeyResponse_default_instance_;
class GetOneApiKeyRequest;
struct GetOneApiKeyRequestDefaultTypeInternal;
extern GetOneApiKeyRequestDefaultTypeInternal _GetOneApiKeyRequest_default_instance_;
class GetOneApiKeyResponse;
struct GetOneApiKeyResponseDefaultTypeInternal;
extern GetOneApiKeyResponseDefaultTypeInternal _GetOneApiKeyResponse_default_instance_;
class ListApiKeyRequest;
struct ListApiKeyRequestDefaultTypeInternal;
extern ListApiKeyRequestDefaultTypeInternal _ListApiKeyRequest_default_instance_;
class ListApiKeyResponse;
struct ListApiKeyResponseDefaultTypeInternal;
extern ListApiKeyResponseDefaultTypeInternal _ListApiKeyResponse_default_instance_;
class UpdateApiKeyRequest;
struct UpdateApiKeyRequestDefaultTypeInternal;
extern UpdateApiKeyRequestDefaultTypeInternal _UpdateApiKeyRequest_default_instance_;
class UpdateApiKeyResponse;
struct UpdateApiKeyResponseDefaultTypeInternal;
extern UpdateApiKeyResponseDefaultTypeInternal _UpdateApiKeyResponse_default_instance_;
}  // namespace v1
}  // namespace apikeys
}  // namespace v1alpha1
}  // namespace accounts
PROTOBUF_NAMESPACE_OPEN
template<> ::accounts::v1alpha1::apikeys::v1::ApiKeyList* Arena::CreateMaybeMessage<::accounts::v1alpha1::apikeys::v1::ApiKeyList>(Arena*);
template<> ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest>(Arena*);
template<> ::accounts::v1alpha1::apikeys::v1::CreateApiKeyResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::apikeys::v1::CreateApiKeyResponse>(Arena*);
template<> ::accounts::v1alpha1::apikeys::v1::DeleteApiKeyRequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::apikeys::v1::DeleteApiKeyRequest>(Arena*);
template<> ::accounts::v1alpha1::apikeys::v1::DeleteApiKeyResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::apikeys::v1::DeleteApiKeyResponse>(Arena*);
template<> ::accounts::v1alpha1::apikeys::v1::GetOneApiKeyRequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::apikeys::v1::GetOneApiKeyRequest>(Arena*);
template<> ::accounts::v1alpha1::apikeys::v1::GetOneApiKeyResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::apikeys::v1::GetOneApiKeyResponse>(Arena*);
template<> ::accounts::v1alpha1::apikeys::v1::ListApiKeyRequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::apikeys::v1::ListApiKeyRequest>(Arena*);
template<> ::accounts::v1alpha1::apikeys::v1::ListApiKeyResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::apikeys::v1::ListApiKeyResponse>(Arena*);
template<> ::accounts::v1alpha1::apikeys::v1::UpdateApiKeyRequest* Arena::CreateMaybeMessage<::accounts::v1alpha1::apikeys::v1::UpdateApiKeyRequest>(Arena*);
template<> ::accounts::v1alpha1::apikeys::v1::UpdateApiKeyResponse* Arena::CreateMaybeMessage<::accounts::v1alpha1::apikeys::v1::UpdateApiKeyResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace accounts {
namespace v1alpha1 {
namespace apikeys {
namespace v1 {

// ===================================================================

class CreateApiKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest) */ {
 public:
  inline CreateApiKeyRequest() : CreateApiKeyRequest(nullptr) {}
  ~CreateApiKeyRequest() override;
  explicit constexpr CreateApiKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateApiKeyRequest(const CreateApiKeyRequest& from);
  CreateApiKeyRequest(CreateApiKeyRequest&& from) noexcept
    : CreateApiKeyRequest() {
    *this = ::std::move(from);
  }

  inline CreateApiKeyRequest& operator=(const CreateApiKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateApiKeyRequest& operator=(CreateApiKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateApiKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateApiKeyRequest* internal_default_instance() {
    return reinterpret_cast<const CreateApiKeyRequest*>(
               &_CreateApiKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateApiKeyRequest& a, CreateApiKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateApiKeyRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateApiKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateApiKeyRequest* New() const final {
    return new CreateApiKeyRequest();
  }

  CreateApiKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateApiKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateApiKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateApiKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateApiKeyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest";
  }
  protected:
  explicit CreateApiKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesIdsFieldNumber = 3,
    kPermissionsIdsFieldNumber = 4,
    kNameFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 5,
    kIsActiveFieldNumber = 6,
    kProjectIdFieldNumber = 7,
  };
  // repeated uint32 roles_ids = 3 [json_name = "rolesIds"];
  int roles_ids_size() const;
  private:
  int _internal_roles_ids_size() const;
  public:
  void clear_roles_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_roles_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_roles_ids() const;
  void _internal_add_roles_ids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_roles_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 roles_ids(int index) const;
  void set_roles_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_roles_ids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      roles_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_roles_ids();

  // repeated uint32 permissions_ids = 4 [json_name = "permissionsIds"];
  int permissions_ids_size() const;
  private:
  int _internal_permissions_ids_size() const;
  public:
  void clear_permissions_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_permissions_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_permissions_ids() const;
  void _internal_add_permissions_ids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_permissions_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 permissions_ids(int index) const;
  void set_permissions_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_permissions_ids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      permissions_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_permissions_ids();

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string user_id = 2 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // uint32 organization_id = 5 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool is_active = 6 [json_name = "isActive"];
  void clear_is_active();
  bool is_active() const;
  void set_is_active(bool value);
  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);
  public:

  // uint32 project_id = 7 [json_name = "projectId"];
  void clear_project_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id() const;
  void set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_project_id() const;
  void _internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > roles_ids_;
  mutable std::atomic<int> _roles_ids_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > permissions_ids_;
  mutable std::atomic<int> _permissions_ids_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  bool is_active_;
  ::PROTOBUF_NAMESPACE_ID::uint32 project_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto;
};
// -------------------------------------------------------------------

class CreateApiKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse) */ {
 public:
  inline CreateApiKeyResponse() : CreateApiKeyResponse(nullptr) {}
  ~CreateApiKeyResponse() override;
  explicit constexpr CreateApiKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateApiKeyResponse(const CreateApiKeyResponse& from);
  CreateApiKeyResponse(CreateApiKeyResponse&& from) noexcept
    : CreateApiKeyResponse() {
    *this = ::std::move(from);
  }

  inline CreateApiKeyResponse& operator=(const CreateApiKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateApiKeyResponse& operator=(CreateApiKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateApiKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateApiKeyResponse* internal_default_instance() {
    return reinterpret_cast<const CreateApiKeyResponse*>(
               &_CreateApiKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateApiKeyResponse& a, CreateApiKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateApiKeyResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateApiKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateApiKeyResponse* New() const final {
    return new CreateApiKeyResponse();
  }

  CreateApiKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateApiKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateApiKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateApiKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateApiKeyResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse";
  }
  protected:
  explicit CreateApiKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kApiKeyFieldNumber = 2,
    kErrorFieldNumber = 5,
    kAccessPointIdFieldNumber = 4,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string api_key = 2 [json_name = "apiKey"];
  void clear_api_key();
  const std::string& api_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_api_key();
  void set_allocated_api_key(std::string* api_key);
  private:
  const std::string& _internal_api_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_key(const std::string& value);
  std::string* _internal_mutable_api_key();
  public:

  // string error = 5 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // uint32 access_point_id = 4 [json_name = "accessPointId"];
  void clear_access_point_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 access_point_id() const;
  void set_access_point_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_access_point_id() const;
  void _internal_set_access_point_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  ::PROTOBUF_NAMESPACE_ID::uint32 access_point_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto;
};
// -------------------------------------------------------------------

class GetOneApiKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.apikeys.v1.GetOneApiKeyRequest) */ {
 public:
  inline GetOneApiKeyRequest() : GetOneApiKeyRequest(nullptr) {}
  ~GetOneApiKeyRequest() override;
  explicit constexpr GetOneApiKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOneApiKeyRequest(const GetOneApiKeyRequest& from);
  GetOneApiKeyRequest(GetOneApiKeyRequest&& from) noexcept
    : GetOneApiKeyRequest() {
    *this = ::std::move(from);
  }

  inline GetOneApiKeyRequest& operator=(const GetOneApiKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOneApiKeyRequest& operator=(GetOneApiKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOneApiKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOneApiKeyRequest* internal_default_instance() {
    return reinterpret_cast<const GetOneApiKeyRequest*>(
               &_GetOneApiKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetOneApiKeyRequest& a, GetOneApiKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOneApiKeyRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOneApiKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetOneApiKeyRequest* New() const final {
    return new GetOneApiKeyRequest();
  }

  GetOneApiKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOneApiKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOneApiKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOneApiKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOneApiKeyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.apikeys.v1.GetOneApiKeyRequest";
  }
  protected:
  explicit GetOneApiKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueKeyFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string value_key = 2 [json_name = "valueKey"];
  void clear_value_key();
  const std::string& value_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_value_key();
  void set_allocated_value_key(std::string* value_key);
  private:
  const std::string& _internal_value_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_key(const std::string& value);
  std::string* _internal_mutable_value_key();
  public:

  // uint32 id = 1 [json_name = "id"];
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.apikeys.v1.GetOneApiKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_key_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto;
};
// -------------------------------------------------------------------

class GetOneApiKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse) */ {
 public:
  inline GetOneApiKeyResponse() : GetOneApiKeyResponse(nullptr) {}
  ~GetOneApiKeyResponse() override;
  explicit constexpr GetOneApiKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOneApiKeyResponse(const GetOneApiKeyResponse& from);
  GetOneApiKeyResponse(GetOneApiKeyResponse&& from) noexcept
    : GetOneApiKeyResponse() {
    *this = ::std::move(from);
  }

  inline GetOneApiKeyResponse& operator=(const GetOneApiKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOneApiKeyResponse& operator=(GetOneApiKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOneApiKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOneApiKeyResponse* internal_default_instance() {
    return reinterpret_cast<const GetOneApiKeyResponse*>(
               &_GetOneApiKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetOneApiKeyResponse& a, GetOneApiKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOneApiKeyResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOneApiKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetOneApiKeyResponse* New() const final {
    return new GetOneApiKeyResponse();
  }

  GetOneApiKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOneApiKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOneApiKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOneApiKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOneApiKeyResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse";
  }
  protected:
  explicit GetOneApiKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 5,
    kPermissionsFieldNumber = 6,
    kApiKeyFieldNumber = 2,
    kNameFieldNumber = 3,
    kUserIdFieldNumber = 4,
    kProjectFieldNumber = 9,
    kOrganizationFieldNumber = 10,
    kIdFieldNumber = 1,
    kIsActiveFieldNumber = 8,
  };
  // repeated .accounts.v1alpha1.Role roles = 5 [json_name = "roles"];
  int roles_size() const;
  private:
  int _internal_roles_size() const;
  public:
  void clear_roles();
  ::accounts::v1alpha1::Role* mutable_roles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::Role >*
      mutable_roles();
  private:
  const ::accounts::v1alpha1::Role& _internal_roles(int index) const;
  ::accounts::v1alpha1::Role* _internal_add_roles();
  public:
  const ::accounts::v1alpha1::Role& roles(int index) const;
  ::accounts::v1alpha1::Role* add_roles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::Role >&
      roles() const;

  // repeated .accounts.v1alpha1.Permission permissions = 6 [json_name = "permissions"];
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::accounts::v1alpha1::Permission* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::Permission >*
      mutable_permissions();
  private:
  const ::accounts::v1alpha1::Permission& _internal_permissions(int index) const;
  ::accounts::v1alpha1::Permission* _internal_add_permissions();
  public:
  const ::accounts::v1alpha1::Permission& permissions(int index) const;
  ::accounts::v1alpha1::Permission* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::Permission >&
      permissions() const;

  // string api_key = 2 [json_name = "apiKey"];
  void clear_api_key();
  const std::string& api_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_api_key();
  void set_allocated_api_key(std::string* api_key);
  private:
  const std::string& _internal_api_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_key(const std::string& value);
  std::string* _internal_mutable_api_key();
  public:

  // string name = 3 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string user_id = 4 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .accounts.v1alpha1.Project project = 9 [json_name = "project"];
  bool has_project() const;
  private:
  bool _internal_has_project() const;
  public:
  void clear_project();
  const ::accounts::v1alpha1::Project& project() const;
  PROTOBUF_MUST_USE_RESULT ::accounts::v1alpha1::Project* release_project();
  ::accounts::v1alpha1::Project* mutable_project();
  void set_allocated_project(::accounts::v1alpha1::Project* project);
  private:
  const ::accounts::v1alpha1::Project& _internal_project() const;
  ::accounts::v1alpha1::Project* _internal_mutable_project();
  public:
  void unsafe_arena_set_allocated_project(
      ::accounts::v1alpha1::Project* project);
  ::accounts::v1alpha1::Project* unsafe_arena_release_project();

  // .accounts.v1alpha1.Organization organization = 10 [json_name = "organization"];
  bool has_organization() const;
  private:
  bool _internal_has_organization() const;
  public:
  void clear_organization();
  const ::accounts::v1alpha1::Organization& organization() const;
  PROTOBUF_MUST_USE_RESULT ::accounts::v1alpha1::Organization* release_organization();
  ::accounts::v1alpha1::Organization* mutable_organization();
  void set_allocated_organization(::accounts::v1alpha1::Organization* organization);
  private:
  const ::accounts::v1alpha1::Organization& _internal_organization() const;
  ::accounts::v1alpha1::Organization* _internal_mutable_organization();
  public:
  void unsafe_arena_set_allocated_organization(
      ::accounts::v1alpha1::Organization* organization);
  ::accounts::v1alpha1::Organization* unsafe_arena_release_organization();

  // uint32 id = 1 [json_name = "id"];
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool is_active = 8 [json_name = "isActive"];
  void clear_is_active();
  bool is_active() const;
  void set_is_active(bool value);
  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::Role > roles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::Permission > permissions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::accounts::v1alpha1::Project* project_;
  ::accounts::v1alpha1::Organization* organization_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  bool is_active_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto;
};
// -------------------------------------------------------------------

class ListApiKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.apikeys.v1.ListApiKeyRequest) */ {
 public:
  inline ListApiKeyRequest() : ListApiKeyRequest(nullptr) {}
  ~ListApiKeyRequest() override;
  explicit constexpr ListApiKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListApiKeyRequest(const ListApiKeyRequest& from);
  ListApiKeyRequest(ListApiKeyRequest&& from) noexcept
    : ListApiKeyRequest() {
    *this = ::std::move(from);
  }

  inline ListApiKeyRequest& operator=(const ListApiKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListApiKeyRequest& operator=(ListApiKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListApiKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListApiKeyRequest* internal_default_instance() {
    return reinterpret_cast<const ListApiKeyRequest*>(
               &_ListApiKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ListApiKeyRequest& a, ListApiKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListApiKeyRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListApiKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListApiKeyRequest* New() const final {
    return new ListApiKeyRequest();
  }

  ListApiKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListApiKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListApiKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListApiKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListApiKeyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.apikeys.v1.ListApiKeyRequest";
  }
  protected:
  explicit ListApiKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kOrganizationIdFieldNumber = 2,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // uint32 organization_id = 2 [json_name = "organizationId"];
  void clear_organization_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id() const;
  void set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_organization_id() const;
  void _internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.apikeys.v1.ListApiKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 organization_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto;
};
// -------------------------------------------------------------------

class ApiKeyList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.apikeys.v1.ApiKeyList) */ {
 public:
  inline ApiKeyList() : ApiKeyList(nullptr) {}
  ~ApiKeyList() override;
  explicit constexpr ApiKeyList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApiKeyList(const ApiKeyList& from);
  ApiKeyList(ApiKeyList&& from) noexcept
    : ApiKeyList() {
    *this = ::std::move(from);
  }

  inline ApiKeyList& operator=(const ApiKeyList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiKeyList& operator=(ApiKeyList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiKeyList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApiKeyList* internal_default_instance() {
    return reinterpret_cast<const ApiKeyList*>(
               &_ApiKeyList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ApiKeyList& a, ApiKeyList& b) {
    a.Swap(&b);
  }
  inline void Swap(ApiKeyList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiKeyList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApiKeyList* New() const final {
    return new ApiKeyList();
  }

  ApiKeyList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApiKeyList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApiKeyList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ApiKeyList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApiKeyList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.apikeys.v1.ApiKeyList";
  }
  protected:
  explicit ApiKeyList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiKeyFieldNumber = 2,
    kNameFieldNumber = 3,
    kUserIdFieldNumber = 4,
    kProjectFieldNumber = 7,
    kOrganizationFieldNumber = 8,
    kIdFieldNumber = 1,
    kIsActiveFieldNumber = 6,
  };
  // string api_key = 2 [json_name = "apiKey"];
  void clear_api_key();
  const std::string& api_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_api_key();
  void set_allocated_api_key(std::string* api_key);
  private:
  const std::string& _internal_api_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_key(const std::string& value);
  std::string* _internal_mutable_api_key();
  public:

  // string name = 3 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string user_id = 4 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .accounts.v1alpha1.Project project = 7 [json_name = "project"];
  bool has_project() const;
  private:
  bool _internal_has_project() const;
  public:
  void clear_project();
  const ::accounts::v1alpha1::Project& project() const;
  PROTOBUF_MUST_USE_RESULT ::accounts::v1alpha1::Project* release_project();
  ::accounts::v1alpha1::Project* mutable_project();
  void set_allocated_project(::accounts::v1alpha1::Project* project);
  private:
  const ::accounts::v1alpha1::Project& _internal_project() const;
  ::accounts::v1alpha1::Project* _internal_mutable_project();
  public:
  void unsafe_arena_set_allocated_project(
      ::accounts::v1alpha1::Project* project);
  ::accounts::v1alpha1::Project* unsafe_arena_release_project();

  // .accounts.v1alpha1.Organization organization = 8 [json_name = "organization"];
  bool has_organization() const;
  private:
  bool _internal_has_organization() const;
  public:
  void clear_organization();
  const ::accounts::v1alpha1::Organization& organization() const;
  PROTOBUF_MUST_USE_RESULT ::accounts::v1alpha1::Organization* release_organization();
  ::accounts::v1alpha1::Organization* mutable_organization();
  void set_allocated_organization(::accounts::v1alpha1::Organization* organization);
  private:
  const ::accounts::v1alpha1::Organization& _internal_organization() const;
  ::accounts::v1alpha1::Organization* _internal_mutable_organization();
  public:
  void unsafe_arena_set_allocated_organization(
      ::accounts::v1alpha1::Organization* organization);
  ::accounts::v1alpha1::Organization* unsafe_arena_release_organization();

  // uint32 id = 1 [json_name = "id"];
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool is_active = 6 [json_name = "isActive"];
  void clear_is_active();
  bool is_active() const;
  void set_is_active(bool value);
  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.apikeys.v1.ApiKeyList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::accounts::v1alpha1::Project* project_;
  ::accounts::v1alpha1::Organization* organization_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  bool is_active_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto;
};
// -------------------------------------------------------------------

class ListApiKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.apikeys.v1.ListApiKeyResponse) */ {
 public:
  inline ListApiKeyResponse() : ListApiKeyResponse(nullptr) {}
  ~ListApiKeyResponse() override;
  explicit constexpr ListApiKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListApiKeyResponse(const ListApiKeyResponse& from);
  ListApiKeyResponse(ListApiKeyResponse&& from) noexcept
    : ListApiKeyResponse() {
    *this = ::std::move(from);
  }

  inline ListApiKeyResponse& operator=(const ListApiKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListApiKeyResponse& operator=(ListApiKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListApiKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListApiKeyResponse* internal_default_instance() {
    return reinterpret_cast<const ListApiKeyResponse*>(
               &_ListApiKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListApiKeyResponse& a, ListApiKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListApiKeyResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListApiKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListApiKeyResponse* New() const final {
    return new ListApiKeyResponse();
  }

  ListApiKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListApiKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListApiKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListApiKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListApiKeyResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.apikeys.v1.ListApiKeyResponse";
  }
  protected:
  explicit ListApiKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiKeysFieldNumber = 1,
  };
  // repeated .accounts.v1alpha1.apikeys.v1.ApiKeyList api_keys = 1 [json_name = "apiKeys"];
  int api_keys_size() const;
  private:
  int _internal_api_keys_size() const;
  public:
  void clear_api_keys();
  ::accounts::v1alpha1::apikeys::v1::ApiKeyList* mutable_api_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::apikeys::v1::ApiKeyList >*
      mutable_api_keys();
  private:
  const ::accounts::v1alpha1::apikeys::v1::ApiKeyList& _internal_api_keys(int index) const;
  ::accounts::v1alpha1::apikeys::v1::ApiKeyList* _internal_add_api_keys();
  public:
  const ::accounts::v1alpha1::apikeys::v1::ApiKeyList& api_keys(int index) const;
  ::accounts::v1alpha1::apikeys::v1::ApiKeyList* add_api_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::apikeys::v1::ApiKeyList >&
      api_keys() const;

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.apikeys.v1.ListApiKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::apikeys::v1::ApiKeyList > api_keys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto;
};
// -------------------------------------------------------------------

class UpdateApiKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.apikeys.v1.UpdateApiKeyRequest) */ {
 public:
  inline UpdateApiKeyRequest() : UpdateApiKeyRequest(nullptr) {}
  ~UpdateApiKeyRequest() override;
  explicit constexpr UpdateApiKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateApiKeyRequest(const UpdateApiKeyRequest& from);
  UpdateApiKeyRequest(UpdateApiKeyRequest&& from) noexcept
    : UpdateApiKeyRequest() {
    *this = ::std::move(from);
  }

  inline UpdateApiKeyRequest& operator=(const UpdateApiKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateApiKeyRequest& operator=(UpdateApiKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateApiKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateApiKeyRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateApiKeyRequest*>(
               &_UpdateApiKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UpdateApiKeyRequest& a, UpdateApiKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateApiKeyRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateApiKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateApiKeyRequest* New() const final {
    return new UpdateApiKeyRequest();
  }

  UpdateApiKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateApiKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateApiKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateApiKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateApiKeyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.apikeys.v1.UpdateApiKeyRequest";
  }
  protected:
  explicit UpdateApiKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiKeyFieldNumber = 6,
    kIdFieldNumber = 1,
  };
  // .accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest api_key = 6 [json_name = "apiKey"];
  bool has_api_key() const;
  private:
  bool _internal_has_api_key() const;
  public:
  void clear_api_key();
  const ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest& api_key() const;
  PROTOBUF_MUST_USE_RESULT ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* release_api_key();
  ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* mutable_api_key();
  void set_allocated_api_key(::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* api_key);
  private:
  const ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest& _internal_api_key() const;
  ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* _internal_mutable_api_key();
  public:
  void unsafe_arena_set_allocated_api_key(
      ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* api_key);
  ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* unsafe_arena_release_api_key();

  // uint32 id = 1 [json_name = "id"];
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.apikeys.v1.UpdateApiKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* api_key_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto;
};
// -------------------------------------------------------------------

class UpdateApiKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse) */ {
 public:
  inline UpdateApiKeyResponse() : UpdateApiKeyResponse(nullptr) {}
  ~UpdateApiKeyResponse() override;
  explicit constexpr UpdateApiKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateApiKeyResponse(const UpdateApiKeyResponse& from);
  UpdateApiKeyResponse(UpdateApiKeyResponse&& from) noexcept
    : UpdateApiKeyResponse() {
    *this = ::std::move(from);
  }

  inline UpdateApiKeyResponse& operator=(const UpdateApiKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateApiKeyResponse& operator=(UpdateApiKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateApiKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateApiKeyResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateApiKeyResponse*>(
               &_UpdateApiKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UpdateApiKeyResponse& a, UpdateApiKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateApiKeyResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateApiKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateApiKeyResponse* New() const final {
    return new UpdateApiKeyResponse();
  }

  UpdateApiKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateApiKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateApiKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateApiKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateApiKeyResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse";
  }
  protected:
  explicit UpdateApiKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kApiKeyFieldNumber = 2,
    kErrorFieldNumber = 3,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string api_key = 2 [json_name = "apiKey"];
  void clear_api_key();
  const std::string& api_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_api_key();
  void set_allocated_api_key(std::string* api_key);
  private:
  const std::string& _internal_api_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_key(const std::string& value);
  std::string* _internal_mutable_api_key();
  public:

  // string error = 3 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto;
};
// -------------------------------------------------------------------

class DeleteApiKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.apikeys.v1.DeleteApiKeyRequest) */ {
 public:
  inline DeleteApiKeyRequest() : DeleteApiKeyRequest(nullptr) {}
  ~DeleteApiKeyRequest() override;
  explicit constexpr DeleteApiKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteApiKeyRequest(const DeleteApiKeyRequest& from);
  DeleteApiKeyRequest(DeleteApiKeyRequest&& from) noexcept
    : DeleteApiKeyRequest() {
    *this = ::std::move(from);
  }

  inline DeleteApiKeyRequest& operator=(const DeleteApiKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteApiKeyRequest& operator=(DeleteApiKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteApiKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteApiKeyRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteApiKeyRequest*>(
               &_DeleteApiKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DeleteApiKeyRequest& a, DeleteApiKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteApiKeyRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteApiKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteApiKeyRequest* New() const final {
    return new DeleteApiKeyRequest();
  }

  DeleteApiKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteApiKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteApiKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteApiKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteApiKeyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.apikeys.v1.DeleteApiKeyRequest";
  }
  protected:
  explicit DeleteApiKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1 [json_name = "id"];
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.apikeys.v1.DeleteApiKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto;
};
// -------------------------------------------------------------------

class DeleteApiKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse) */ {
 public:
  inline DeleteApiKeyResponse() : DeleteApiKeyResponse(nullptr) {}
  ~DeleteApiKeyResponse() override;
  explicit constexpr DeleteApiKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteApiKeyResponse(const DeleteApiKeyResponse& from);
  DeleteApiKeyResponse(DeleteApiKeyResponse&& from) noexcept
    : DeleteApiKeyResponse() {
    *this = ::std::move(from);
  }

  inline DeleteApiKeyResponse& operator=(const DeleteApiKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteApiKeyResponse& operator=(DeleteApiKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteApiKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteApiKeyResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteApiKeyResponse*>(
               &_DeleteApiKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeleteApiKeyResponse& a, DeleteApiKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteApiKeyResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteApiKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteApiKeyResponse* New() const final {
    return new DeleteApiKeyResponse();
  }

  DeleteApiKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteApiKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteApiKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteApiKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteApiKeyResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse";
  }
  protected:
  explicit DeleteApiKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kApiKeyFieldNumber = 2,
    kErrorFieldNumber = 3,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string api_key = 2 [json_name = "apiKey"];
  void clear_api_key();
  const std::string& api_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_api_key();
  void set_allocated_api_key(std::string* api_key);
  private:
  const std::string& _internal_api_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_key(const std::string& value);
  std::string* _internal_mutable_api_key();
  public:

  // string error = 3 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateApiKeyRequest

// string name = 1 [json_name = "name"];
inline void CreateApiKeyRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateApiKeyRequest::name() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateApiKeyRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.name)
}
inline std::string* CreateApiKeyRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.name)
  return _s;
}
inline const std::string& CreateApiKeyRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateApiKeyRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateApiKeyRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateApiKeyRequest::release_name() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateApiKeyRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.name)
}

// string user_id = 2 [json_name = "userId"];
inline void CreateApiKeyRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& CreateApiKeyRequest::user_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateApiKeyRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.user_id)
}
inline std::string* CreateApiKeyRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.user_id)
  return _s;
}
inline const std::string& CreateApiKeyRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void CreateApiKeyRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateApiKeyRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateApiKeyRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateApiKeyRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.user_id)
}

// repeated uint32 roles_ids = 3 [json_name = "rolesIds"];
inline int CreateApiKeyRequest::_internal_roles_ids_size() const {
  return roles_ids_.size();
}
inline int CreateApiKeyRequest::roles_ids_size() const {
  return _internal_roles_ids_size();
}
inline void CreateApiKeyRequest::clear_roles_ids() {
  roles_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateApiKeyRequest::_internal_roles_ids(int index) const {
  return roles_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateApiKeyRequest::roles_ids(int index) const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.roles_ids)
  return _internal_roles_ids(index);
}
inline void CreateApiKeyRequest::set_roles_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  roles_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.roles_ids)
}
inline void CreateApiKeyRequest::_internal_add_roles_ids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  roles_ids_.Add(value);
}
inline void CreateApiKeyRequest::add_roles_ids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_roles_ids(value);
  // @@protoc_insertion_point(field_add:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.roles_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
CreateApiKeyRequest::_internal_roles_ids() const {
  return roles_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
CreateApiKeyRequest::roles_ids() const {
  // @@protoc_insertion_point(field_list:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.roles_ids)
  return _internal_roles_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
CreateApiKeyRequest::_internal_mutable_roles_ids() {
  return &roles_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
CreateApiKeyRequest::mutable_roles_ids() {
  // @@protoc_insertion_point(field_mutable_list:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.roles_ids)
  return _internal_mutable_roles_ids();
}

// repeated uint32 permissions_ids = 4 [json_name = "permissionsIds"];
inline int CreateApiKeyRequest::_internal_permissions_ids_size() const {
  return permissions_ids_.size();
}
inline int CreateApiKeyRequest::permissions_ids_size() const {
  return _internal_permissions_ids_size();
}
inline void CreateApiKeyRequest::clear_permissions_ids() {
  permissions_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateApiKeyRequest::_internal_permissions_ids(int index) const {
  return permissions_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateApiKeyRequest::permissions_ids(int index) const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.permissions_ids)
  return _internal_permissions_ids(index);
}
inline void CreateApiKeyRequest::set_permissions_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  permissions_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.permissions_ids)
}
inline void CreateApiKeyRequest::_internal_add_permissions_ids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  permissions_ids_.Add(value);
}
inline void CreateApiKeyRequest::add_permissions_ids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_permissions_ids(value);
  // @@protoc_insertion_point(field_add:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.permissions_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
CreateApiKeyRequest::_internal_permissions_ids() const {
  return permissions_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
CreateApiKeyRequest::permissions_ids() const {
  // @@protoc_insertion_point(field_list:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.permissions_ids)
  return _internal_permissions_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
CreateApiKeyRequest::_internal_mutable_permissions_ids() {
  return &permissions_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
CreateApiKeyRequest::mutable_permissions_ids() {
  // @@protoc_insertion_point(field_mutable_list:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.permissions_ids)
  return _internal_mutable_permissions_ids();
}

// uint32 organization_id = 5 [json_name = "organizationId"];
inline void CreateApiKeyRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateApiKeyRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateApiKeyRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.organization_id)
  return _internal_organization_id();
}
inline void CreateApiKeyRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void CreateApiKeyRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.organization_id)
}

// bool is_active = 6 [json_name = "isActive"];
inline void CreateApiKeyRequest::clear_is_active() {
  is_active_ = false;
}
inline bool CreateApiKeyRequest::_internal_is_active() const {
  return is_active_;
}
inline bool CreateApiKeyRequest::is_active() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.is_active)
  return _internal_is_active();
}
inline void CreateApiKeyRequest::_internal_set_is_active(bool value) {
  
  is_active_ = value;
}
inline void CreateApiKeyRequest::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.is_active)
}

// uint32 project_id = 7 [json_name = "projectId"];
inline void CreateApiKeyRequest::clear_project_id() {
  project_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateApiKeyRequest::_internal_project_id() const {
  return project_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateApiKeyRequest::project_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.project_id)
  return _internal_project_id();
}
inline void CreateApiKeyRequest::_internal_set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  project_id_ = value;
}
inline void CreateApiKeyRequest::set_project_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_project_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest.project_id)
}

// -------------------------------------------------------------------

// CreateApiKeyResponse

// string msg = 1 [json_name = "msg"];
inline void CreateApiKeyResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& CreateApiKeyResponse::msg() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateApiKeyResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.msg)
}
inline std::string* CreateApiKeyResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.msg)
  return _s;
}
inline const std::string& CreateApiKeyResponse::_internal_msg() const {
  return msg_.Get();
}
inline void CreateApiKeyResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateApiKeyResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateApiKeyResponse::release_msg() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateApiKeyResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.msg)
}

// string api_key = 2 [json_name = "apiKey"];
inline void CreateApiKeyResponse::clear_api_key() {
  api_key_.ClearToEmpty();
}
inline const std::string& CreateApiKeyResponse::api_key() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.api_key)
  return _internal_api_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateApiKeyResponse::set_api_key(ArgT0&& arg0, ArgT... args) {
 
 api_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.api_key)
}
inline std::string* CreateApiKeyResponse::mutable_api_key() {
  std::string* _s = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.api_key)
  return _s;
}
inline const std::string& CreateApiKeyResponse::_internal_api_key() const {
  return api_key_.Get();
}
inline void CreateApiKeyResponse::_internal_set_api_key(const std::string& value) {
  
  api_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateApiKeyResponse::_internal_mutable_api_key() {
  
  return api_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateApiKeyResponse::release_api_key() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.api_key)
  return api_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateApiKeyResponse::set_allocated_api_key(std::string* api_key) {
  if (api_key != nullptr) {
    
  } else {
    
  }
  api_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), api_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.api_key)
}

// uint32 access_point_id = 4 [json_name = "accessPointId"];
inline void CreateApiKeyResponse::clear_access_point_id() {
  access_point_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateApiKeyResponse::_internal_access_point_id() const {
  return access_point_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateApiKeyResponse::access_point_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.access_point_id)
  return _internal_access_point_id();
}
inline void CreateApiKeyResponse::_internal_set_access_point_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  access_point_id_ = value;
}
inline void CreateApiKeyResponse::set_access_point_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_access_point_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.access_point_id)
}

// string error = 5 [json_name = "error"];
inline void CreateApiKeyResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& CreateApiKeyResponse::error() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateApiKeyResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.error)
}
inline std::string* CreateApiKeyResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.error)
  return _s;
}
inline const std::string& CreateApiKeyResponse::_internal_error() const {
  return error_.Get();
}
inline void CreateApiKeyResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateApiKeyResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateApiKeyResponse::release_error() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateApiKeyResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.CreateApiKeyResponse.error)
}

// -------------------------------------------------------------------

// GetOneApiKeyRequest

// uint32 id = 1 [json_name = "id"];
inline void GetOneApiKeyRequest::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOneApiKeyRequest::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOneApiKeyRequest::id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.GetOneApiKeyRequest.id)
  return _internal_id();
}
inline void GetOneApiKeyRequest::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void GetOneApiKeyRequest::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.GetOneApiKeyRequest.id)
}

// string value_key = 2 [json_name = "valueKey"];
inline void GetOneApiKeyRequest::clear_value_key() {
  value_key_.ClearToEmpty();
}
inline const std::string& GetOneApiKeyRequest::value_key() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.GetOneApiKeyRequest.value_key)
  return _internal_value_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOneApiKeyRequest::set_value_key(ArgT0&& arg0, ArgT... args) {
 
 value_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.GetOneApiKeyRequest.value_key)
}
inline std::string* GetOneApiKeyRequest::mutable_value_key() {
  std::string* _s = _internal_mutable_value_key();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.GetOneApiKeyRequest.value_key)
  return _s;
}
inline const std::string& GetOneApiKeyRequest::_internal_value_key() const {
  return value_key_.Get();
}
inline void GetOneApiKeyRequest::_internal_set_value_key(const std::string& value) {
  
  value_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOneApiKeyRequest::_internal_mutable_value_key() {
  
  return value_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOneApiKeyRequest::release_value_key() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.GetOneApiKeyRequest.value_key)
  return value_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOneApiKeyRequest::set_allocated_value_key(std::string* value_key) {
  if (value_key != nullptr) {
    
  } else {
    
  }
  value_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.GetOneApiKeyRequest.value_key)
}

// -------------------------------------------------------------------

// GetOneApiKeyResponse

// uint32 id = 1 [json_name = "id"];
inline void GetOneApiKeyResponse::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOneApiKeyResponse::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetOneApiKeyResponse::id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.id)
  return _internal_id();
}
inline void GetOneApiKeyResponse::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void GetOneApiKeyResponse::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.id)
}

// string api_key = 2 [json_name = "apiKey"];
inline void GetOneApiKeyResponse::clear_api_key() {
  api_key_.ClearToEmpty();
}
inline const std::string& GetOneApiKeyResponse::api_key() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.api_key)
  return _internal_api_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOneApiKeyResponse::set_api_key(ArgT0&& arg0, ArgT... args) {
 
 api_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.api_key)
}
inline std::string* GetOneApiKeyResponse::mutable_api_key() {
  std::string* _s = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.api_key)
  return _s;
}
inline const std::string& GetOneApiKeyResponse::_internal_api_key() const {
  return api_key_.Get();
}
inline void GetOneApiKeyResponse::_internal_set_api_key(const std::string& value) {
  
  api_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOneApiKeyResponse::_internal_mutable_api_key() {
  
  return api_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOneApiKeyResponse::release_api_key() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.api_key)
  return api_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOneApiKeyResponse::set_allocated_api_key(std::string* api_key) {
  if (api_key != nullptr) {
    
  } else {
    
  }
  api_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), api_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.api_key)
}

// string name = 3 [json_name = "name"];
inline void GetOneApiKeyResponse::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GetOneApiKeyResponse::name() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOneApiKeyResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.name)
}
inline std::string* GetOneApiKeyResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.name)
  return _s;
}
inline const std::string& GetOneApiKeyResponse::_internal_name() const {
  return name_.Get();
}
inline void GetOneApiKeyResponse::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOneApiKeyResponse::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOneApiKeyResponse::release_name() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOneApiKeyResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.name)
}

// string user_id = 4 [json_name = "userId"];
inline void GetOneApiKeyResponse::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& GetOneApiKeyResponse::user_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOneApiKeyResponse::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.user_id)
}
inline std::string* GetOneApiKeyResponse::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.user_id)
  return _s;
}
inline const std::string& GetOneApiKeyResponse::_internal_user_id() const {
  return user_id_.Get();
}
inline void GetOneApiKeyResponse::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOneApiKeyResponse::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOneApiKeyResponse::release_user_id() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOneApiKeyResponse::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.user_id)
}

// repeated .accounts.v1alpha1.Role roles = 5 [json_name = "roles"];
inline int GetOneApiKeyResponse::_internal_roles_size() const {
  return roles_.size();
}
inline int GetOneApiKeyResponse::roles_size() const {
  return _internal_roles_size();
}
inline ::accounts::v1alpha1::Role* GetOneApiKeyResponse::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.roles)
  return roles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::Role >*
GetOneApiKeyResponse::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.roles)
  return &roles_;
}
inline const ::accounts::v1alpha1::Role& GetOneApiKeyResponse::_internal_roles(int index) const {
  return roles_.Get(index);
}
inline const ::accounts::v1alpha1::Role& GetOneApiKeyResponse::roles(int index) const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.roles)
  return _internal_roles(index);
}
inline ::accounts::v1alpha1::Role* GetOneApiKeyResponse::_internal_add_roles() {
  return roles_.Add();
}
inline ::accounts::v1alpha1::Role* GetOneApiKeyResponse::add_roles() {
  ::accounts::v1alpha1::Role* _add = _internal_add_roles();
  // @@protoc_insertion_point(field_add:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.roles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::Role >&
GetOneApiKeyResponse::roles() const {
  // @@protoc_insertion_point(field_list:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.roles)
  return roles_;
}

// repeated .accounts.v1alpha1.Permission permissions = 6 [json_name = "permissions"];
inline int GetOneApiKeyResponse::_internal_permissions_size() const {
  return permissions_.size();
}
inline int GetOneApiKeyResponse::permissions_size() const {
  return _internal_permissions_size();
}
inline ::accounts::v1alpha1::Permission* GetOneApiKeyResponse::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.permissions)
  return permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::Permission >*
GetOneApiKeyResponse::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.permissions)
  return &permissions_;
}
inline const ::accounts::v1alpha1::Permission& GetOneApiKeyResponse::_internal_permissions(int index) const {
  return permissions_.Get(index);
}
inline const ::accounts::v1alpha1::Permission& GetOneApiKeyResponse::permissions(int index) const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.permissions)
  return _internal_permissions(index);
}
inline ::accounts::v1alpha1::Permission* GetOneApiKeyResponse::_internal_add_permissions() {
  return permissions_.Add();
}
inline ::accounts::v1alpha1::Permission* GetOneApiKeyResponse::add_permissions() {
  ::accounts::v1alpha1::Permission* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::Permission >&
GetOneApiKeyResponse::permissions() const {
  // @@protoc_insertion_point(field_list:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.permissions)
  return permissions_;
}

// bool is_active = 8 [json_name = "isActive"];
inline void GetOneApiKeyResponse::clear_is_active() {
  is_active_ = false;
}
inline bool GetOneApiKeyResponse::_internal_is_active() const {
  return is_active_;
}
inline bool GetOneApiKeyResponse::is_active() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.is_active)
  return _internal_is_active();
}
inline void GetOneApiKeyResponse::_internal_set_is_active(bool value) {
  
  is_active_ = value;
}
inline void GetOneApiKeyResponse::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.is_active)
}

// .accounts.v1alpha1.Project project = 9 [json_name = "project"];
inline bool GetOneApiKeyResponse::_internal_has_project() const {
  return this != internal_default_instance() && project_ != nullptr;
}
inline bool GetOneApiKeyResponse::has_project() const {
  return _internal_has_project();
}
inline const ::accounts::v1alpha1::Project& GetOneApiKeyResponse::_internal_project() const {
  const ::accounts::v1alpha1::Project* p = project_;
  return p != nullptr ? *p : reinterpret_cast<const ::accounts::v1alpha1::Project&>(
      ::accounts::v1alpha1::_Project_default_instance_);
}
inline const ::accounts::v1alpha1::Project& GetOneApiKeyResponse::project() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.project)
  return _internal_project();
}
inline void GetOneApiKeyResponse::unsafe_arena_set_allocated_project(
    ::accounts::v1alpha1::Project* project) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_);
  }
  project_ = project;
  if (project) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.project)
}
inline ::accounts::v1alpha1::Project* GetOneApiKeyResponse::release_project() {
  
  ::accounts::v1alpha1::Project* temp = project_;
  project_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::accounts::v1alpha1::Project* GetOneApiKeyResponse::unsafe_arena_release_project() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.project)
  
  ::accounts::v1alpha1::Project* temp = project_;
  project_ = nullptr;
  return temp;
}
inline ::accounts::v1alpha1::Project* GetOneApiKeyResponse::_internal_mutable_project() {
  
  if (project_ == nullptr) {
    auto* p = CreateMaybeMessage<::accounts::v1alpha1::Project>(GetArenaForAllocation());
    project_ = p;
  }
  return project_;
}
inline ::accounts::v1alpha1::Project* GetOneApiKeyResponse::mutable_project() {
  ::accounts::v1alpha1::Project* _msg = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.project)
  return _msg;
}
inline void GetOneApiKeyResponse::set_allocated_project(::accounts::v1alpha1::Project* project) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_);
  }
  if (project) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project));
    if (message_arena != submessage_arena) {
      project = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, project, submessage_arena);
    }
    
  } else {
    
  }
  project_ = project;
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.project)
}

// .accounts.v1alpha1.Organization organization = 10 [json_name = "organization"];
inline bool GetOneApiKeyResponse::_internal_has_organization() const {
  return this != internal_default_instance() && organization_ != nullptr;
}
inline bool GetOneApiKeyResponse::has_organization() const {
  return _internal_has_organization();
}
inline const ::accounts::v1alpha1::Organization& GetOneApiKeyResponse::_internal_organization() const {
  const ::accounts::v1alpha1::Organization* p = organization_;
  return p != nullptr ? *p : reinterpret_cast<const ::accounts::v1alpha1::Organization&>(
      ::accounts::v1alpha1::_Organization_default_instance_);
}
inline const ::accounts::v1alpha1::Organization& GetOneApiKeyResponse::organization() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.organization)
  return _internal_organization();
}
inline void GetOneApiKeyResponse::unsafe_arena_set_allocated_organization(
    ::accounts::v1alpha1::Organization* organization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(organization_);
  }
  organization_ = organization;
  if (organization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.organization)
}
inline ::accounts::v1alpha1::Organization* GetOneApiKeyResponse::release_organization() {
  
  ::accounts::v1alpha1::Organization* temp = organization_;
  organization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::accounts::v1alpha1::Organization* GetOneApiKeyResponse::unsafe_arena_release_organization() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.organization)
  
  ::accounts::v1alpha1::Organization* temp = organization_;
  organization_ = nullptr;
  return temp;
}
inline ::accounts::v1alpha1::Organization* GetOneApiKeyResponse::_internal_mutable_organization() {
  
  if (organization_ == nullptr) {
    auto* p = CreateMaybeMessage<::accounts::v1alpha1::Organization>(GetArenaForAllocation());
    organization_ = p;
  }
  return organization_;
}
inline ::accounts::v1alpha1::Organization* GetOneApiKeyResponse::mutable_organization() {
  ::accounts::v1alpha1::Organization* _msg = _internal_mutable_organization();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.organization)
  return _msg;
}
inline void GetOneApiKeyResponse::set_allocated_organization(::accounts::v1alpha1::Organization* organization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(organization_);
  }
  if (organization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(organization));
    if (message_arena != submessage_arena) {
      organization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, organization, submessage_arena);
    }
    
  } else {
    
  }
  organization_ = organization;
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.GetOneApiKeyResponse.organization)
}

// -------------------------------------------------------------------

// ListApiKeyRequest

// string user_id = 1 [json_name = "userId"];
inline void ListApiKeyRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& ListApiKeyRequest::user_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.ListApiKeyRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListApiKeyRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.ListApiKeyRequest.user_id)
}
inline std::string* ListApiKeyRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.ListApiKeyRequest.user_id)
  return _s;
}
inline const std::string& ListApiKeyRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void ListApiKeyRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListApiKeyRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListApiKeyRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.ListApiKeyRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListApiKeyRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.ListApiKeyRequest.user_id)
}

// uint32 organization_id = 2 [json_name = "organizationId"];
inline void ListApiKeyRequest::clear_organization_id() {
  organization_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListApiKeyRequest::_internal_organization_id() const {
  return organization_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListApiKeyRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.ListApiKeyRequest.organization_id)
  return _internal_organization_id();
}
inline void ListApiKeyRequest::_internal_set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  organization_id_ = value;
}
inline void ListApiKeyRequest::set_organization_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_organization_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.ListApiKeyRequest.organization_id)
}

// -------------------------------------------------------------------

// ApiKeyList

// uint32 id = 1 [json_name = "id"];
inline void ApiKeyList::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ApiKeyList::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ApiKeyList::id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.ApiKeyList.id)
  return _internal_id();
}
inline void ApiKeyList::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void ApiKeyList::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.ApiKeyList.id)
}

// string api_key = 2 [json_name = "apiKey"];
inline void ApiKeyList::clear_api_key() {
  api_key_.ClearToEmpty();
}
inline const std::string& ApiKeyList::api_key() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.ApiKeyList.api_key)
  return _internal_api_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApiKeyList::set_api_key(ArgT0&& arg0, ArgT... args) {
 
 api_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.ApiKeyList.api_key)
}
inline std::string* ApiKeyList::mutable_api_key() {
  std::string* _s = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.ApiKeyList.api_key)
  return _s;
}
inline const std::string& ApiKeyList::_internal_api_key() const {
  return api_key_.Get();
}
inline void ApiKeyList::_internal_set_api_key(const std::string& value) {
  
  api_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ApiKeyList::_internal_mutable_api_key() {
  
  return api_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ApiKeyList::release_api_key() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.ApiKeyList.api_key)
  return api_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ApiKeyList::set_allocated_api_key(std::string* api_key) {
  if (api_key != nullptr) {
    
  } else {
    
  }
  api_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), api_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.ApiKeyList.api_key)
}

// string name = 3 [json_name = "name"];
inline void ApiKeyList::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ApiKeyList::name() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.ApiKeyList.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApiKeyList::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.ApiKeyList.name)
}
inline std::string* ApiKeyList::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.ApiKeyList.name)
  return _s;
}
inline const std::string& ApiKeyList::_internal_name() const {
  return name_.Get();
}
inline void ApiKeyList::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ApiKeyList::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ApiKeyList::release_name() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.ApiKeyList.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ApiKeyList::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.ApiKeyList.name)
}

// string user_id = 4 [json_name = "userId"];
inline void ApiKeyList::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& ApiKeyList::user_id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.ApiKeyList.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApiKeyList::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.ApiKeyList.user_id)
}
inline std::string* ApiKeyList::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.ApiKeyList.user_id)
  return _s;
}
inline const std::string& ApiKeyList::_internal_user_id() const {
  return user_id_.Get();
}
inline void ApiKeyList::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ApiKeyList::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ApiKeyList::release_user_id() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.ApiKeyList.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ApiKeyList::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.ApiKeyList.user_id)
}

// bool is_active = 6 [json_name = "isActive"];
inline void ApiKeyList::clear_is_active() {
  is_active_ = false;
}
inline bool ApiKeyList::_internal_is_active() const {
  return is_active_;
}
inline bool ApiKeyList::is_active() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.ApiKeyList.is_active)
  return _internal_is_active();
}
inline void ApiKeyList::_internal_set_is_active(bool value) {
  
  is_active_ = value;
}
inline void ApiKeyList::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.ApiKeyList.is_active)
}

// .accounts.v1alpha1.Project project = 7 [json_name = "project"];
inline bool ApiKeyList::_internal_has_project() const {
  return this != internal_default_instance() && project_ != nullptr;
}
inline bool ApiKeyList::has_project() const {
  return _internal_has_project();
}
inline const ::accounts::v1alpha1::Project& ApiKeyList::_internal_project() const {
  const ::accounts::v1alpha1::Project* p = project_;
  return p != nullptr ? *p : reinterpret_cast<const ::accounts::v1alpha1::Project&>(
      ::accounts::v1alpha1::_Project_default_instance_);
}
inline const ::accounts::v1alpha1::Project& ApiKeyList::project() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.ApiKeyList.project)
  return _internal_project();
}
inline void ApiKeyList::unsafe_arena_set_allocated_project(
    ::accounts::v1alpha1::Project* project) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_);
  }
  project_ = project;
  if (project) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:accounts.v1alpha1.apikeys.v1.ApiKeyList.project)
}
inline ::accounts::v1alpha1::Project* ApiKeyList::release_project() {
  
  ::accounts::v1alpha1::Project* temp = project_;
  project_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::accounts::v1alpha1::Project* ApiKeyList::unsafe_arena_release_project() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.ApiKeyList.project)
  
  ::accounts::v1alpha1::Project* temp = project_;
  project_ = nullptr;
  return temp;
}
inline ::accounts::v1alpha1::Project* ApiKeyList::_internal_mutable_project() {
  
  if (project_ == nullptr) {
    auto* p = CreateMaybeMessage<::accounts::v1alpha1::Project>(GetArenaForAllocation());
    project_ = p;
  }
  return project_;
}
inline ::accounts::v1alpha1::Project* ApiKeyList::mutable_project() {
  ::accounts::v1alpha1::Project* _msg = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.ApiKeyList.project)
  return _msg;
}
inline void ApiKeyList::set_allocated_project(::accounts::v1alpha1::Project* project) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(project_);
  }
  if (project) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(project));
    if (message_arena != submessage_arena) {
      project = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, project, submessage_arena);
    }
    
  } else {
    
  }
  project_ = project;
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.ApiKeyList.project)
}

// .accounts.v1alpha1.Organization organization = 8 [json_name = "organization"];
inline bool ApiKeyList::_internal_has_organization() const {
  return this != internal_default_instance() && organization_ != nullptr;
}
inline bool ApiKeyList::has_organization() const {
  return _internal_has_organization();
}
inline const ::accounts::v1alpha1::Organization& ApiKeyList::_internal_organization() const {
  const ::accounts::v1alpha1::Organization* p = organization_;
  return p != nullptr ? *p : reinterpret_cast<const ::accounts::v1alpha1::Organization&>(
      ::accounts::v1alpha1::_Organization_default_instance_);
}
inline const ::accounts::v1alpha1::Organization& ApiKeyList::organization() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.ApiKeyList.organization)
  return _internal_organization();
}
inline void ApiKeyList::unsafe_arena_set_allocated_organization(
    ::accounts::v1alpha1::Organization* organization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(organization_);
  }
  organization_ = organization;
  if (organization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:accounts.v1alpha1.apikeys.v1.ApiKeyList.organization)
}
inline ::accounts::v1alpha1::Organization* ApiKeyList::release_organization() {
  
  ::accounts::v1alpha1::Organization* temp = organization_;
  organization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::accounts::v1alpha1::Organization* ApiKeyList::unsafe_arena_release_organization() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.ApiKeyList.organization)
  
  ::accounts::v1alpha1::Organization* temp = organization_;
  organization_ = nullptr;
  return temp;
}
inline ::accounts::v1alpha1::Organization* ApiKeyList::_internal_mutable_organization() {
  
  if (organization_ == nullptr) {
    auto* p = CreateMaybeMessage<::accounts::v1alpha1::Organization>(GetArenaForAllocation());
    organization_ = p;
  }
  return organization_;
}
inline ::accounts::v1alpha1::Organization* ApiKeyList::mutable_organization() {
  ::accounts::v1alpha1::Organization* _msg = _internal_mutable_organization();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.ApiKeyList.organization)
  return _msg;
}
inline void ApiKeyList::set_allocated_organization(::accounts::v1alpha1::Organization* organization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(organization_);
  }
  if (organization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(organization));
    if (message_arena != submessage_arena) {
      organization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, organization, submessage_arena);
    }
    
  } else {
    
  }
  organization_ = organization;
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.ApiKeyList.organization)
}

// -------------------------------------------------------------------

// ListApiKeyResponse

// repeated .accounts.v1alpha1.apikeys.v1.ApiKeyList api_keys = 1 [json_name = "apiKeys"];
inline int ListApiKeyResponse::_internal_api_keys_size() const {
  return api_keys_.size();
}
inline int ListApiKeyResponse::api_keys_size() const {
  return _internal_api_keys_size();
}
inline void ListApiKeyResponse::clear_api_keys() {
  api_keys_.Clear();
}
inline ::accounts::v1alpha1::apikeys::v1::ApiKeyList* ListApiKeyResponse::mutable_api_keys(int index) {
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.ListApiKeyResponse.api_keys)
  return api_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::apikeys::v1::ApiKeyList >*
ListApiKeyResponse::mutable_api_keys() {
  // @@protoc_insertion_point(field_mutable_list:accounts.v1alpha1.apikeys.v1.ListApiKeyResponse.api_keys)
  return &api_keys_;
}
inline const ::accounts::v1alpha1::apikeys::v1::ApiKeyList& ListApiKeyResponse::_internal_api_keys(int index) const {
  return api_keys_.Get(index);
}
inline const ::accounts::v1alpha1::apikeys::v1::ApiKeyList& ListApiKeyResponse::api_keys(int index) const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.ListApiKeyResponse.api_keys)
  return _internal_api_keys(index);
}
inline ::accounts::v1alpha1::apikeys::v1::ApiKeyList* ListApiKeyResponse::_internal_add_api_keys() {
  return api_keys_.Add();
}
inline ::accounts::v1alpha1::apikeys::v1::ApiKeyList* ListApiKeyResponse::add_api_keys() {
  ::accounts::v1alpha1::apikeys::v1::ApiKeyList* _add = _internal_add_api_keys();
  // @@protoc_insertion_point(field_add:accounts.v1alpha1.apikeys.v1.ListApiKeyResponse.api_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::accounts::v1alpha1::apikeys::v1::ApiKeyList >&
ListApiKeyResponse::api_keys() const {
  // @@protoc_insertion_point(field_list:accounts.v1alpha1.apikeys.v1.ListApiKeyResponse.api_keys)
  return api_keys_;
}

// -------------------------------------------------------------------

// UpdateApiKeyRequest

// uint32 id = 1 [json_name = "id"];
inline void UpdateApiKeyRequest::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateApiKeyRequest::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateApiKeyRequest::id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.UpdateApiKeyRequest.id)
  return _internal_id();
}
inline void UpdateApiKeyRequest::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void UpdateApiKeyRequest::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.UpdateApiKeyRequest.id)
}

// .accounts.v1alpha1.apikeys.v1.CreateApiKeyRequest api_key = 6 [json_name = "apiKey"];
inline bool UpdateApiKeyRequest::_internal_has_api_key() const {
  return this != internal_default_instance() && api_key_ != nullptr;
}
inline bool UpdateApiKeyRequest::has_api_key() const {
  return _internal_has_api_key();
}
inline void UpdateApiKeyRequest::clear_api_key() {
  if (GetArenaForAllocation() == nullptr && api_key_ != nullptr) {
    delete api_key_;
  }
  api_key_ = nullptr;
}
inline const ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest& UpdateApiKeyRequest::_internal_api_key() const {
  const ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* p = api_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest&>(
      ::accounts::v1alpha1::apikeys::v1::_CreateApiKeyRequest_default_instance_);
}
inline const ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest& UpdateApiKeyRequest::api_key() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.UpdateApiKeyRequest.api_key)
  return _internal_api_key();
}
inline void UpdateApiKeyRequest::unsafe_arena_set_allocated_api_key(
    ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* api_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_key_);
  }
  api_key_ = api_key;
  if (api_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:accounts.v1alpha1.apikeys.v1.UpdateApiKeyRequest.api_key)
}
inline ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* UpdateApiKeyRequest::release_api_key() {
  
  ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* temp = api_key_;
  api_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* UpdateApiKeyRequest::unsafe_arena_release_api_key() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.UpdateApiKeyRequest.api_key)
  
  ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* temp = api_key_;
  api_key_ = nullptr;
  return temp;
}
inline ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* UpdateApiKeyRequest::_internal_mutable_api_key() {
  
  if (api_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest>(GetArenaForAllocation());
    api_key_ = p;
  }
  return api_key_;
}
inline ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* UpdateApiKeyRequest::mutable_api_key() {
  ::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* _msg = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.UpdateApiKeyRequest.api_key)
  return _msg;
}
inline void UpdateApiKeyRequest::set_allocated_api_key(::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest* api_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete api_key_;
  }
  if (api_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::accounts::v1alpha1::apikeys::v1::CreateApiKeyRequest>::GetOwningArena(api_key);
    if (message_arena != submessage_arena) {
      api_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, api_key, submessage_arena);
    }
    
  } else {
    
  }
  api_key_ = api_key;
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.UpdateApiKeyRequest.api_key)
}

// -------------------------------------------------------------------

// UpdateApiKeyResponse

// string msg = 1 [json_name = "msg"];
inline void UpdateApiKeyResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& UpdateApiKeyResponse::msg() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateApiKeyResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse.msg)
}
inline std::string* UpdateApiKeyResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse.msg)
  return _s;
}
inline const std::string& UpdateApiKeyResponse::_internal_msg() const {
  return msg_.Get();
}
inline void UpdateApiKeyResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateApiKeyResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateApiKeyResponse::release_msg() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateApiKeyResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse.msg)
}

// string api_key = 2 [json_name = "apiKey"];
inline void UpdateApiKeyResponse::clear_api_key() {
  api_key_.ClearToEmpty();
}
inline const std::string& UpdateApiKeyResponse::api_key() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse.api_key)
  return _internal_api_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateApiKeyResponse::set_api_key(ArgT0&& arg0, ArgT... args) {
 
 api_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse.api_key)
}
inline std::string* UpdateApiKeyResponse::mutable_api_key() {
  std::string* _s = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse.api_key)
  return _s;
}
inline const std::string& UpdateApiKeyResponse::_internal_api_key() const {
  return api_key_.Get();
}
inline void UpdateApiKeyResponse::_internal_set_api_key(const std::string& value) {
  
  api_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateApiKeyResponse::_internal_mutable_api_key() {
  
  return api_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateApiKeyResponse::release_api_key() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse.api_key)
  return api_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateApiKeyResponse::set_allocated_api_key(std::string* api_key) {
  if (api_key != nullptr) {
    
  } else {
    
  }
  api_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), api_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse.api_key)
}

// string error = 3 [json_name = "error"];
inline void UpdateApiKeyResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& UpdateApiKeyResponse::error() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateApiKeyResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse.error)
}
inline std::string* UpdateApiKeyResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse.error)
  return _s;
}
inline const std::string& UpdateApiKeyResponse::_internal_error() const {
  return error_.Get();
}
inline void UpdateApiKeyResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateApiKeyResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateApiKeyResponse::release_error() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateApiKeyResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.UpdateApiKeyResponse.error)
}

// -------------------------------------------------------------------

// DeleteApiKeyRequest

// uint32 id = 1 [json_name = "id"];
inline void DeleteApiKeyRequest::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteApiKeyRequest::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeleteApiKeyRequest::id() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.DeleteApiKeyRequest.id)
  return _internal_id();
}
inline void DeleteApiKeyRequest::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void DeleteApiKeyRequest::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.DeleteApiKeyRequest.id)
}

// -------------------------------------------------------------------

// DeleteApiKeyResponse

// string msg = 1 [json_name = "msg"];
inline void DeleteApiKeyResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& DeleteApiKeyResponse::msg() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteApiKeyResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse.msg)
}
inline std::string* DeleteApiKeyResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse.msg)
  return _s;
}
inline const std::string& DeleteApiKeyResponse::_internal_msg() const {
  return msg_.Get();
}
inline void DeleteApiKeyResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteApiKeyResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteApiKeyResponse::release_msg() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteApiKeyResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse.msg)
}

// string api_key = 2 [json_name = "apiKey"];
inline void DeleteApiKeyResponse::clear_api_key() {
  api_key_.ClearToEmpty();
}
inline const std::string& DeleteApiKeyResponse::api_key() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse.api_key)
  return _internal_api_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteApiKeyResponse::set_api_key(ArgT0&& arg0, ArgT... args) {
 
 api_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse.api_key)
}
inline std::string* DeleteApiKeyResponse::mutable_api_key() {
  std::string* _s = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse.api_key)
  return _s;
}
inline const std::string& DeleteApiKeyResponse::_internal_api_key() const {
  return api_key_.Get();
}
inline void DeleteApiKeyResponse::_internal_set_api_key(const std::string& value) {
  
  api_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteApiKeyResponse::_internal_mutable_api_key() {
  
  return api_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteApiKeyResponse::release_api_key() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse.api_key)
  return api_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteApiKeyResponse::set_allocated_api_key(std::string* api_key) {
  if (api_key != nullptr) {
    
  } else {
    
  }
  api_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), api_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse.api_key)
}

// string error = 3 [json_name = "error"];
inline void DeleteApiKeyResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& DeleteApiKeyResponse::error() const {
  // @@protoc_insertion_point(field_get:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteApiKeyResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse.error)
}
inline std::string* DeleteApiKeyResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse.error)
  return _s;
}
inline const std::string& DeleteApiKeyResponse::_internal_error() const {
  return error_.Get();
}
inline void DeleteApiKeyResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteApiKeyResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteApiKeyResponse::release_error() {
  // @@protoc_insertion_point(field_release:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteApiKeyResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:accounts.v1alpha1.apikeys.v1.DeleteApiKeyResponse.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace apikeys
}  // namespace v1alpha1
}  // namespace accounts

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_accounts_2fv1alpha1_2fapikeys_2fapikeys_2eproto
