// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pipelines/tekton/v1alpha1/tekton_api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "pipelines/tekton/v1alpha1/tekton.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto;
namespace pipelines {
namespace tekton {
namespace v1alpha1 {
class ChangeStatusRuntimeAndApplicationRequest;
struct ChangeStatusRuntimeAndApplicationRequestDefaultTypeInternal;
extern ChangeStatusRuntimeAndApplicationRequestDefaultTypeInternal _ChangeStatusRuntimeAndApplicationRequest_default_instance_;
class ChangeStatusRuntimeAndApplicationResponse;
struct ChangeStatusRuntimeAndApplicationResponseDefaultTypeInternal;
extern ChangeStatusRuntimeAndApplicationResponseDefaultTypeInternal _ChangeStatusRuntimeAndApplicationResponse_default_instance_;
class CreateTektonPipelineRequest;
struct CreateTektonPipelineRequestDefaultTypeInternal;
extern CreateTektonPipelineRequestDefaultTypeInternal _CreateTektonPipelineRequest_default_instance_;
class CreateTektonPipelineResponse;
struct CreateTektonPipelineResponseDefaultTypeInternal;
extern CreateTektonPipelineResponseDefaultTypeInternal _CreateTektonPipelineResponse_default_instance_;
class DeleteTektonPipelineRequest;
struct DeleteTektonPipelineRequestDefaultTypeInternal;
extern DeleteTektonPipelineRequestDefaultTypeInternal _DeleteTektonPipelineRequest_default_instance_;
class DeleteTektonPipelineResponse;
struct DeleteTektonPipelineResponseDefaultTypeInternal;
extern DeleteTektonPipelineResponseDefaultTypeInternal _DeleteTektonPipelineResponse_default_instance_;
class GetPipelineRunRequest;
struct GetPipelineRunRequestDefaultTypeInternal;
extern GetPipelineRunRequestDefaultTypeInternal _GetPipelineRunRequest_default_instance_;
class GetPipelineRunResponse;
struct GetPipelineRunResponseDefaultTypeInternal;
extern GetPipelineRunResponseDefaultTypeInternal _GetPipelineRunResponse_default_instance_;
class GetStatusRuntimeRequest;
struct GetStatusRuntimeRequestDefaultTypeInternal;
extern GetStatusRuntimeRequestDefaultTypeInternal _GetStatusRuntimeRequest_default_instance_;
class GetStatusRuntimeResponse;
struct GetStatusRuntimeResponseDefaultTypeInternal;
extern GetStatusRuntimeResponseDefaultTypeInternal _GetStatusRuntimeResponse_default_instance_;
class ListPipelineRunRequest;
struct ListPipelineRunRequestDefaultTypeInternal;
extern ListPipelineRunRequestDefaultTypeInternal _ListPipelineRunRequest_default_instance_;
class ListPipelineRunResponse;
struct ListPipelineRunResponseDefaultTypeInternal;
extern ListPipelineRunResponseDefaultTypeInternal _ListPipelineRunResponse_default_instance_;
class ListTektonTaskPipelineRequest;
struct ListTektonTaskPipelineRequestDefaultTypeInternal;
extern ListTektonTaskPipelineRequestDefaultTypeInternal _ListTektonTaskPipelineRequest_default_instance_;
class ListTektonTaskPipelineResponse;
struct ListTektonTaskPipelineResponseDefaultTypeInternal;
extern ListTektonTaskPipelineResponseDefaultTypeInternal _ListTektonTaskPipelineResponse_default_instance_;
}  // namespace v1alpha1
}  // namespace tekton
}  // namespace pipelines
PROTOBUF_NAMESPACE_OPEN
template<> ::pipelines::tekton::v1alpha1::ChangeStatusRuntimeAndApplicationRequest* Arena::CreateMaybeMessage<::pipelines::tekton::v1alpha1::ChangeStatusRuntimeAndApplicationRequest>(Arena*);
template<> ::pipelines::tekton::v1alpha1::ChangeStatusRuntimeAndApplicationResponse* Arena::CreateMaybeMessage<::pipelines::tekton::v1alpha1::ChangeStatusRuntimeAndApplicationResponse>(Arena*);
template<> ::pipelines::tekton::v1alpha1::CreateTektonPipelineRequest* Arena::CreateMaybeMessage<::pipelines::tekton::v1alpha1::CreateTektonPipelineRequest>(Arena*);
template<> ::pipelines::tekton::v1alpha1::CreateTektonPipelineResponse* Arena::CreateMaybeMessage<::pipelines::tekton::v1alpha1::CreateTektonPipelineResponse>(Arena*);
template<> ::pipelines::tekton::v1alpha1::DeleteTektonPipelineRequest* Arena::CreateMaybeMessage<::pipelines::tekton::v1alpha1::DeleteTektonPipelineRequest>(Arena*);
template<> ::pipelines::tekton::v1alpha1::DeleteTektonPipelineResponse* Arena::CreateMaybeMessage<::pipelines::tekton::v1alpha1::DeleteTektonPipelineResponse>(Arena*);
template<> ::pipelines::tekton::v1alpha1::GetPipelineRunRequest* Arena::CreateMaybeMessage<::pipelines::tekton::v1alpha1::GetPipelineRunRequest>(Arena*);
template<> ::pipelines::tekton::v1alpha1::GetPipelineRunResponse* Arena::CreateMaybeMessage<::pipelines::tekton::v1alpha1::GetPipelineRunResponse>(Arena*);
template<> ::pipelines::tekton::v1alpha1::GetStatusRuntimeRequest* Arena::CreateMaybeMessage<::pipelines::tekton::v1alpha1::GetStatusRuntimeRequest>(Arena*);
template<> ::pipelines::tekton::v1alpha1::GetStatusRuntimeResponse* Arena::CreateMaybeMessage<::pipelines::tekton::v1alpha1::GetStatusRuntimeResponse>(Arena*);
template<> ::pipelines::tekton::v1alpha1::ListPipelineRunRequest* Arena::CreateMaybeMessage<::pipelines::tekton::v1alpha1::ListPipelineRunRequest>(Arena*);
template<> ::pipelines::tekton::v1alpha1::ListPipelineRunResponse* Arena::CreateMaybeMessage<::pipelines::tekton::v1alpha1::ListPipelineRunResponse>(Arena*);
template<> ::pipelines::tekton::v1alpha1::ListTektonTaskPipelineRequest* Arena::CreateMaybeMessage<::pipelines::tekton::v1alpha1::ListTektonTaskPipelineRequest>(Arena*);
template<> ::pipelines::tekton::v1alpha1::ListTektonTaskPipelineResponse* Arena::CreateMaybeMessage<::pipelines::tekton::v1alpha1::ListTektonTaskPipelineResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pipelines {
namespace tekton {
namespace v1alpha1 {

// ===================================================================

class CreateTektonPipelineRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pipelines.tekton.v1alpha1.CreateTektonPipelineRequest) */ {
 public:
  inline CreateTektonPipelineRequest() : CreateTektonPipelineRequest(nullptr) {}
  ~CreateTektonPipelineRequest() override;
  explicit constexpr CreateTektonPipelineRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTektonPipelineRequest(const CreateTektonPipelineRequest& from);
  CreateTektonPipelineRequest(CreateTektonPipelineRequest&& from) noexcept
    : CreateTektonPipelineRequest() {
    *this = ::std::move(from);
  }

  inline CreateTektonPipelineRequest& operator=(const CreateTektonPipelineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTektonPipelineRequest& operator=(CreateTektonPipelineRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTektonPipelineRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTektonPipelineRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTektonPipelineRequest*>(
               &_CreateTektonPipelineRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateTektonPipelineRequest& a, CreateTektonPipelineRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTektonPipelineRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTektonPipelineRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTektonPipelineRequest* New() const final {
    return new CreateTektonPipelineRequest();
  }

  CreateTektonPipelineRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTektonPipelineRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTektonPipelineRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateTektonPipelineRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTektonPipelineRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pipelines.tekton.v1alpha1.CreateTektonPipelineRequest";
  }
  protected:
  explicit CreateTektonPipelineRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 2,
    kTektonPipelineFieldNumber = 1,
  };
  // string user_id = 2 [json_name = "userId"];
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .pipelines.tekton.v1alpha1.Pipeline tekton_pipeline = 1 [json_name = "tektonPipeline"];
  bool has_tekton_pipeline() const;
  private:
  bool _internal_has_tekton_pipeline() const;
  public:
  void clear_tekton_pipeline();
  const ::pipelines::tekton::v1alpha1::Pipeline& tekton_pipeline() const;
  PROTOBUF_MUST_USE_RESULT ::pipelines::tekton::v1alpha1::Pipeline* release_tekton_pipeline();
  ::pipelines::tekton::v1alpha1::Pipeline* mutable_tekton_pipeline();
  void set_allocated_tekton_pipeline(::pipelines::tekton::v1alpha1::Pipeline* tekton_pipeline);
  private:
  const ::pipelines::tekton::v1alpha1::Pipeline& _internal_tekton_pipeline() const;
  ::pipelines::tekton::v1alpha1::Pipeline* _internal_mutable_tekton_pipeline();
  public:
  void unsafe_arena_set_allocated_tekton_pipeline(
      ::pipelines::tekton::v1alpha1::Pipeline* tekton_pipeline);
  ::pipelines::tekton::v1alpha1::Pipeline* unsafe_arena_release_tekton_pipeline();

  // @@protoc_insertion_point(class_scope:pipelines.tekton.v1alpha1.CreateTektonPipelineRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::pipelines::tekton::v1alpha1::Pipeline* tekton_pipeline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto;
};
// -------------------------------------------------------------------

class CreateTektonPipelineResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pipelines.tekton.v1alpha1.CreateTektonPipelineResponse) */ {
 public:
  inline CreateTektonPipelineResponse() : CreateTektonPipelineResponse(nullptr) {}
  ~CreateTektonPipelineResponse() override;
  explicit constexpr CreateTektonPipelineResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTektonPipelineResponse(const CreateTektonPipelineResponse& from);
  CreateTektonPipelineResponse(CreateTektonPipelineResponse&& from) noexcept
    : CreateTektonPipelineResponse() {
    *this = ::std::move(from);
  }

  inline CreateTektonPipelineResponse& operator=(const CreateTektonPipelineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTektonPipelineResponse& operator=(CreateTektonPipelineResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTektonPipelineResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTektonPipelineResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTektonPipelineResponse*>(
               &_CreateTektonPipelineResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateTektonPipelineResponse& a, CreateTektonPipelineResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTektonPipelineResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTektonPipelineResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTektonPipelineResponse* New() const final {
    return new CreateTektonPipelineResponse();
  }

  CreateTektonPipelineResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTektonPipelineResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTektonPipelineResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateTektonPipelineResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTektonPipelineResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pipelines.tekton.v1alpha1.CreateTektonPipelineResponse";
  }
  protected:
  explicit CreateTektonPipelineResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kTektonPipelineFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .pipelines.tekton.v1alpha1.Pipeline tekton_pipeline = 1 [json_name = "tektonPipeline"];
  bool has_tekton_pipeline() const;
  private:
  bool _internal_has_tekton_pipeline() const;
  public:
  void clear_tekton_pipeline();
  const ::pipelines::tekton::v1alpha1::Pipeline& tekton_pipeline() const;
  PROTOBUF_MUST_USE_RESULT ::pipelines::tekton::v1alpha1::Pipeline* release_tekton_pipeline();
  ::pipelines::tekton::v1alpha1::Pipeline* mutable_tekton_pipeline();
  void set_allocated_tekton_pipeline(::pipelines::tekton::v1alpha1::Pipeline* tekton_pipeline);
  private:
  const ::pipelines::tekton::v1alpha1::Pipeline& _internal_tekton_pipeline() const;
  ::pipelines::tekton::v1alpha1::Pipeline* _internal_mutable_tekton_pipeline();
  public:
  void unsafe_arena_set_allocated_tekton_pipeline(
      ::pipelines::tekton::v1alpha1::Pipeline* tekton_pipeline);
  ::pipelines::tekton::v1alpha1::Pipeline* unsafe_arena_release_tekton_pipeline();

  // @@protoc_insertion_point(class_scope:pipelines.tekton.v1alpha1.CreateTektonPipelineResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::pipelines::tekton::v1alpha1::Pipeline* tekton_pipeline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteTektonPipelineRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest) */ {
 public:
  inline DeleteTektonPipelineRequest() : DeleteTektonPipelineRequest(nullptr) {}
  ~DeleteTektonPipelineRequest() override;
  explicit constexpr DeleteTektonPipelineRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteTektonPipelineRequest(const DeleteTektonPipelineRequest& from);
  DeleteTektonPipelineRequest(DeleteTektonPipelineRequest&& from) noexcept
    : DeleteTektonPipelineRequest() {
    *this = ::std::move(from);
  }

  inline DeleteTektonPipelineRequest& operator=(const DeleteTektonPipelineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTektonPipelineRequest& operator=(DeleteTektonPipelineRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteTektonPipelineRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteTektonPipelineRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteTektonPipelineRequest*>(
               &_DeleteTektonPipelineRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DeleteTektonPipelineRequest& a, DeleteTektonPipelineRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteTektonPipelineRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTektonPipelineRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteTektonPipelineRequest* New() const final {
    return new DeleteTektonPipelineRequest();
  }

  DeleteTektonPipelineRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteTektonPipelineRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteTektonPipelineRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteTektonPipelineRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTektonPipelineRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest";
  }
  protected:
  explicit DeleteTektonPipelineRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuntimeNameFieldNumber = 1,
    kApplicationIdFieldNumber = 2,
    kEnvironmentIdFieldNumber = 3,
  };
  // string runtime_name = 1 [json_name = "runtimeName"];
  void clear_runtime_name();
  const std::string& runtime_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_runtime_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_runtime_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_runtime_name();
  void set_allocated_runtime_name(std::string* runtime_name);
  private:
  const std::string& _internal_runtime_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_runtime_name(const std::string& value);
  std::string* _internal_mutable_runtime_name();
  public:

  // string application_id = 2 [json_name = "applicationId"];
  void clear_application_id();
  const std::string& application_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_application_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_application_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_application_id();
  void set_allocated_application_id(std::string* application_id);
  private:
  const std::string& _internal_application_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_application_id(const std::string& value);
  std::string* _internal_mutable_application_id();
  public:

  // string environment_id = 3 [json_name = "environmentId"];
  void clear_environment_id();
  const std::string& environment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_environment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_environment_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_environment_id();
  void set_allocated_environment_id(std::string* environment_id);
  private:
  const std::string& _internal_environment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_environment_id(const std::string& value);
  std::string* _internal_mutable_environment_id();
  public:

  // @@protoc_insertion_point(class_scope:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr runtime_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr application_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr environment_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto;
};
// -------------------------------------------------------------------

class DeleteTektonPipelineResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pipelines.tekton.v1alpha1.DeleteTektonPipelineResponse) */ {
 public:
  inline DeleteTektonPipelineResponse() : DeleteTektonPipelineResponse(nullptr) {}
  ~DeleteTektonPipelineResponse() override;
  explicit constexpr DeleteTektonPipelineResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteTektonPipelineResponse(const DeleteTektonPipelineResponse& from);
  DeleteTektonPipelineResponse(DeleteTektonPipelineResponse&& from) noexcept
    : DeleteTektonPipelineResponse() {
    *this = ::std::move(from);
  }

  inline DeleteTektonPipelineResponse& operator=(const DeleteTektonPipelineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTektonPipelineResponse& operator=(DeleteTektonPipelineResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteTektonPipelineResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteTektonPipelineResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteTektonPipelineResponse*>(
               &_DeleteTektonPipelineResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeleteTektonPipelineResponse& a, DeleteTektonPipelineResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteTektonPipelineResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTektonPipelineResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteTektonPipelineResponse* New() const final {
    return new DeleteTektonPipelineResponse();
  }

  DeleteTektonPipelineResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteTektonPipelineResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteTektonPipelineResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteTektonPipelineResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTektonPipelineResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pipelines.tekton.v1alpha1.DeleteTektonPipelineResponse";
  }
  protected:
  explicit DeleteTektonPipelineResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:pipelines.tekton.v1alpha1.DeleteTektonPipelineResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListTektonTaskPipelineRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pipelines.tekton.v1alpha1.ListTektonTaskPipelineRequest) */ {
 public:
  inline ListTektonTaskPipelineRequest() : ListTektonTaskPipelineRequest(nullptr) {}
  ~ListTektonTaskPipelineRequest() override;
  explicit constexpr ListTektonTaskPipelineRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTektonTaskPipelineRequest(const ListTektonTaskPipelineRequest& from);
  ListTektonTaskPipelineRequest(ListTektonTaskPipelineRequest&& from) noexcept
    : ListTektonTaskPipelineRequest() {
    *this = ::std::move(from);
  }

  inline ListTektonTaskPipelineRequest& operator=(const ListTektonTaskPipelineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTektonTaskPipelineRequest& operator=(ListTektonTaskPipelineRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTektonTaskPipelineRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTektonTaskPipelineRequest* internal_default_instance() {
    return reinterpret_cast<const ListTektonTaskPipelineRequest*>(
               &_ListTektonTaskPipelineRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ListTektonTaskPipelineRequest& a, ListTektonTaskPipelineRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTektonTaskPipelineRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTektonTaskPipelineRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListTektonTaskPipelineRequest* New() const final {
    return new ListTektonTaskPipelineRequest();
  }

  ListTektonTaskPipelineRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListTektonTaskPipelineRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTektonTaskPipelineRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListTektonTaskPipelineRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTektonTaskPipelineRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pipelines.tekton.v1alpha1.ListTektonTaskPipelineRequest";
  }
  protected:
  explicit ListTektonTaskPipelineRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pipelines.tekton.v1alpha1.ListTektonTaskPipelineRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListTektonTaskPipelineResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pipelines.tekton.v1alpha1.ListTektonTaskPipelineResponse) */ {
 public:
  inline ListTektonTaskPipelineResponse() : ListTektonTaskPipelineResponse(nullptr) {}
  ~ListTektonTaskPipelineResponse() override;
  explicit constexpr ListTektonTaskPipelineResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTektonTaskPipelineResponse(const ListTektonTaskPipelineResponse& from);
  ListTektonTaskPipelineResponse(ListTektonTaskPipelineResponse&& from) noexcept
    : ListTektonTaskPipelineResponse() {
    *this = ::std::move(from);
  }

  inline ListTektonTaskPipelineResponse& operator=(const ListTektonTaskPipelineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTektonTaskPipelineResponse& operator=(ListTektonTaskPipelineResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTektonTaskPipelineResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTektonTaskPipelineResponse* internal_default_instance() {
    return reinterpret_cast<const ListTektonTaskPipelineResponse*>(
               &_ListTektonTaskPipelineResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListTektonTaskPipelineResponse& a, ListTektonTaskPipelineResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTektonTaskPipelineResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTektonTaskPipelineResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListTektonTaskPipelineResponse* New() const final {
    return new ListTektonTaskPipelineResponse();
  }

  ListTektonTaskPipelineResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListTektonTaskPipelineResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTektonTaskPipelineResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListTektonTaskPipelineResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTektonTaskPipelineResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pipelines.tekton.v1alpha1.ListTektonTaskPipelineResponse";
  }
  protected:
  explicit ListTektonTaskPipelineResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kTaskListFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .pipelines.tekton.v1alpha1.TektonTaskList task_list = 1 [json_name = "taskList"];
  bool has_task_list() const;
  private:
  bool _internal_has_task_list() const;
  public:
  void clear_task_list();
  const ::pipelines::tekton::v1alpha1::TektonTaskList& task_list() const;
  PROTOBUF_MUST_USE_RESULT ::pipelines::tekton::v1alpha1::TektonTaskList* release_task_list();
  ::pipelines::tekton::v1alpha1::TektonTaskList* mutable_task_list();
  void set_allocated_task_list(::pipelines::tekton::v1alpha1::TektonTaskList* task_list);
  private:
  const ::pipelines::tekton::v1alpha1::TektonTaskList& _internal_task_list() const;
  ::pipelines::tekton::v1alpha1::TektonTaskList* _internal_mutable_task_list();
  public:
  void unsafe_arena_set_allocated_task_list(
      ::pipelines::tekton::v1alpha1::TektonTaskList* task_list);
  ::pipelines::tekton::v1alpha1::TektonTaskList* unsafe_arena_release_task_list();

  // @@protoc_insertion_point(class_scope:pipelines.tekton.v1alpha1.ListTektonTaskPipelineResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::pipelines::tekton::v1alpha1::TektonTaskList* task_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPipelineRunRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pipelines.tekton.v1alpha1.GetPipelineRunRequest) */ {
 public:
  inline GetPipelineRunRequest() : GetPipelineRunRequest(nullptr) {}
  ~GetPipelineRunRequest() override;
  explicit constexpr GetPipelineRunRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPipelineRunRequest(const GetPipelineRunRequest& from);
  GetPipelineRunRequest(GetPipelineRunRequest&& from) noexcept
    : GetPipelineRunRequest() {
    *this = ::std::move(from);
  }

  inline GetPipelineRunRequest& operator=(const GetPipelineRunRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPipelineRunRequest& operator=(GetPipelineRunRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPipelineRunRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPipelineRunRequest* internal_default_instance() {
    return reinterpret_cast<const GetPipelineRunRequest*>(
               &_GetPipelineRunRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetPipelineRunRequest& a, GetPipelineRunRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPipelineRunRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPipelineRunRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPipelineRunRequest* New() const final {
    return new GetPipelineRunRequest();
  }

  GetPipelineRunRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPipelineRunRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPipelineRunRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPipelineRunRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPipelineRunRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pipelines.tekton.v1alpha1.GetPipelineRunRequest";
  }
  protected:
  explicit GetPipelineRunRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuntimeIdFieldNumber = 1,
  };
  // string runtime_id = 1 [json_name = "runtimeId"];
  void clear_runtime_id();
  const std::string& runtime_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_runtime_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_runtime_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_runtime_id();
  void set_allocated_runtime_id(std::string* runtime_id);
  private:
  const std::string& _internal_runtime_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_runtime_id(const std::string& value);
  std::string* _internal_mutable_runtime_id();
  public:

  // @@protoc_insertion_point(class_scope:pipelines.tekton.v1alpha1.GetPipelineRunRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr runtime_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetPipelineRunResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pipelines.tekton.v1alpha1.GetPipelineRunResponse) */ {
 public:
  inline GetPipelineRunResponse() : GetPipelineRunResponse(nullptr) {}
  ~GetPipelineRunResponse() override;
  explicit constexpr GetPipelineRunResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPipelineRunResponse(const GetPipelineRunResponse& from);
  GetPipelineRunResponse(GetPipelineRunResponse&& from) noexcept
    : GetPipelineRunResponse() {
    *this = ::std::move(from);
  }

  inline GetPipelineRunResponse& operator=(const GetPipelineRunResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPipelineRunResponse& operator=(GetPipelineRunResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPipelineRunResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPipelineRunResponse* internal_default_instance() {
    return reinterpret_cast<const GetPipelineRunResponse*>(
               &_GetPipelineRunResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetPipelineRunResponse& a, GetPipelineRunResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPipelineRunResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPipelineRunResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPipelineRunResponse* New() const final {
    return new GetPipelineRunResponse();
  }

  GetPipelineRunResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPipelineRunResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPipelineRunResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPipelineRunResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPipelineRunResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pipelines.tekton.v1alpha1.GetPipelineRunResponse";
  }
  protected:
  explicit GetPipelineRunResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPipelineRunFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .pipelines.tekton.v1alpha1.PipelineRun pipeline_run = 1 [json_name = "pipelineRun"];
  bool has_pipeline_run() const;
  private:
  bool _internal_has_pipeline_run() const;
  public:
  void clear_pipeline_run();
  const ::pipelines::tekton::v1alpha1::PipelineRun& pipeline_run() const;
  PROTOBUF_MUST_USE_RESULT ::pipelines::tekton::v1alpha1::PipelineRun* release_pipeline_run();
  ::pipelines::tekton::v1alpha1::PipelineRun* mutable_pipeline_run();
  void set_allocated_pipeline_run(::pipelines::tekton::v1alpha1::PipelineRun* pipeline_run);
  private:
  const ::pipelines::tekton::v1alpha1::PipelineRun& _internal_pipeline_run() const;
  ::pipelines::tekton::v1alpha1::PipelineRun* _internal_mutable_pipeline_run();
  public:
  void unsafe_arena_set_allocated_pipeline_run(
      ::pipelines::tekton::v1alpha1::PipelineRun* pipeline_run);
  ::pipelines::tekton::v1alpha1::PipelineRun* unsafe_arena_release_pipeline_run();

  // @@protoc_insertion_point(class_scope:pipelines.tekton.v1alpha1.GetPipelineRunResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::pipelines::tekton::v1alpha1::PipelineRun* pipeline_run_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListPipelineRunRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pipelines.tekton.v1alpha1.ListPipelineRunRequest) */ {
 public:
  inline ListPipelineRunRequest() : ListPipelineRunRequest(nullptr) {}
  ~ListPipelineRunRequest() override;
  explicit constexpr ListPipelineRunRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPipelineRunRequest(const ListPipelineRunRequest& from);
  ListPipelineRunRequest(ListPipelineRunRequest&& from) noexcept
    : ListPipelineRunRequest() {
    *this = ::std::move(from);
  }

  inline ListPipelineRunRequest& operator=(const ListPipelineRunRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPipelineRunRequest& operator=(ListPipelineRunRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPipelineRunRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPipelineRunRequest* internal_default_instance() {
    return reinterpret_cast<const ListPipelineRunRequest*>(
               &_ListPipelineRunRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ListPipelineRunRequest& a, ListPipelineRunRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPipelineRunRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPipelineRunRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPipelineRunRequest* New() const final {
    return new ListPipelineRunRequest();
  }

  ListPipelineRunRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPipelineRunRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPipelineRunRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPipelineRunRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPipelineRunRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pipelines.tekton.v1alpha1.ListPipelineRunRequest";
  }
  protected:
  explicit ListPipelineRunRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuntimeIdFieldNumber = 1,
  };
  // string runtime_id = 1 [json_name = "runtimeId"];
  void clear_runtime_id();
  const std::string& runtime_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_runtime_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_runtime_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_runtime_id();
  void set_allocated_runtime_id(std::string* runtime_id);
  private:
  const std::string& _internal_runtime_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_runtime_id(const std::string& value);
  std::string* _internal_mutable_runtime_id();
  public:

  // @@protoc_insertion_point(class_scope:pipelines.tekton.v1alpha1.ListPipelineRunRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr runtime_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ListPipelineRunResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pipelines.tekton.v1alpha1.ListPipelineRunResponse) */ {
 public:
  inline ListPipelineRunResponse() : ListPipelineRunResponse(nullptr) {}
  ~ListPipelineRunResponse() override;
  explicit constexpr ListPipelineRunResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPipelineRunResponse(const ListPipelineRunResponse& from);
  ListPipelineRunResponse(ListPipelineRunResponse&& from) noexcept
    : ListPipelineRunResponse() {
    *this = ::std::move(from);
  }

  inline ListPipelineRunResponse& operator=(const ListPipelineRunResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPipelineRunResponse& operator=(ListPipelineRunResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPipelineRunResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPipelineRunResponse* internal_default_instance() {
    return reinterpret_cast<const ListPipelineRunResponse*>(
               &_ListPipelineRunResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListPipelineRunResponse& a, ListPipelineRunResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPipelineRunResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPipelineRunResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPipelineRunResponse* New() const final {
    return new ListPipelineRunResponse();
  }

  ListPipelineRunResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPipelineRunResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPipelineRunResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPipelineRunResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPipelineRunResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pipelines.tekton.v1alpha1.ListPipelineRunResponse";
  }
  protected:
  explicit ListPipelineRunResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kPipelineRunListFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .pipelines.tekton.v1alpha1.PipelineRunList pipeline_run_list = 1 [json_name = "pipelineRunList"];
  bool has_pipeline_run_list() const;
  private:
  bool _internal_has_pipeline_run_list() const;
  public:
  void clear_pipeline_run_list();
  const ::pipelines::tekton::v1alpha1::PipelineRunList& pipeline_run_list() const;
  PROTOBUF_MUST_USE_RESULT ::pipelines::tekton::v1alpha1::PipelineRunList* release_pipeline_run_list();
  ::pipelines::tekton::v1alpha1::PipelineRunList* mutable_pipeline_run_list();
  void set_allocated_pipeline_run_list(::pipelines::tekton::v1alpha1::PipelineRunList* pipeline_run_list);
  private:
  const ::pipelines::tekton::v1alpha1::PipelineRunList& _internal_pipeline_run_list() const;
  ::pipelines::tekton::v1alpha1::PipelineRunList* _internal_mutable_pipeline_run_list();
  public:
  void unsafe_arena_set_allocated_pipeline_run_list(
      ::pipelines::tekton::v1alpha1::PipelineRunList* pipeline_run_list);
  ::pipelines::tekton::v1alpha1::PipelineRunList* unsafe_arena_release_pipeline_run_list();

  // @@protoc_insertion_point(class_scope:pipelines.tekton.v1alpha1.ListPipelineRunResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::pipelines::tekton::v1alpha1::PipelineRunList* pipeline_run_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetStatusRuntimeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pipelines.tekton.v1alpha1.GetStatusRuntimeRequest) */ {
 public:
  inline GetStatusRuntimeRequest() : GetStatusRuntimeRequest(nullptr) {}
  ~GetStatusRuntimeRequest() override;
  explicit constexpr GetStatusRuntimeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStatusRuntimeRequest(const GetStatusRuntimeRequest& from);
  GetStatusRuntimeRequest(GetStatusRuntimeRequest&& from) noexcept
    : GetStatusRuntimeRequest() {
    *this = ::std::move(from);
  }

  inline GetStatusRuntimeRequest& operator=(const GetStatusRuntimeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatusRuntimeRequest& operator=(GetStatusRuntimeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStatusRuntimeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStatusRuntimeRequest* internal_default_instance() {
    return reinterpret_cast<const GetStatusRuntimeRequest*>(
               &_GetStatusRuntimeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetStatusRuntimeRequest& a, GetStatusRuntimeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatusRuntimeRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatusRuntimeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetStatusRuntimeRequest* New() const final {
    return new GetStatusRuntimeRequest();
  }

  GetStatusRuntimeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetStatusRuntimeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStatusRuntimeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetStatusRuntimeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatusRuntimeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pipelines.tekton.v1alpha1.GetStatusRuntimeRequest";
  }
  protected:
  explicit GetStatusRuntimeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuntimeIdFieldNumber = 1,
  };
  // string runtime_id = 1 [json_name = "runtimeId"];
  void clear_runtime_id();
  const std::string& runtime_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_runtime_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_runtime_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_runtime_id();
  void set_allocated_runtime_id(std::string* runtime_id);
  private:
  const std::string& _internal_runtime_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_runtime_id(const std::string& value);
  std::string* _internal_mutable_runtime_id();
  public:

  // @@protoc_insertion_point(class_scope:pipelines.tekton.v1alpha1.GetStatusRuntimeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr runtime_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto;
};
// -------------------------------------------------------------------

class GetStatusRuntimeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pipelines.tekton.v1alpha1.GetStatusRuntimeResponse) */ {
 public:
  inline GetStatusRuntimeResponse() : GetStatusRuntimeResponse(nullptr) {}
  ~GetStatusRuntimeResponse() override;
  explicit constexpr GetStatusRuntimeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStatusRuntimeResponse(const GetStatusRuntimeResponse& from);
  GetStatusRuntimeResponse(GetStatusRuntimeResponse&& from) noexcept
    : GetStatusRuntimeResponse() {
    *this = ::std::move(from);
  }

  inline GetStatusRuntimeResponse& operator=(const GetStatusRuntimeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatusRuntimeResponse& operator=(GetStatusRuntimeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStatusRuntimeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStatusRuntimeResponse* internal_default_instance() {
    return reinterpret_cast<const GetStatusRuntimeResponse*>(
               &_GetStatusRuntimeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetStatusRuntimeResponse& a, GetStatusRuntimeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatusRuntimeResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatusRuntimeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetStatusRuntimeResponse* New() const final {
    return new GetStatusRuntimeResponse();
  }

  GetStatusRuntimeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetStatusRuntimeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStatusRuntimeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetStatusRuntimeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatusRuntimeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pipelines.tekton.v1alpha1.GetStatusRuntimeResponse";
  }
  protected:
  explicit GetStatusRuntimeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventFieldNumber = 1,
  };
  // .pipelines.tekton.v1alpha1.Event event = 1 [json_name = "event"];
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::pipelines::tekton::v1alpha1::Event& event() const;
  PROTOBUF_MUST_USE_RESULT ::pipelines::tekton::v1alpha1::Event* release_event();
  ::pipelines::tekton::v1alpha1::Event* mutable_event();
  void set_allocated_event(::pipelines::tekton::v1alpha1::Event* event);
  private:
  const ::pipelines::tekton::v1alpha1::Event& _internal_event() const;
  ::pipelines::tekton::v1alpha1::Event* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::pipelines::tekton::v1alpha1::Event* event);
  ::pipelines::tekton::v1alpha1::Event* unsafe_arena_release_event();

  // @@protoc_insertion_point(class_scope:pipelines.tekton.v1alpha1.GetStatusRuntimeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pipelines::tekton::v1alpha1::Event* event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ChangeStatusRuntimeAndApplicationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest) */ {
 public:
  inline ChangeStatusRuntimeAndApplicationRequest() : ChangeStatusRuntimeAndApplicationRequest(nullptr) {}
  ~ChangeStatusRuntimeAndApplicationRequest() override;
  explicit constexpr ChangeStatusRuntimeAndApplicationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeStatusRuntimeAndApplicationRequest(const ChangeStatusRuntimeAndApplicationRequest& from);
  ChangeStatusRuntimeAndApplicationRequest(ChangeStatusRuntimeAndApplicationRequest&& from) noexcept
    : ChangeStatusRuntimeAndApplicationRequest() {
    *this = ::std::move(from);
  }

  inline ChangeStatusRuntimeAndApplicationRequest& operator=(const ChangeStatusRuntimeAndApplicationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeStatusRuntimeAndApplicationRequest& operator=(ChangeStatusRuntimeAndApplicationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeStatusRuntimeAndApplicationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeStatusRuntimeAndApplicationRequest* internal_default_instance() {
    return reinterpret_cast<const ChangeStatusRuntimeAndApplicationRequest*>(
               &_ChangeStatusRuntimeAndApplicationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ChangeStatusRuntimeAndApplicationRequest& a, ChangeStatusRuntimeAndApplicationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeStatusRuntimeAndApplicationRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeStatusRuntimeAndApplicationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChangeStatusRuntimeAndApplicationRequest* New() const final {
    return new ChangeStatusRuntimeAndApplicationRequest();
  }

  ChangeStatusRuntimeAndApplicationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChangeStatusRuntimeAndApplicationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeStatusRuntimeAndApplicationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeStatusRuntimeAndApplicationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeStatusRuntimeAndApplicationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest";
  }
  protected:
  explicit ChangeStatusRuntimeAndApplicationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApplicationIdFieldNumber = 1,
    kProjectIdFieldNumber = 2,
    kOrganizationIdFieldNumber = 3,
    kRuntimeNameFieldNumber = 4,
    kNamespaceFieldNumber = 5,
    kRuntimeIdFieldNumber = 6,
    kStatusFieldNumber = 7,
  };
  // string application_id = 1 [json_name = "applicationId"];
  void clear_application_id();
  const std::string& application_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_application_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_application_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_application_id();
  void set_allocated_application_id(std::string* application_id);
  private:
  const std::string& _internal_application_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_application_id(const std::string& value);
  std::string* _internal_mutable_application_id();
  public:

  // string project_id = 2 [json_name = "projectId"];
  void clear_project_id();
  const std::string& project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_project_id();
  void set_allocated_project_id(std::string* project_id);
  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(const std::string& value);
  std::string* _internal_mutable_project_id();
  public:

  // string organization_id = 3 [json_name = "organizationId"];
  void clear_organization_id();
  const std::string& organization_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_organization_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_organization_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_organization_id();
  void set_allocated_organization_id(std::string* organization_id);
  private:
  const std::string& _internal_organization_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_organization_id(const std::string& value);
  std::string* _internal_mutable_organization_id();
  public:

  // string runtime_name = 4 [json_name = "runtimeName"];
  void clear_runtime_name();
  const std::string& runtime_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_runtime_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_runtime_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_runtime_name();
  void set_allocated_runtime_name(std::string* runtime_name);
  private:
  const std::string& _internal_runtime_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_runtime_name(const std::string& value);
  std::string* _internal_mutable_runtime_name();
  public:

  // string namespace = 5 [json_name = "namespace"];
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // string runtime_id = 6 [json_name = "runtimeId"];
  void clear_runtime_id();
  const std::string& runtime_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_runtime_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_runtime_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_runtime_id();
  void set_allocated_runtime_id(std::string* runtime_id);
  private:
  const std::string& _internal_runtime_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_runtime_id(const std::string& value);
  std::string* _internal_mutable_runtime_id();
  public:

  // string status = 7 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr application_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr organization_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr runtime_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr runtime_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto;
};
// -------------------------------------------------------------------

class ChangeStatusRuntimeAndApplicationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationResponse) */ {
 public:
  inline ChangeStatusRuntimeAndApplicationResponse() : ChangeStatusRuntimeAndApplicationResponse(nullptr) {}
  ~ChangeStatusRuntimeAndApplicationResponse() override;
  explicit constexpr ChangeStatusRuntimeAndApplicationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeStatusRuntimeAndApplicationResponse(const ChangeStatusRuntimeAndApplicationResponse& from);
  ChangeStatusRuntimeAndApplicationResponse(ChangeStatusRuntimeAndApplicationResponse&& from) noexcept
    : ChangeStatusRuntimeAndApplicationResponse() {
    *this = ::std::move(from);
  }

  inline ChangeStatusRuntimeAndApplicationResponse& operator=(const ChangeStatusRuntimeAndApplicationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeStatusRuntimeAndApplicationResponse& operator=(ChangeStatusRuntimeAndApplicationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeStatusRuntimeAndApplicationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeStatusRuntimeAndApplicationResponse* internal_default_instance() {
    return reinterpret_cast<const ChangeStatusRuntimeAndApplicationResponse*>(
               &_ChangeStatusRuntimeAndApplicationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ChangeStatusRuntimeAndApplicationResponse& a, ChangeStatusRuntimeAndApplicationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeStatusRuntimeAndApplicationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeStatusRuntimeAndApplicationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChangeStatusRuntimeAndApplicationResponse* New() const final {
    return new ChangeStatusRuntimeAndApplicationResponse();
  }

  ChangeStatusRuntimeAndApplicationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChangeStatusRuntimeAndApplicationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeStatusRuntimeAndApplicationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeStatusRuntimeAndApplicationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeStatusRuntimeAndApplicationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationResponse";
  }
  protected:
  explicit ChangeStatusRuntimeAndApplicationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string msg = 1 [json_name = "msg"];
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_MUST_USE_RESULT std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateTektonPipelineRequest

// .pipelines.tekton.v1alpha1.Pipeline tekton_pipeline = 1 [json_name = "tektonPipeline"];
inline bool CreateTektonPipelineRequest::_internal_has_tekton_pipeline() const {
  return this != internal_default_instance() && tekton_pipeline_ != nullptr;
}
inline bool CreateTektonPipelineRequest::has_tekton_pipeline() const {
  return _internal_has_tekton_pipeline();
}
inline const ::pipelines::tekton::v1alpha1::Pipeline& CreateTektonPipelineRequest::_internal_tekton_pipeline() const {
  const ::pipelines::tekton::v1alpha1::Pipeline* p = tekton_pipeline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pipelines::tekton::v1alpha1::Pipeline&>(
      ::pipelines::tekton::v1alpha1::_Pipeline_default_instance_);
}
inline const ::pipelines::tekton::v1alpha1::Pipeline& CreateTektonPipelineRequest::tekton_pipeline() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.CreateTektonPipelineRequest.tekton_pipeline)
  return _internal_tekton_pipeline();
}
inline void CreateTektonPipelineRequest::unsafe_arena_set_allocated_tekton_pipeline(
    ::pipelines::tekton::v1alpha1::Pipeline* tekton_pipeline) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tekton_pipeline_);
  }
  tekton_pipeline_ = tekton_pipeline;
  if (tekton_pipeline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pipelines.tekton.v1alpha1.CreateTektonPipelineRequest.tekton_pipeline)
}
inline ::pipelines::tekton::v1alpha1::Pipeline* CreateTektonPipelineRequest::release_tekton_pipeline() {
  
  ::pipelines::tekton::v1alpha1::Pipeline* temp = tekton_pipeline_;
  tekton_pipeline_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pipelines::tekton::v1alpha1::Pipeline* CreateTektonPipelineRequest::unsafe_arena_release_tekton_pipeline() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.CreateTektonPipelineRequest.tekton_pipeline)
  
  ::pipelines::tekton::v1alpha1::Pipeline* temp = tekton_pipeline_;
  tekton_pipeline_ = nullptr;
  return temp;
}
inline ::pipelines::tekton::v1alpha1::Pipeline* CreateTektonPipelineRequest::_internal_mutable_tekton_pipeline() {
  
  if (tekton_pipeline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pipelines::tekton::v1alpha1::Pipeline>(GetArenaForAllocation());
    tekton_pipeline_ = p;
  }
  return tekton_pipeline_;
}
inline ::pipelines::tekton::v1alpha1::Pipeline* CreateTektonPipelineRequest::mutable_tekton_pipeline() {
  ::pipelines::tekton::v1alpha1::Pipeline* _msg = _internal_mutable_tekton_pipeline();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.CreateTektonPipelineRequest.tekton_pipeline)
  return _msg;
}
inline void CreateTektonPipelineRequest::set_allocated_tekton_pipeline(::pipelines::tekton::v1alpha1::Pipeline* tekton_pipeline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tekton_pipeline_);
  }
  if (tekton_pipeline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tekton_pipeline));
    if (message_arena != submessage_arena) {
      tekton_pipeline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tekton_pipeline, submessage_arena);
    }
    
  } else {
    
  }
  tekton_pipeline_ = tekton_pipeline;
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.CreateTektonPipelineRequest.tekton_pipeline)
}

// string user_id = 2 [json_name = "userId"];
inline void CreateTektonPipelineRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& CreateTektonPipelineRequest::user_id() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.CreateTektonPipelineRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTektonPipelineRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.CreateTektonPipelineRequest.user_id)
}
inline std::string* CreateTektonPipelineRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.CreateTektonPipelineRequest.user_id)
  return _s;
}
inline const std::string& CreateTektonPipelineRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void CreateTektonPipelineRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateTektonPipelineRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateTektonPipelineRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.CreateTektonPipelineRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateTektonPipelineRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.CreateTektonPipelineRequest.user_id)
}

// -------------------------------------------------------------------

// CreateTektonPipelineResponse

// .pipelines.tekton.v1alpha1.Pipeline tekton_pipeline = 1 [json_name = "tektonPipeline"];
inline bool CreateTektonPipelineResponse::_internal_has_tekton_pipeline() const {
  return this != internal_default_instance() && tekton_pipeline_ != nullptr;
}
inline bool CreateTektonPipelineResponse::has_tekton_pipeline() const {
  return _internal_has_tekton_pipeline();
}
inline const ::pipelines::tekton::v1alpha1::Pipeline& CreateTektonPipelineResponse::_internal_tekton_pipeline() const {
  const ::pipelines::tekton::v1alpha1::Pipeline* p = tekton_pipeline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pipelines::tekton::v1alpha1::Pipeline&>(
      ::pipelines::tekton::v1alpha1::_Pipeline_default_instance_);
}
inline const ::pipelines::tekton::v1alpha1::Pipeline& CreateTektonPipelineResponse::tekton_pipeline() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.CreateTektonPipelineResponse.tekton_pipeline)
  return _internal_tekton_pipeline();
}
inline void CreateTektonPipelineResponse::unsafe_arena_set_allocated_tekton_pipeline(
    ::pipelines::tekton::v1alpha1::Pipeline* tekton_pipeline) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tekton_pipeline_);
  }
  tekton_pipeline_ = tekton_pipeline;
  if (tekton_pipeline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pipelines.tekton.v1alpha1.CreateTektonPipelineResponse.tekton_pipeline)
}
inline ::pipelines::tekton::v1alpha1::Pipeline* CreateTektonPipelineResponse::release_tekton_pipeline() {
  
  ::pipelines::tekton::v1alpha1::Pipeline* temp = tekton_pipeline_;
  tekton_pipeline_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pipelines::tekton::v1alpha1::Pipeline* CreateTektonPipelineResponse::unsafe_arena_release_tekton_pipeline() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.CreateTektonPipelineResponse.tekton_pipeline)
  
  ::pipelines::tekton::v1alpha1::Pipeline* temp = tekton_pipeline_;
  tekton_pipeline_ = nullptr;
  return temp;
}
inline ::pipelines::tekton::v1alpha1::Pipeline* CreateTektonPipelineResponse::_internal_mutable_tekton_pipeline() {
  
  if (tekton_pipeline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pipelines::tekton::v1alpha1::Pipeline>(GetArenaForAllocation());
    tekton_pipeline_ = p;
  }
  return tekton_pipeline_;
}
inline ::pipelines::tekton::v1alpha1::Pipeline* CreateTektonPipelineResponse::mutable_tekton_pipeline() {
  ::pipelines::tekton::v1alpha1::Pipeline* _msg = _internal_mutable_tekton_pipeline();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.CreateTektonPipelineResponse.tekton_pipeline)
  return _msg;
}
inline void CreateTektonPipelineResponse::set_allocated_tekton_pipeline(::pipelines::tekton::v1alpha1::Pipeline* tekton_pipeline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tekton_pipeline_);
  }
  if (tekton_pipeline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tekton_pipeline));
    if (message_arena != submessage_arena) {
      tekton_pipeline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tekton_pipeline, submessage_arena);
    }
    
  } else {
    
  }
  tekton_pipeline_ = tekton_pipeline;
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.CreateTektonPipelineResponse.tekton_pipeline)
}

// string status = 2 [json_name = "status"];
inline void CreateTektonPipelineResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CreateTektonPipelineResponse::status() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.CreateTektonPipelineResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTektonPipelineResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.CreateTektonPipelineResponse.status)
}
inline std::string* CreateTektonPipelineResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.CreateTektonPipelineResponse.status)
  return _s;
}
inline const std::string& CreateTektonPipelineResponse::_internal_status() const {
  return status_.Get();
}
inline void CreateTektonPipelineResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateTektonPipelineResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateTektonPipelineResponse::release_status() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.CreateTektonPipelineResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateTektonPipelineResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.CreateTektonPipelineResponse.status)
}

// -------------------------------------------------------------------

// DeleteTektonPipelineRequest

// string runtime_name = 1 [json_name = "runtimeName"];
inline void DeleteTektonPipelineRequest::clear_runtime_name() {
  runtime_name_.ClearToEmpty();
}
inline const std::string& DeleteTektonPipelineRequest::runtime_name() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest.runtime_name)
  return _internal_runtime_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteTektonPipelineRequest::set_runtime_name(ArgT0&& arg0, ArgT... args) {
 
 runtime_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest.runtime_name)
}
inline std::string* DeleteTektonPipelineRequest::mutable_runtime_name() {
  std::string* _s = _internal_mutable_runtime_name();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest.runtime_name)
  return _s;
}
inline const std::string& DeleteTektonPipelineRequest::_internal_runtime_name() const {
  return runtime_name_.Get();
}
inline void DeleteTektonPipelineRequest::_internal_set_runtime_name(const std::string& value) {
  
  runtime_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteTektonPipelineRequest::_internal_mutable_runtime_name() {
  
  return runtime_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteTektonPipelineRequest::release_runtime_name() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest.runtime_name)
  return runtime_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteTektonPipelineRequest::set_allocated_runtime_name(std::string* runtime_name) {
  if (runtime_name != nullptr) {
    
  } else {
    
  }
  runtime_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), runtime_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest.runtime_name)
}

// string application_id = 2 [json_name = "applicationId"];
inline void DeleteTektonPipelineRequest::clear_application_id() {
  application_id_.ClearToEmpty();
}
inline const std::string& DeleteTektonPipelineRequest::application_id() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest.application_id)
  return _internal_application_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteTektonPipelineRequest::set_application_id(ArgT0&& arg0, ArgT... args) {
 
 application_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest.application_id)
}
inline std::string* DeleteTektonPipelineRequest::mutable_application_id() {
  std::string* _s = _internal_mutable_application_id();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest.application_id)
  return _s;
}
inline const std::string& DeleteTektonPipelineRequest::_internal_application_id() const {
  return application_id_.Get();
}
inline void DeleteTektonPipelineRequest::_internal_set_application_id(const std::string& value) {
  
  application_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteTektonPipelineRequest::_internal_mutable_application_id() {
  
  return application_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteTektonPipelineRequest::release_application_id() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest.application_id)
  return application_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteTektonPipelineRequest::set_allocated_application_id(std::string* application_id) {
  if (application_id != nullptr) {
    
  } else {
    
  }
  application_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), application_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest.application_id)
}

// string environment_id = 3 [json_name = "environmentId"];
inline void DeleteTektonPipelineRequest::clear_environment_id() {
  environment_id_.ClearToEmpty();
}
inline const std::string& DeleteTektonPipelineRequest::environment_id() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest.environment_id)
  return _internal_environment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteTektonPipelineRequest::set_environment_id(ArgT0&& arg0, ArgT... args) {
 
 environment_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest.environment_id)
}
inline std::string* DeleteTektonPipelineRequest::mutable_environment_id() {
  std::string* _s = _internal_mutable_environment_id();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest.environment_id)
  return _s;
}
inline const std::string& DeleteTektonPipelineRequest::_internal_environment_id() const {
  return environment_id_.Get();
}
inline void DeleteTektonPipelineRequest::_internal_set_environment_id(const std::string& value) {
  
  environment_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteTektonPipelineRequest::_internal_mutable_environment_id() {
  
  return environment_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteTektonPipelineRequest::release_environment_id() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest.environment_id)
  return environment_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteTektonPipelineRequest::set_allocated_environment_id(std::string* environment_id) {
  if (environment_id != nullptr) {
    
  } else {
    
  }
  environment_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), environment_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.DeleteTektonPipelineRequest.environment_id)
}

// -------------------------------------------------------------------

// DeleteTektonPipelineResponse

// string status = 1 [json_name = "status"];
inline void DeleteTektonPipelineResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& DeleteTektonPipelineResponse::status() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.DeleteTektonPipelineResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteTektonPipelineResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.DeleteTektonPipelineResponse.status)
}
inline std::string* DeleteTektonPipelineResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.DeleteTektonPipelineResponse.status)
  return _s;
}
inline const std::string& DeleteTektonPipelineResponse::_internal_status() const {
  return status_.Get();
}
inline void DeleteTektonPipelineResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteTektonPipelineResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteTektonPipelineResponse::release_status() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.DeleteTektonPipelineResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteTektonPipelineResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.DeleteTektonPipelineResponse.status)
}

// -------------------------------------------------------------------

// ListTektonTaskPipelineRequest

// -------------------------------------------------------------------

// ListTektonTaskPipelineResponse

// .pipelines.tekton.v1alpha1.TektonTaskList task_list = 1 [json_name = "taskList"];
inline bool ListTektonTaskPipelineResponse::_internal_has_task_list() const {
  return this != internal_default_instance() && task_list_ != nullptr;
}
inline bool ListTektonTaskPipelineResponse::has_task_list() const {
  return _internal_has_task_list();
}
inline const ::pipelines::tekton::v1alpha1::TektonTaskList& ListTektonTaskPipelineResponse::_internal_task_list() const {
  const ::pipelines::tekton::v1alpha1::TektonTaskList* p = task_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::pipelines::tekton::v1alpha1::TektonTaskList&>(
      ::pipelines::tekton::v1alpha1::_TektonTaskList_default_instance_);
}
inline const ::pipelines::tekton::v1alpha1::TektonTaskList& ListTektonTaskPipelineResponse::task_list() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.ListTektonTaskPipelineResponse.task_list)
  return _internal_task_list();
}
inline void ListTektonTaskPipelineResponse::unsafe_arena_set_allocated_task_list(
    ::pipelines::tekton::v1alpha1::TektonTaskList* task_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_list_);
  }
  task_list_ = task_list;
  if (task_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pipelines.tekton.v1alpha1.ListTektonTaskPipelineResponse.task_list)
}
inline ::pipelines::tekton::v1alpha1::TektonTaskList* ListTektonTaskPipelineResponse::release_task_list() {
  
  ::pipelines::tekton::v1alpha1::TektonTaskList* temp = task_list_;
  task_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pipelines::tekton::v1alpha1::TektonTaskList* ListTektonTaskPipelineResponse::unsafe_arena_release_task_list() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.ListTektonTaskPipelineResponse.task_list)
  
  ::pipelines::tekton::v1alpha1::TektonTaskList* temp = task_list_;
  task_list_ = nullptr;
  return temp;
}
inline ::pipelines::tekton::v1alpha1::TektonTaskList* ListTektonTaskPipelineResponse::_internal_mutable_task_list() {
  
  if (task_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::pipelines::tekton::v1alpha1::TektonTaskList>(GetArenaForAllocation());
    task_list_ = p;
  }
  return task_list_;
}
inline ::pipelines::tekton::v1alpha1::TektonTaskList* ListTektonTaskPipelineResponse::mutable_task_list() {
  ::pipelines::tekton::v1alpha1::TektonTaskList* _msg = _internal_mutable_task_list();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.ListTektonTaskPipelineResponse.task_list)
  return _msg;
}
inline void ListTektonTaskPipelineResponse::set_allocated_task_list(::pipelines::tekton::v1alpha1::TektonTaskList* task_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_list_);
  }
  if (task_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_list));
    if (message_arena != submessage_arena) {
      task_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_list, submessage_arena);
    }
    
  } else {
    
  }
  task_list_ = task_list;
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.ListTektonTaskPipelineResponse.task_list)
}

// string status = 2 [json_name = "status"];
inline void ListTektonTaskPipelineResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& ListTektonTaskPipelineResponse::status() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.ListTektonTaskPipelineResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListTektonTaskPipelineResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.ListTektonTaskPipelineResponse.status)
}
inline std::string* ListTektonTaskPipelineResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.ListTektonTaskPipelineResponse.status)
  return _s;
}
inline const std::string& ListTektonTaskPipelineResponse::_internal_status() const {
  return status_.Get();
}
inline void ListTektonTaskPipelineResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListTektonTaskPipelineResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListTektonTaskPipelineResponse::release_status() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.ListTektonTaskPipelineResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListTektonTaskPipelineResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.ListTektonTaskPipelineResponse.status)
}

// -------------------------------------------------------------------

// GetPipelineRunRequest

// string runtime_id = 1 [json_name = "runtimeId"];
inline void GetPipelineRunRequest::clear_runtime_id() {
  runtime_id_.ClearToEmpty();
}
inline const std::string& GetPipelineRunRequest::runtime_id() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.GetPipelineRunRequest.runtime_id)
  return _internal_runtime_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPipelineRunRequest::set_runtime_id(ArgT0&& arg0, ArgT... args) {
 
 runtime_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.GetPipelineRunRequest.runtime_id)
}
inline std::string* GetPipelineRunRequest::mutable_runtime_id() {
  std::string* _s = _internal_mutable_runtime_id();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.GetPipelineRunRequest.runtime_id)
  return _s;
}
inline const std::string& GetPipelineRunRequest::_internal_runtime_id() const {
  return runtime_id_.Get();
}
inline void GetPipelineRunRequest::_internal_set_runtime_id(const std::string& value) {
  
  runtime_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPipelineRunRequest::_internal_mutable_runtime_id() {
  
  return runtime_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPipelineRunRequest::release_runtime_id() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.GetPipelineRunRequest.runtime_id)
  return runtime_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPipelineRunRequest::set_allocated_runtime_id(std::string* runtime_id) {
  if (runtime_id != nullptr) {
    
  } else {
    
  }
  runtime_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), runtime_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.GetPipelineRunRequest.runtime_id)
}

// -------------------------------------------------------------------

// GetPipelineRunResponse

// .pipelines.tekton.v1alpha1.PipelineRun pipeline_run = 1 [json_name = "pipelineRun"];
inline bool GetPipelineRunResponse::_internal_has_pipeline_run() const {
  return this != internal_default_instance() && pipeline_run_ != nullptr;
}
inline bool GetPipelineRunResponse::has_pipeline_run() const {
  return _internal_has_pipeline_run();
}
inline const ::pipelines::tekton::v1alpha1::PipelineRun& GetPipelineRunResponse::_internal_pipeline_run() const {
  const ::pipelines::tekton::v1alpha1::PipelineRun* p = pipeline_run_;
  return p != nullptr ? *p : reinterpret_cast<const ::pipelines::tekton::v1alpha1::PipelineRun&>(
      ::pipelines::tekton::v1alpha1::_PipelineRun_default_instance_);
}
inline const ::pipelines::tekton::v1alpha1::PipelineRun& GetPipelineRunResponse::pipeline_run() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.GetPipelineRunResponse.pipeline_run)
  return _internal_pipeline_run();
}
inline void GetPipelineRunResponse::unsafe_arena_set_allocated_pipeline_run(
    ::pipelines::tekton::v1alpha1::PipelineRun* pipeline_run) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pipeline_run_);
  }
  pipeline_run_ = pipeline_run;
  if (pipeline_run) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pipelines.tekton.v1alpha1.GetPipelineRunResponse.pipeline_run)
}
inline ::pipelines::tekton::v1alpha1::PipelineRun* GetPipelineRunResponse::release_pipeline_run() {
  
  ::pipelines::tekton::v1alpha1::PipelineRun* temp = pipeline_run_;
  pipeline_run_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pipelines::tekton::v1alpha1::PipelineRun* GetPipelineRunResponse::unsafe_arena_release_pipeline_run() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.GetPipelineRunResponse.pipeline_run)
  
  ::pipelines::tekton::v1alpha1::PipelineRun* temp = pipeline_run_;
  pipeline_run_ = nullptr;
  return temp;
}
inline ::pipelines::tekton::v1alpha1::PipelineRun* GetPipelineRunResponse::_internal_mutable_pipeline_run() {
  
  if (pipeline_run_ == nullptr) {
    auto* p = CreateMaybeMessage<::pipelines::tekton::v1alpha1::PipelineRun>(GetArenaForAllocation());
    pipeline_run_ = p;
  }
  return pipeline_run_;
}
inline ::pipelines::tekton::v1alpha1::PipelineRun* GetPipelineRunResponse::mutable_pipeline_run() {
  ::pipelines::tekton::v1alpha1::PipelineRun* _msg = _internal_mutable_pipeline_run();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.GetPipelineRunResponse.pipeline_run)
  return _msg;
}
inline void GetPipelineRunResponse::set_allocated_pipeline_run(::pipelines::tekton::v1alpha1::PipelineRun* pipeline_run) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pipeline_run_);
  }
  if (pipeline_run) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pipeline_run));
    if (message_arena != submessage_arena) {
      pipeline_run = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pipeline_run, submessage_arena);
    }
    
  } else {
    
  }
  pipeline_run_ = pipeline_run;
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.GetPipelineRunResponse.pipeline_run)
}

// string status = 2 [json_name = "status"];
inline void GetPipelineRunResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GetPipelineRunResponse::status() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.GetPipelineRunResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPipelineRunResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.GetPipelineRunResponse.status)
}
inline std::string* GetPipelineRunResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.GetPipelineRunResponse.status)
  return _s;
}
inline const std::string& GetPipelineRunResponse::_internal_status() const {
  return status_.Get();
}
inline void GetPipelineRunResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPipelineRunResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPipelineRunResponse::release_status() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.GetPipelineRunResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPipelineRunResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.GetPipelineRunResponse.status)
}

// -------------------------------------------------------------------

// ListPipelineRunRequest

// string runtime_id = 1 [json_name = "runtimeId"];
inline void ListPipelineRunRequest::clear_runtime_id() {
  runtime_id_.ClearToEmpty();
}
inline const std::string& ListPipelineRunRequest::runtime_id() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.ListPipelineRunRequest.runtime_id)
  return _internal_runtime_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPipelineRunRequest::set_runtime_id(ArgT0&& arg0, ArgT... args) {
 
 runtime_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.ListPipelineRunRequest.runtime_id)
}
inline std::string* ListPipelineRunRequest::mutable_runtime_id() {
  std::string* _s = _internal_mutable_runtime_id();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.ListPipelineRunRequest.runtime_id)
  return _s;
}
inline const std::string& ListPipelineRunRequest::_internal_runtime_id() const {
  return runtime_id_.Get();
}
inline void ListPipelineRunRequest::_internal_set_runtime_id(const std::string& value) {
  
  runtime_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPipelineRunRequest::_internal_mutable_runtime_id() {
  
  return runtime_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPipelineRunRequest::release_runtime_id() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.ListPipelineRunRequest.runtime_id)
  return runtime_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPipelineRunRequest::set_allocated_runtime_id(std::string* runtime_id) {
  if (runtime_id != nullptr) {
    
  } else {
    
  }
  runtime_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), runtime_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.ListPipelineRunRequest.runtime_id)
}

// -------------------------------------------------------------------

// ListPipelineRunResponse

// .pipelines.tekton.v1alpha1.PipelineRunList pipeline_run_list = 1 [json_name = "pipelineRunList"];
inline bool ListPipelineRunResponse::_internal_has_pipeline_run_list() const {
  return this != internal_default_instance() && pipeline_run_list_ != nullptr;
}
inline bool ListPipelineRunResponse::has_pipeline_run_list() const {
  return _internal_has_pipeline_run_list();
}
inline const ::pipelines::tekton::v1alpha1::PipelineRunList& ListPipelineRunResponse::_internal_pipeline_run_list() const {
  const ::pipelines::tekton::v1alpha1::PipelineRunList* p = pipeline_run_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::pipelines::tekton::v1alpha1::PipelineRunList&>(
      ::pipelines::tekton::v1alpha1::_PipelineRunList_default_instance_);
}
inline const ::pipelines::tekton::v1alpha1::PipelineRunList& ListPipelineRunResponse::pipeline_run_list() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.ListPipelineRunResponse.pipeline_run_list)
  return _internal_pipeline_run_list();
}
inline void ListPipelineRunResponse::unsafe_arena_set_allocated_pipeline_run_list(
    ::pipelines::tekton::v1alpha1::PipelineRunList* pipeline_run_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pipeline_run_list_);
  }
  pipeline_run_list_ = pipeline_run_list;
  if (pipeline_run_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pipelines.tekton.v1alpha1.ListPipelineRunResponse.pipeline_run_list)
}
inline ::pipelines::tekton::v1alpha1::PipelineRunList* ListPipelineRunResponse::release_pipeline_run_list() {
  
  ::pipelines::tekton::v1alpha1::PipelineRunList* temp = pipeline_run_list_;
  pipeline_run_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pipelines::tekton::v1alpha1::PipelineRunList* ListPipelineRunResponse::unsafe_arena_release_pipeline_run_list() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.ListPipelineRunResponse.pipeline_run_list)
  
  ::pipelines::tekton::v1alpha1::PipelineRunList* temp = pipeline_run_list_;
  pipeline_run_list_ = nullptr;
  return temp;
}
inline ::pipelines::tekton::v1alpha1::PipelineRunList* ListPipelineRunResponse::_internal_mutable_pipeline_run_list() {
  
  if (pipeline_run_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::pipelines::tekton::v1alpha1::PipelineRunList>(GetArenaForAllocation());
    pipeline_run_list_ = p;
  }
  return pipeline_run_list_;
}
inline ::pipelines::tekton::v1alpha1::PipelineRunList* ListPipelineRunResponse::mutable_pipeline_run_list() {
  ::pipelines::tekton::v1alpha1::PipelineRunList* _msg = _internal_mutable_pipeline_run_list();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.ListPipelineRunResponse.pipeline_run_list)
  return _msg;
}
inline void ListPipelineRunResponse::set_allocated_pipeline_run_list(::pipelines::tekton::v1alpha1::PipelineRunList* pipeline_run_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pipeline_run_list_);
  }
  if (pipeline_run_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pipeline_run_list));
    if (message_arena != submessage_arena) {
      pipeline_run_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pipeline_run_list, submessage_arena);
    }
    
  } else {
    
  }
  pipeline_run_list_ = pipeline_run_list;
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.ListPipelineRunResponse.pipeline_run_list)
}

// string status = 2 [json_name = "status"];
inline void ListPipelineRunResponse::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& ListPipelineRunResponse::status() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.ListPipelineRunResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPipelineRunResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.ListPipelineRunResponse.status)
}
inline std::string* ListPipelineRunResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.ListPipelineRunResponse.status)
  return _s;
}
inline const std::string& ListPipelineRunResponse::_internal_status() const {
  return status_.Get();
}
inline void ListPipelineRunResponse::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPipelineRunResponse::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPipelineRunResponse::release_status() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.ListPipelineRunResponse.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPipelineRunResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.ListPipelineRunResponse.status)
}

// -------------------------------------------------------------------

// GetStatusRuntimeRequest

// string runtime_id = 1 [json_name = "runtimeId"];
inline void GetStatusRuntimeRequest::clear_runtime_id() {
  runtime_id_.ClearToEmpty();
}
inline const std::string& GetStatusRuntimeRequest::runtime_id() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.GetStatusRuntimeRequest.runtime_id)
  return _internal_runtime_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStatusRuntimeRequest::set_runtime_id(ArgT0&& arg0, ArgT... args) {
 
 runtime_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.GetStatusRuntimeRequest.runtime_id)
}
inline std::string* GetStatusRuntimeRequest::mutable_runtime_id() {
  std::string* _s = _internal_mutable_runtime_id();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.GetStatusRuntimeRequest.runtime_id)
  return _s;
}
inline const std::string& GetStatusRuntimeRequest::_internal_runtime_id() const {
  return runtime_id_.Get();
}
inline void GetStatusRuntimeRequest::_internal_set_runtime_id(const std::string& value) {
  
  runtime_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetStatusRuntimeRequest::_internal_mutable_runtime_id() {
  
  return runtime_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetStatusRuntimeRequest::release_runtime_id() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.GetStatusRuntimeRequest.runtime_id)
  return runtime_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetStatusRuntimeRequest::set_allocated_runtime_id(std::string* runtime_id) {
  if (runtime_id != nullptr) {
    
  } else {
    
  }
  runtime_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), runtime_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.GetStatusRuntimeRequest.runtime_id)
}

// -------------------------------------------------------------------

// GetStatusRuntimeResponse

// .pipelines.tekton.v1alpha1.Event event = 1 [json_name = "event"];
inline bool GetStatusRuntimeResponse::_internal_has_event() const {
  return this != internal_default_instance() && event_ != nullptr;
}
inline bool GetStatusRuntimeResponse::has_event() const {
  return _internal_has_event();
}
inline const ::pipelines::tekton::v1alpha1::Event& GetStatusRuntimeResponse::_internal_event() const {
  const ::pipelines::tekton::v1alpha1::Event* p = event_;
  return p != nullptr ? *p : reinterpret_cast<const ::pipelines::tekton::v1alpha1::Event&>(
      ::pipelines::tekton::v1alpha1::_Event_default_instance_);
}
inline const ::pipelines::tekton::v1alpha1::Event& GetStatusRuntimeResponse::event() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.GetStatusRuntimeResponse.event)
  return _internal_event();
}
inline void GetStatusRuntimeResponse::unsafe_arena_set_allocated_event(
    ::pipelines::tekton::v1alpha1::Event* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pipelines.tekton.v1alpha1.GetStatusRuntimeResponse.event)
}
inline ::pipelines::tekton::v1alpha1::Event* GetStatusRuntimeResponse::release_event() {
  
  ::pipelines::tekton::v1alpha1::Event* temp = event_;
  event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pipelines::tekton::v1alpha1::Event* GetStatusRuntimeResponse::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.GetStatusRuntimeResponse.event)
  
  ::pipelines::tekton::v1alpha1::Event* temp = event_;
  event_ = nullptr;
  return temp;
}
inline ::pipelines::tekton::v1alpha1::Event* GetStatusRuntimeResponse::_internal_mutable_event() {
  
  if (event_ == nullptr) {
    auto* p = CreateMaybeMessage<::pipelines::tekton::v1alpha1::Event>(GetArenaForAllocation());
    event_ = p;
  }
  return event_;
}
inline ::pipelines::tekton::v1alpha1::Event* GetStatusRuntimeResponse::mutable_event() {
  ::pipelines::tekton::v1alpha1::Event* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.GetStatusRuntimeResponse.event)
  return _msg;
}
inline void GetStatusRuntimeResponse::set_allocated_event(::pipelines::tekton::v1alpha1::Event* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event));
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.GetStatusRuntimeResponse.event)
}

// -------------------------------------------------------------------

// ChangeStatusRuntimeAndApplicationRequest

// string application_id = 1 [json_name = "applicationId"];
inline void ChangeStatusRuntimeAndApplicationRequest::clear_application_id() {
  application_id_.ClearToEmpty();
}
inline const std::string& ChangeStatusRuntimeAndApplicationRequest::application_id() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.application_id)
  return _internal_application_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeStatusRuntimeAndApplicationRequest::set_application_id(ArgT0&& arg0, ArgT... args) {
 
 application_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.application_id)
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::mutable_application_id() {
  std::string* _s = _internal_mutable_application_id();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.application_id)
  return _s;
}
inline const std::string& ChangeStatusRuntimeAndApplicationRequest::_internal_application_id() const {
  return application_id_.Get();
}
inline void ChangeStatusRuntimeAndApplicationRequest::_internal_set_application_id(const std::string& value) {
  
  application_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::_internal_mutable_application_id() {
  
  return application_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::release_application_id() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.application_id)
  return application_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeStatusRuntimeAndApplicationRequest::set_allocated_application_id(std::string* application_id) {
  if (application_id != nullptr) {
    
  } else {
    
  }
  application_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), application_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.application_id)
}

// string project_id = 2 [json_name = "projectId"];
inline void ChangeStatusRuntimeAndApplicationRequest::clear_project_id() {
  project_id_.ClearToEmpty();
}
inline const std::string& ChangeStatusRuntimeAndApplicationRequest::project_id() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.project_id)
  return _internal_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeStatusRuntimeAndApplicationRequest::set_project_id(ArgT0&& arg0, ArgT... args) {
 
 project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.project_id)
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.project_id)
  return _s;
}
inline const std::string& ChangeStatusRuntimeAndApplicationRequest::_internal_project_id() const {
  return project_id_.Get();
}
inline void ChangeStatusRuntimeAndApplicationRequest::_internal_set_project_id(const std::string& value) {
  
  project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::_internal_mutable_project_id() {
  
  return project_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::release_project_id() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.project_id)
  return project_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeStatusRuntimeAndApplicationRequest::set_allocated_project_id(std::string* project_id) {
  if (project_id != nullptr) {
    
  } else {
    
  }
  project_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), project_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.project_id)
}

// string organization_id = 3 [json_name = "organizationId"];
inline void ChangeStatusRuntimeAndApplicationRequest::clear_organization_id() {
  organization_id_.ClearToEmpty();
}
inline const std::string& ChangeStatusRuntimeAndApplicationRequest::organization_id() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.organization_id)
  return _internal_organization_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeStatusRuntimeAndApplicationRequest::set_organization_id(ArgT0&& arg0, ArgT... args) {
 
 organization_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.organization_id)
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::mutable_organization_id() {
  std::string* _s = _internal_mutable_organization_id();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.organization_id)
  return _s;
}
inline const std::string& ChangeStatusRuntimeAndApplicationRequest::_internal_organization_id() const {
  return organization_id_.Get();
}
inline void ChangeStatusRuntimeAndApplicationRequest::_internal_set_organization_id(const std::string& value) {
  
  organization_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::_internal_mutable_organization_id() {
  
  return organization_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::release_organization_id() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.organization_id)
  return organization_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeStatusRuntimeAndApplicationRequest::set_allocated_organization_id(std::string* organization_id) {
  if (organization_id != nullptr) {
    
  } else {
    
  }
  organization_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), organization_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.organization_id)
}

// string runtime_name = 4 [json_name = "runtimeName"];
inline void ChangeStatusRuntimeAndApplicationRequest::clear_runtime_name() {
  runtime_name_.ClearToEmpty();
}
inline const std::string& ChangeStatusRuntimeAndApplicationRequest::runtime_name() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.runtime_name)
  return _internal_runtime_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeStatusRuntimeAndApplicationRequest::set_runtime_name(ArgT0&& arg0, ArgT... args) {
 
 runtime_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.runtime_name)
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::mutable_runtime_name() {
  std::string* _s = _internal_mutable_runtime_name();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.runtime_name)
  return _s;
}
inline const std::string& ChangeStatusRuntimeAndApplicationRequest::_internal_runtime_name() const {
  return runtime_name_.Get();
}
inline void ChangeStatusRuntimeAndApplicationRequest::_internal_set_runtime_name(const std::string& value) {
  
  runtime_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::_internal_mutable_runtime_name() {
  
  return runtime_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::release_runtime_name() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.runtime_name)
  return runtime_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeStatusRuntimeAndApplicationRequest::set_allocated_runtime_name(std::string* runtime_name) {
  if (runtime_name != nullptr) {
    
  } else {
    
  }
  runtime_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), runtime_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.runtime_name)
}

// string namespace = 5 [json_name = "namespace"];
inline void ChangeStatusRuntimeAndApplicationRequest::clear_namespace_() {
  namespace__.ClearToEmpty();
}
inline const std::string& ChangeStatusRuntimeAndApplicationRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeStatusRuntimeAndApplicationRequest::set_namespace_(ArgT0&& arg0, ArgT... args) {
 
 namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.namespace)
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.namespace)
  return _s;
}
inline const std::string& ChangeStatusRuntimeAndApplicationRequest::_internal_namespace_() const {
  return namespace__.Get();
}
inline void ChangeStatusRuntimeAndApplicationRequest::_internal_set_namespace_(const std::string& value) {
  
  namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::_internal_mutable_namespace_() {
  
  return namespace__.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::release_namespace_() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.namespace)
  return namespace__.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeStatusRuntimeAndApplicationRequest::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  namespace__.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.namespace)
}

// string runtime_id = 6 [json_name = "runtimeId"];
inline void ChangeStatusRuntimeAndApplicationRequest::clear_runtime_id() {
  runtime_id_.ClearToEmpty();
}
inline const std::string& ChangeStatusRuntimeAndApplicationRequest::runtime_id() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.runtime_id)
  return _internal_runtime_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeStatusRuntimeAndApplicationRequest::set_runtime_id(ArgT0&& arg0, ArgT... args) {
 
 runtime_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.runtime_id)
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::mutable_runtime_id() {
  std::string* _s = _internal_mutable_runtime_id();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.runtime_id)
  return _s;
}
inline const std::string& ChangeStatusRuntimeAndApplicationRequest::_internal_runtime_id() const {
  return runtime_id_.Get();
}
inline void ChangeStatusRuntimeAndApplicationRequest::_internal_set_runtime_id(const std::string& value) {
  
  runtime_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::_internal_mutable_runtime_id() {
  
  return runtime_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::release_runtime_id() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.runtime_id)
  return runtime_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeStatusRuntimeAndApplicationRequest::set_allocated_runtime_id(std::string* runtime_id) {
  if (runtime_id != nullptr) {
    
  } else {
    
  }
  runtime_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), runtime_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.runtime_id)
}

// string status = 7 [json_name = "status"];
inline void ChangeStatusRuntimeAndApplicationRequest::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& ChangeStatusRuntimeAndApplicationRequest::status() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeStatusRuntimeAndApplicationRequest::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.status)
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.status)
  return _s;
}
inline const std::string& ChangeStatusRuntimeAndApplicationRequest::_internal_status() const {
  return status_.Get();
}
inline void ChangeStatusRuntimeAndApplicationRequest::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationRequest::release_status() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeStatusRuntimeAndApplicationRequest::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationRequest.status)
}

// -------------------------------------------------------------------

// ChangeStatusRuntimeAndApplicationResponse

// string msg = 1 [json_name = "msg"];
inline void ChangeStatusRuntimeAndApplicationResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& ChangeStatusRuntimeAndApplicationResponse::msg() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeStatusRuntimeAndApplicationResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationResponse.msg)
}
inline std::string* ChangeStatusRuntimeAndApplicationResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationResponse.msg)
  return _s;
}
inline const std::string& ChangeStatusRuntimeAndApplicationResponse::_internal_msg() const {
  return msg_.Get();
}
inline void ChangeStatusRuntimeAndApplicationResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationResponse::release_msg() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeStatusRuntimeAndApplicationResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationResponse.msg)
}

// string error = 2 [json_name = "error"];
inline void ChangeStatusRuntimeAndApplicationResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& ChangeStatusRuntimeAndApplicationResponse::error() const {
  // @@protoc_insertion_point(field_get:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeStatusRuntimeAndApplicationResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationResponse.error)
}
inline std::string* ChangeStatusRuntimeAndApplicationResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationResponse.error)
  return _s;
}
inline const std::string& ChangeStatusRuntimeAndApplicationResponse::_internal_error() const {
  return error_.Get();
}
inline void ChangeStatusRuntimeAndApplicationResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeStatusRuntimeAndApplicationResponse::release_error() {
  // @@protoc_insertion_point(field_release:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeStatusRuntimeAndApplicationResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pipelines.tekton.v1alpha1.ChangeStatusRuntimeAndApplicationResponse.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace tekton
}  // namespace pipelines

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pipelines_2ftekton_2fv1alpha1_2ftekton_5fapi_2eproto
